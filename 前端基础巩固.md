## 伪元素选择器
1. last-child选择器是选择父元素的最后一个元素的所有xx元素，不好用。。
2. `一般来说，想要选择同名元素中的最后一个，就这样使用`
```
<div id="one">
			<div class="a">1</div>
			<div class="a">2</div>
			<div class="a">3</div>
</div>

//这样就可以选中最后一个class类名为a的元素啦！
//需要注意的是，.a元素必须是某元素中的子元素，不能是根元素
.a:last-child{
	color: red;
}
```
3. 第二种情况
```
<div id="one">
			<div class="two">
				<div class="a">1</div>
				<div class="a">2</div>
			</div>
			<div class="a">3</div>
		</div>
//此时是2,3都变色，因为他们都是各自父元素的最后一个.a类名的元素
```
4. nth-child(n)选择第n个元素
```
		<div id="one">
			<div class="a">1</div>
			<div class="a">2</div>//红
			<div class="a">3</div>
		</div>
		//选择第二个.a元素
		.a:nth-child(2){
			color: red;
		}
```
5. nth-child(2n)选择偶数元素
```
	//只选择偶数的.a元素，奇数的话选择(2n-1)
	.a:nth-child(2n){
		color: red;
	}
	<div id="one">
			<div class="a">1</div>
			<div class="a">2</div>//red
			<div class="a">3</div>
			<div class="a">1</div>//red
			<div class="a">2</div>
			<div class="a">3</div>//red
		</div>
	//需要注意的是，始终是针对一个父元素来说的
	<div id="one">
		<div class="a">1</div>
		<div class="a">2</div>//red
		<div class="a">3</div>
		<div>      //因为父元素不同，所以计数的索引重新开始
			<div class="a">1</div>
			<div class="a">2</div>//red
			<div class="a">3</div>
		</div>
	</div>
```
6. nth-child(n+3)表示是从第三个开始之后的所有元素(包括第三个)
```
.a:nth-child(n+3){
	color: red;
}
<div id="one">
			<div class="a">1</div>
			<div class="a">2</div>
			<div class="a">3</div>//red
			<div class="a">1</div>//red
			<div class="a">2</div>//red
			<div class="a">3</div>//red
		</div>
```
7. nth-child(-n+3),=>3,2,1,0,-1....(0之后的都不算),所以指代1开始到3的元素
8. nth-last-child(2),选择倒数第二个元素
9. `如何选择某个父元素下最后一个xx元素呢？`
```
//通过子选择器指定某个父元素下的子元素，然后通过last-child指定该父元素下的最后一个xx子元素
.two .a:last-child{
				color: red;
			}
			
<div id="one">
			<div class="a">1</div>
			<div class="a">2</div>
			<div class="a">3</div>
			<div class="two">
				<div class="a">1</div>
				<div class="a">2</div>
				<div class="a">3</div>
			</div>
		</div>
```

## a标签链接
1. 锚点链接:`在一个文件可以定义多个锚点，点击a链接可以跳转到锚点所在位置`
```
<div id="one">
			<div class="d" id="t">2</div>
			<div class="two" style="height: 2000px;">
				<div class="a">1</div>
			</div>
			<a href="#t">ww</a>
		</div>
```
* `需要注意的是，锚点定位要使用id,使用class无效；并且要在页面高度足够滚动的时候才能看出效果`
2. 功能性链接:`点击链接可以跳转到外部文件或者启动其他程序`
3. 双向定位:(文件之间，文件两处地方都可以双向定位)
```
<div class="two" style="height: 2000px;">
				<div class="a">1</div>
				<a href="#w" id="t">双向定位</a> //可以从这里跳转到本文件的#w处
			</div>
			<a href="#t" id="w">ww</a>//可以从这里跳转到本文件的#t处
```
4. 单向定位
```
<div class="two" style="height: 2000px;">
				<div class="a">1</div>
				<a href="one.html#w" id="t">单向定位</a> //可以跳转到某文件的某个锚点处
			</div>
```
5. [参考](https://blog.csdn.net/cccdf_jjj/article/details/80930148)

## opacity继承的问题(父元素设置透明度，子元素必定继承！)
1. 遇到的实际问题:父元素设置圆角背景透明度，子元素是黑体字，但是子元素因为父元素是白色0.5透明，所以子元素也变得透明，此时的黑是模糊的黑！
2. 原因:`如果父元素设置了opacity属性，那么子元素必定会继承！`
3. 解决方法：
```
1. 使用rgba()来代替opacity，rgba也能设置透明度，但是不会被子元素继承，
2. 失败:对子元素使用z-index:2,尝试提高子元素优先级(提高了优先级，但是不会影响到继承问题)，但是子元素依旧继承父元素透明度，失败！
3. 失败:对子元素使用opacity:1,虽然对子元素设置样式的优先级高于继承的优先级，但是子元素的opacity:1也是基于父元素的opacity来设置的，所以依旧是低于预期效果(可以进一步在父元素opacity的基础上降低透明度，但是提高是没办法的)

```

## canvas
1. 实际应用:`在小程序中制造分享海报的时候需要用到canvas自己画图，想到做app也需要，所以学了一下js的canvas`
```
<div>
			<canvas id="one" width="600" height="600"></canvas>
			<img src="one/3.jpg" id="two">
		</div>

function draw(){
				var canvas=document.getElementById('one');
				if(!canvas.getContext) return;
				var can=canvas.getContext('2d');
				// canvas对于每个图形的起点都是0,0,即使指定起点,也是相对位置,所以图形都需要指定相对坐标
				can.beginPath(); //每创建一个图形都要开始一个路径
				// can.arc(100,100,50,0,Math.PI/2,false);
				can.strokeRect(50,50,50,50);//该方法可以绘制矩形,不需要使用stroke
				can.fillStyle='rgb(153,153,153)'
				
				can.beginPath();
				can.font='20px sans-serif';//字体样式要设置在文本之前,否则无效
				can.strokeText('我在下遗憾',50,150);//绘制的是文本边框
				can.fillText('我在下遗憾',50,200);//绘制文本
				// can.closePath();//从起始点到当前点画线,有点多此一举!
				// can.stroke();//通过线条来绘制图形轮廓
				
				can.beginPath();
				var img=document.getElementById('two');
				//必须在图片加载完再绘制图片,否则会失效
				img.onload=function(){
					can.drawImage(img,50,250,100,100);
				}
				
				can.beginPath();
				var img2=new Image();//可以自己创建一个图片元素
				//指定一个src属性
				img2.src='https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture'
				img2.onload=()=>{
					can.drawImage(img2,50,400,100,100)
				}
			}
			draw()

```
* 弧度和度数换算:`1度=PI/180*弧度`，`需要注意的是cancas中绘制图形使用的是弧度`
* [强烈推荐](https://blog.csdn.net/u012468376/article/details/73350998)

## js动态类型语言
1. `静态类型语言在编译时便确定变量的类型`
2. `动态类型语言在编译结束之后，在程序运行，变量被赋予某个值之后，才具有某个类型`
3. `JavaScript是动态类型语言`

## js的多态
1. 多态:`给不同对象发送同一个命令，不同对象会做出不同的操作，给出不同的反馈`
2. 通俗来说:`导演说action,演员开始演戏，摄影师开始拍，龙套在后台在准备，虽然是同一个命令，但是不同对象会有不同的反应`
```
			var makeSound=function(Animal){
				//	instanceof用于指出某对象是否是特定对象的实例,在此时就是判断是否存在该函数
				if(Animal.sound instanceof Function){
					Animal.sound();//执行不同的对象的同一个方法,得到不同的反馈
				}
			}
			
			var cat=function(){};
			cat.prototype.sound=function(){
				console.log('喵喵喵')
			};//使用prototype,该cat函数的实例对象的__proto__属性就可以指向sound方法
			
			var dog=function(){}
			dog.prototype.sound=function(){
				console.log("汪汪汪")
			}
			
			makeSound(new cat());
			makeSound(new dog());
			//此时如果想再添加一个对象chicken就只需要创建函数及sound函数就可以了,调用makeSound就可以实现多态
			//调用不同的对象的sound方法可以得到不同的反馈
			var chicken={
				sound:function(){
					console.log('咕咕咕')
				}
			}
			makeSound(chicken);//再创建一个chicken对象，给该对象添加sound方法
```
* 与java不同，Java是静态类型语言，需要在使用之前指定对象类型，那么该命名为dog/cat?都不同，应该给他们添加一个超类型animal,dog/cat extends animal 这样就可以实现多态了！
* `多态的最根本好处就在于可以把过程化的条件语句(if dog,else if cat...)转换为对象的多态特性，不必询问对象类型，只要对象具有该行为，那么只管调用该行为就可以了`




## js的封装
1. `一般来说，js的封装指的是将信息隐藏，封装数据和封装实现，还可以封装类型和封装变化`
2. 在java这些语言中，通过public private关键字设置访问权限实现对数据的封装特性
3. 在JavaScript中没有提供对这些关键字的支持，我们只能通过依赖变量的作用域来实现封装特性，并且只能模拟出public,private特性
```
			var one=(function(){
				var name='sada';//相当于private私有变量
				return {
					getName:function(){  //相当于public公有方法
						return name;
					}
				}
			})();
			console.log(one.getName());//通过公有方法访问到私有变量
			console.log(one.name);//不能直接访问到私有变量
```
4. 想办法把程序中变化的部分封装好之后，剩下的就是稳定而可复用的部分了

## 设计模式之一(原型模式)--实现继承
1. `原型模式是一种用于创建对象的模式，如果我们想创建一个对象，那么一般先指定对象类型，然后通过类来创建这个对象`
2. `原型模式不再关心对象的具体类型，而是找到一个对象，通过克隆的方式来创建一个一模一样的对象`
3. `如果需要一个跟某个对象一模一样的对象，那就可以使用原型模式；但是使用原型模式需要注意该语言是否提供了克隆的方法，javascript中就是Object.create方法`
```
			var one=function(){
				this.name='one';
				this.age=22;
			}
			var two=new one();
			console.log(two);
			two.name='two';
			two.age=11;//改变实例的属性
			console.log(two);
			//通过Object.create方法克隆一个和two实例一模一样的对象
			var two_child=Object.create(two);
			console.log(two_child);//two_child.__proto__指向two
			// 有些浏览器可能不支持Object.create方法,则使用
			Object.create=Object.create||function(obj){
				var F=function(){};
				F.prototype=obj;// 所以使用Object.create方法克隆其实就是创建一个对象指向obj,然后返回该对象的实例,由于该实例没有重新定义属性方法,所以自然寻找不到,就会通过__poto__属性往上查找到two对象,也就实现了克隆
				return new F();
			}
```
4. 原型模式同时也是一种编程范式，也存在原型编程的基本规则
* 1.所有书都是对象(但是在js中存在基本数据类型，所以js是绝大数是对象，但是所有对象都存在一个根对象，所有的对象都可以通过__proto__追溯到该对象)
```
			var one=new Object();
			// Object.getPrototypeOf()方法可以获取到对象的原型
			console.log(Object.getPrototypeOf(one));
			console.log(Object.getPrototypeOf(one)===Object.prototype);//true
			// 也就表明了通过new Object()得到的one实例的原型是Object.prototpe 
			// 并且js中所有的对象的原型(或者是最终原型指向)都是Object.prototype
```
* 2.要得到一个对象，不是通过实例化类，而是通过找到一个对象作为原型并克隆它
* `但是js一般不是通过new来创建对象吗？的确是，但是new运算符来调用函数时，此时的函数就是一个构造器`
* `使用new运算符来创建对象的过程其实就是先克隆Object.prototpe对象，然后再通过一些操作来进行克隆的过程`
* 3.对象会记住他的原型(`通过__proto__隐藏属性`)
* `每个对象的__proto__属性默认会指向它的构造器对象，也就是{Construtor}.prototype`
* 注意:不是所有浏览器都会公开__proto__属性
```
			var one=new Object();
			console.log(one.__proto__===Object.prototype);//true
			
			var Person=function () {};
			//修改obj对象的__proto__指向
			one.__proto__=Person.prototype;
			console.log(one.__proto__===Person.prototype);
```
* 4.如果对象无法响应某个请求，那么它会把该请求委托给它的构造器的原型，直到要一个可以处理该请求的对象为止
* `虽然在js中，每个对象的原型都是Object.prototype,但是通过修改__proto__指向可以改变对象原型`
```
//闭包封装
			var one=(function(){
				return {
					getName:function (name){
						return name;
					}
				}
			})();
			var one_child=function(){};
			// var one_child_child=new one_child();
			// console.log(one_child_child.getName('yiyi'));//往上找getName()方法,但是不存在
			
			one_child.prototype=one;//修改one_child原型指向为one函数
			var one_child_child=new one_child();
			console.log(one_child_child.getName('dsa'));//改变原型后,可以往上找到方法,这也就是继承,也就是原型链
```
* `任何对象，除了Object.prototype之外，都会有原型，而通过Object.create(null)可以创建出没有原型的对象`

## 强制类型转换
```
			// 强制类型转换 Number
			console.log(Number('2'));//2
			console.log(Number(null));//0
			console.log(Number(undefined));//NaN
			console.log(Number(NaN));//NaN
			console.log(Number([]));//0
			console.log(Number({}));//NaN
			
			// 强制类型转换String(相当于调用了 xx.valueOf().toString())
			console.log(String(1));//'1'
			console.log(String([])==='');//'',true,空数组被强制转换为''空字符串
			console.log(String({}));//object Object 
			console.log(String(undefined));//undefined
			console.log(String(null));//null
			console.log(String(NaN));//NaN
			// 这也从侧面解释了为什么 null==0是 false,因为关系运算符是把数据先转换为字符串的,也是调用valueOf().toString()方法
			
			// 强制类型转换 Boolean
			console.log(Boolean(1));//true
			// 强制转换为Boolean,除了'',0,NaN,undefined,null,false之外,其他的都会转为true
			console.log(Boolean([]));//true
			console.log(Boolean({}));//true
```

## 元素嵌套规则
1. p元素不能包含任何`块级元素`(包括自身)
* 因为在p元素中嵌套其他块级元素的话，最后解析就会当做两个p元素包裹着其他块级元素来处理
```
				<p>p元素不能嵌套元素
					<div>p元素可以嵌套内联元素？</div>
				</p>
				=>等于
				<p>p元素不能嵌套元素</p>
					<div>p元素可以嵌套内联元素？</div>
				<p></p>
				
				但是把块级元素改为内联元素又可以
				<input type="button" name="" id="" value="two" class="two" />
```
2. a元素可以包含任何其他元素(`除了自身`),因为a标签会自动添加结束符号
```
<a href="#">
				xx
				<a href="">yy</a>
			</a>
		=>被渲染为
		<a href="#">
			xx
			</a>
			<a href="">yy</a>
			//a标签包含a标签的话会自动添加结束符号
		
```
```
<a href="#">
				xx
				<div>yy</div>
			</a>
			//a标签包含div标签显示正常
```
3. 块元素可以包含内联元素和某些块级元素，内联元素却不能包含块级元素，内联元素只能包含内联元素
4. 这些块级元素只能包含内联元素不能包含块级元素，如:h1,h2,p,dt
5. li标签可以包含div标签,ol,ul标签
6. [a](https://www.cnblogs.com/tu-0718/p/6635212.html)
7. [参考](https://www.cnblogs.com/sunmarvell/p/9583419.html)

## button会有边缘线(影响美观)
1. `在实际应用中，我发现button按钮存在边缘线，但是自己没有设置样式，那么就是button自带的样式`
2. `给应用的button改变样式，之前是button::after自带border样式自带边缘线，所以把button::after的border:none`

## 判断整数
1. 对于正整数，如果要判断是否是整数，那么可以`num%1==0，如果能取余1，那么就是正整数`
2. 或者通过Math操作,`对数据进行Math.floor取下，Math.ceil取上，Math.round四舍五入等操作，如果操作之后还是跟原来的自己相等，那么就是正整数`

## new 数据类型的原始值
1. console.log(new Boolean());//PrimitiveValue原始值为false
2. console.log(new Number());//PrimitiveValue原始值为0
3. console.log(new String());//PrimitiveValue原始值为""空字符串
4. console.log(new function(){});//PrimitiveValue原始值为{}

## 图片下面有间隙？
1. [参考](https://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&mid=2649092548&idx=3&sn=f6e37f79dcbe10854fa3a31d8ba2be68&chksm=be5bd669892c5f7fcf528fcd27d2f714da4ffc89da7383ae09c7629ea46b2de47f071476b34d&mpshare=1&scene=1&srcid=&sharer_sharetime=1573833643584&sharer_shareid=53e5faa8096c16b54c2c13fcf6c34ab4&key=49517593695748bd684dc8407ae44b86037616ea80aed7d4a2619e3892644be834c513d864f8fac4cb4350c729b0ae96a8a9f58db194a195d583f5fba87b9786bcd5d861ebb36c177cc544f2d0292a46&ascene=1&uin=NTU0NzM3Mzcy&devicetype=Windows+10&version=62060833&lang=zh_CN&pass_ticket=MPifW5Vm%2BuiA%2Bwk%2F5e0i2%2ByewxX1MetKfB31whIud5Yx%2FALo8TW3rR3b7w4nsz21)
2. 行内框盒子模型分为内容区域(content area)，内联盒子(inline boxes)，行框盒子(line boxes)，包容盒子(containing box)
---
1. content area内容区域是一种围绕文字的看不见的盒子，大小只和font-size有关(也就是紧紧包着文字)，与line-height无关。
2. inline-boxes内联盒子让文字排成一排而不是成块显示，例如span就是一个内联盒子，而没有span这种内联盒子包裹，仅仅是文字的被叫做匿名内联盒子(内联盒子的大小和line-height一样)
3. line-boxes行框盒子由一个个内联盒子组成(一行就是一个行框盒子)`需要注意的是，在行框盒子中，整个行框会有两条基线，两条基线之间的距离就是行高，也就是行框的空间`
4. containing-box包容盒子由一个个行框盒子组成
5. `line-height(行高)=font-size(字体大小)+vertical-spacing(行间距);(行间距vertical-spacing/2的高度就是第一行距离第二行的高度) font-size高度就是内容区域的高度，line-height的高度就是内联盒子的高度，而行框盒子由一个个内联盒子组成，所以行框盒子的高度也是和line-height一样`
6.  `但是没有vertical-spacing行间距这个属性，所以需要借助line-height实现行间距`
---
* 图片下面有间隙？
1. `创建一个div，div里面有一个img元素，而img元素默认是基线对齐，也就是vertical-align:baseline`
```
		<div class="one">
			<img src="one/3.jpg" >
		</div>
		
		.one{
			border: 1px solid red;
			width: 400px;
		}
		img{
			width: 200px;
			height: 202px;
			/* height: 202px;是为了消除border的影响 */
		}
```
* 为了方便观察，把图片的height加上border的值*2，然后调整vertical-align就能看出区别
* `所以我们把vertical-align设置为bottom就可以消除图片下面的边距啦！虽然用top,middle也有效果，但是如果存在同行的元素，那么就能看出另一个元素对齐了图片的底部，中间，顶部了`
---
* 去除图片底边距的方法还有`把图片设置为display:block;因为块级元素不存在基线对齐的问题，块级元素不需要对齐！`
* `因为两条基线(一行文本一条基线，基线在底线之上)之间的距离就是line-height,所以给父元素设置基线为0就可以让父元素的行间距消失！`
* `如果给父元素设置行高line-height为0，那么父元素的高度完全由子元素决定，子元素对齐的基线也就是自己的基线！`
* `给子元素设置vertical-align:baseline;其实就是跟父元素的基线对齐`

## 深入理解line-height行高
1. [参考](https://www.cnblogs.com/oxspirt/p/10370203.html)
2. `line-height属于可继承的css属性之一`
---
1. 百分比继承
* `对于一个元素,font-size:20px;line-height:120%;那么计算之后的的行高也就是24px(注意，继承的是24px而不是百分比！);这个属性会被子元素继承为font-size的值，子元素即使自己设置了font-size(内联样式)也无效，但是子元素自己设置的行高有效！`
* `提出一个问题？行高小于font-size的时候(此时的元素占据空间为line-height,但是font-size没有改变，所以可能出现文字重叠)基线在哪里？`
2. 长度
* 对line-height设置长度，那么子元素继承的就是长度(`还是那句话，子元素自己设置的font-size会被line-height覆盖，但是子元素的line-height可以覆盖继承的line-height`)
3. normal
* `对于不同的浏览器来说，normal的值不一样，一般为1.2,`，normal也会被子元素继承，继承的是`倍数，子元素的line-height就是根据继承的倍数*font-size计算得出的`
4. 纯数字(倍数)
* 对行高设置为纯数字，其实也即是设置为font-size的倍数,`继承的是倍数`
---
* `对于一行文本来说，存在四线三格(英文中的)，从顶部到底部分别是顶线，中线，基线，底线`
* `content area内容区域也就是顶线和底线之间的区域`

## vertical-align
1. `vertical-align用来指定行内元素或者表格元素的垂直对齐方式`，下面说一下取值
2. baseline:基线，`自身的基线与父盒子的基线对齐，如果没有自身基线，比如img,那么外边距底部边缘和父盒子的基线对齐`
3. `虽然还想写下去，但是。。发现懵了，vertical-align貌似除了父元素，还要有两个子元素才能实现处居中效果，而且不是相对父元素居中，而是两个子元素的相对居中`
4. [参考](https://www.cnblogs.com/starof/p/4512284.html)
5. `还有父元素的x-height一般来说对于不同浏览器不一样，谷歌的font-size默认是16px,字体是sans-serif,所以x-height的一般大概是3-4px`

## 水平间隙垂直间隙总结
1. `水平间隙一般是因为文本之类的原因，例如li,span等元素，可以把元素紧贴在一起，不换行，如:<li></li><li></li>;<span>两个元素之间没有间隙</span><span>没有间隙</span>`
2. `垂直间隙一般是因为默认使用了vertical-align:baseline；对齐了父元素的基线，所以可以使用vertical-align:middle解决，或者给父元素设置line-height:0;或者把内部元素设置display:block;因为块级元素是没有vertical-align对齐烦恼的`

## 数组reduce方法
```
			var arr=[3,2,5,4];
			console.log(arr.reduce((x,y)=> x+y ));
			//相当于3+2=5; 5+5=10;10+4=14;把每次运算之后的结果跟下一个元素一起运算,再次作为下一组运算的初始值
			
			console.log(arr.reduce((x,y)=> x+y,10));
			//reduce可以有两个参数,第一个参数是运算的函数,第二个参数是可选的,设置初始值
			//此时相当于 10+3=13;13+2=15;15+5=20;20+4=24;
```

## 如何获取函数中的参数名称和个数?
1. `注意，arguments对象是跟function分不开的，arguments对象不能显式创建；arguments对象只有函数开始时才能使用`
2. `js中每个函数都会有Arguments对象实例arguments,arguments引用着函数的实参，arguments.length表示函数长度，arguments.callee引用函数本身`
3. `虽然arguments不是数组，但是跟数组的使用方式很相似`
```
function test() {
        var s = "";
        for (var i = 0; i < arguments.length; i++) {
            s += arguments[i] + ",";
        }
        return s;
}
console.log(test("name", "age"));

输出结果：
name,age
```
4. `this指向问题`
```
			var length = 10;
			function fn() {
			  console.log(this.length);
			}

			var obj = { 
			  method: function(private_fn) {
				private_fn();//此时的private_fn其实是window.fn();默认绑定
				arguments[0]();//隐式绑定？
			  }
			};
			obj.method(fn); 
			
			var arr=[function(){ console.log(this.length)},1,"隐式绑定？","如果是隐式绑定，那么该返回的是该数组的长度4"];
			arr[0]();//没错,就是4!虽然window.length=10;但是arr[0]()这种方式其实是隐式绑定,就是arr对象去调用自己的属性方法,所以自己的属性方法指向的this就是本身
```
5. 获取形参个数
```
			function getSimple(a,b,c){
				console.log("形参")
			}
			console.log(getSimple.length)
```
6. `arguments.callee指的就是当前参数所在的函数，可以当做函数使用，arguments.callee.length也可以获取函数形参个数`

## this的四种绑定
1. 默认绑定
* `当一个函数没有明确的被对象调用的时候，也就是单纯作为独立函数被调用的时候，对函数的this使用默认绑定，绑定到全局的window`
```
			var a=10;
			function getSimple(){
				console.log("默认绑定，默认绑定到window:"+this.a)
			}
			getSimple();//此时的函数是单纯作为独立函数被调用，所以this被默认绑定到window
```
* `在函数内部调用另一个函数，只要是作为独立函数被调用，那么都是默认绑定到window`
```
			var a=10;
			function getSimple(){
				function inner(){
					console.log("默认绑定，默认绑定到window:"+this.a)
				}
				inner();//此时的inner函数在别的函数内部,但是依旧是作为独立函数被调用,所以this依旧被默认绑定到window 
			}
			getSimple()
```
* `在被隐式调用的对象属性的调用函数，只要还是作为独立函数被调用，那么就还是被默认绑定到window`
```
			var a=10;
			var obj={
				a:5,
				inner:function (){
					console.log("此时使用obj.inner隐式绑定，Inner函数的确被obj对象隐式绑定了"+this.a);//5
					function inner_in(){
						//但是inner_in函数是作为独立函数被调用的,并没有被obj对象隐式调用,所以依旧被默认绑定到window
						console.log("默认绑定，默认绑定到window:"+this.a);//10
					}
					inner_in()
				}
			}
			obj.inner();
```
2. 隐式绑定
* `当一个函数被一个对象"包含"的时候，我们就称this被隐式绑定到对象中了，此时通过this可以直接访问对象中的其他属性`
```
			var a=10;
			var obj={
				inner:function(){
					console.log(this.a);//10000
				},
				a:10000
			}
			obj.inner();
```
* `对象属性动态绑定函数(函数声明在对象外部)和一开始就绑定函数是一样的效果`
```
			var a=10;
			function my(){
				console.log(this.a);//10000
			}
			var obj={
				inner:my,
				a:10000
			}
			obj.inner();
```
* `从上面两个例子可以看出，this是动态绑定的，不是一定要声明在对象内部才会被对象调用；函数不是完全被对象所拥有的，具有一定的独立性`
* `隐式绑定中的this传递丢失问题`
```
			var a=10;
			function my(){
				console.log(this.a);//10000
			}
			var obj={
				inner:my,
				a:10000
			}
			var out=obj.inner;//此时的out对象就相当于obj对象中的inner函数，并且跟obj对象没关系了！
			out();//因为此时只是inner函数被绑定到out中，而out是作为一个独立函数被调用，所以此时是被默认绑定到window对象中
```
* `隐式绑定中this传递丢失另一种情况`
```
			var a=10;
			function my(){
				console.log(this.a);//10000
			}
			var obj={
				inner:my,
				a:10000
			}
			function other(fn){
				fn();//此时作为独立函数被调用,所以默认绑定到window
			}
			var out=obj.inner;
			other(out);
```
* `隐式绑定中，如果存在多层对象属性链，那么this被绑定到最内层的对象`
```
			var a=10;
			var obj={
				a:1,
				obj2:{
					a:2,
					obj3:{
						//a:4,
						out:function(){
							console.log(this.a)
						}
					}
				}
			}
			obj.obj2.obj3.__proto__=window;//如果添加这条语句，那么obj.obj2.obj3.__proto__=window;对象的原型就指向window，那么obj的方法所需要的a属性就可以通过原型链去查找到window.a
			obj.obj2.obj3.out();//如果不给obj3帝乡一个a属性，那么就输出undefined
			//需要注意的是，如果最内层直接调用函数的对象不存在函数this所需要的属性的话
			//那么此时会输出undefined，因为这个时候跟原型链无关！this指向的对象没有原型可以寻找
			//如果把指定__proto__属性语句改为obj.obj2.obj3.__proto__=obj.obj2;那么输出为2
```
* `需要注意的是，1.所有函数具有prototype属性(显式原型)；2.所有对象都具有__proto__属性(隐式原型);3.原型对象——在定义的时候就被创建，是具有prototype属性的对象`
* `另外在隐式绑定中，还有一种很隐蔽的隐式绑定，看起来是作为独立函数被调用，其实是自己去调用自己的方法，所以指向自身`
```
			var length = 10;
			function fn() {
			  console.log(this.length);
			}

			var obj = { 
			  method: function(private_fn) {
				private_fn();//此时的fn其实是window.fn();默认绑定
				arguments[0]();//隐式绑定？
			  }
			};
			obj.method(fn); 
			
			var arr=[function(){ console.log(this.length)},1,"隐式绑定？","如果是隐式绑定，那么该返回的是该数组的长度4"];
			arr[0]();//没错,就是4!虽然window.length=10;但是arr[0]()这种方式其实是隐式绑定,就是arr对象去调用自己的属性方法,所以自己的属性方法指向的this就是本身
```
3. 显式绑定
* `显式绑定就是利用call,apply,bind函数指定该方法被哪个对象绑定`
```
			var a=10;
			var obj={
				a:4,
				inner:function(){
					console.log(this.a)
				}
			}
			var one=obj.inner;
			one();//this在隐式绑定中丢失了，此时使用的是window.a
			obj.inner();//隐式绑定,没有丢失,此时是使用obj.a
			one.call(obj);//使用call方法把函数obj.inner()显式绑定给obj对象,这样就不会出现this丢失的问题!
```
* 但是如果不想要每次调用one函数都需要加上call该怎么办？那就给One对象加上一层函数,每次调用one对象就会自动调用想要的函数
```
			var obj={
				a:4,
				inner:function(){
					console.log(this.a)
				}
			}
			var one=function(){
				return obj.inner.call(obj);
			}
			one();//此时的inner函数的this指向的是obj!
```
* js还提供了一种更加简单的this绑定方法，bind`bind方法不会直接调用函数，而是返回改变了this指向之后的函数`
```
把 one那个语句改为 var one=obj.bind(obj);
				 one();
```
* 此外，`js还提供了一种改变this指向的方法apply,apply方法和call方法的不同之处就在于当执行的函数存在多个形参的时候，call是一个个参数传递，而apply方法是把所有参数都作为一个数组传递，即使只存在一个参数也是数组`
```
			one=function(){
				// return obj.inner.call(obj,2,3);
				return obj.inner.apply(obj,[2,3]);//输出结果和call方法时一致
			}
			one=obj.inner.bind(null,1,1);//此外，bind方法也是一个个参数的形式
```
* `注意，call/apply/bind方法的第一个参数指的是this指向的对象，如果为null/undefined的话那就是默认绑定为window`
* `显式绑定和隐式绑定的区别就是隐式绑定只是给函数临时绑定一个对象，函数的this指向很可能会改变，而显示绑定的话，绑定了就不会改变`
4. new绑定
* `this的绑定方式有四种，按照优先级分别是new绑定，显式绑定，隐式绑定，默认绑定`
* `new绑定其实也是实现多态的一种方式`
```
			var obj=function(name,age){
				this.name=name;
				this.age=age;
			}
			var one=new obj('张三',11);
			var two=new obj('李西',12);
			console.log(one.name,one.age);
			console.log(two.name,two.age);
```
* 通过new绑定的方式把对象的this指向新创建的新对象
5. [参考](https://www.jb51.net/article/121164.htm)

## 位运算符与逻辑运算符
1. `位运算符|,&   不是逻辑运算符||，&& !!! 铭记这一点，必须区分开`
2. 位运算符| `运算规则是对于每一位，只要有一位的数字是1，那么该位的数字就是1`
3. 位运算符& `运算规则是对于每一位，必须该位的都是1，该位的数字才是1`
```
			console.log(3|1);// 3,1分别转换为位是 11,01  ,11 =>3
			console.log(9|2);// 9,2转换为位是 1001,0010,=>1011=> (8+2+1)=>11
			
			console.log(3&1);// 3,1分别转换为位是 11,01, 01 =>1
			console.log(9&2);// 9,2转换为位是 1001,0010,=>0000=> 0
```
* `当对非数字数据类型使用位运算符的时候，先把数据转换为数字类型(NaN(虽然NaN也是Number数据类型)/null/undefined在位运算中相当于0)`
```
			console.log(false|9);//9
			console.log(null&9);//0
			console.log(true|9);//0001,1001 =>1001 => 9
			console.log(true&9);//0001,1001 =>0001 => 1
			console.log(NaN|9);//9
			console.log(NaN&9);//0
```
4. 逻辑运算符|| `如果第一个数是true,那么就不需要判断后面的数据，直接输出第一个数，否则继续后面的数，直到为true，或者都不为true,那就返回最后一个数`
5. 逻辑运算符&& `如果第一个数是false,那么就直接返回false,不需要判断后面的数据。直到找到false,或者全部都是true,那就返回最后一个值`
```
			console.log(false||9);//9
			console.log(NaN||false||1);//1
			console.log(true||9);//true,在||或逻辑运算中,返回第一个true
			console.log(true&&9);//9,在&&与逻辑运算中,返回最后一个true
			console.log(1&&9&&true);//true
```
6. 在逻辑运算中，`NaN/null/undefined相当于false`
7. [参考](https://blog.csdn.net/zhang918784312/article/details/82873485)

## promise
1. [参考](https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247484844&idx=1&sn=2d18d58986e3386d3dd1babb9323d6e7&chksm=fa2be545cd5c6c53f2d44bbafca33c65b114f30402e160fe48ab9fb6657cdab88b9f07309112&scene=0&xtrack=1&key=7200d6da4529fd32ab1e2c09f38b8e7582f4eab339757c586f3d16684ffce69b4875f78b38e8bf72c04d47a44fad58fe9c39e25a892365c3ab5947d89974827d87ad10346aab409390fd1c27a0bc5cb1&ascene=1&uin=NTU0NzM3Mzcy&devicetype=Windows+10&version=62070158&lang=zh_CN&pass_ticket=FlUxpH3VsNAa5B3p0KxidJpy7p5nIor6oGxFYQAiYJn%2FA1323oVhM%2BfVxX12otvW)

## 点击image无效？
1. `image是绝对定位，在input按钮之上，不知为何，点击会无效果，增加z-index:2之后反而好了，为1却也不行！`
```
  但是奇怪的是，在复现问题的时候，发现可以点中图片！
  <div class="one">
  	<input type="text" placeholder="image点击失效？" onclick="alert('点击input')"/>
  	<img src="./one/3.jpg" alt="这是没网络显示时的" title="img失效" onclick="alert('能点中图片？')">
  </div>
  .one{
  	position: relative;
  	width: 200px;
  	height: 40px;
  	text-align: center;
  }
  .one input{
  	width: 100%;
  	height: 30px;
  	line-height: 40px;
  	/* 垂直居中lne-height=父元素height是不行的，因为这不是文字！ */
  }
  .one input::-webkit-input-placeholder{
  	color: blue;
  	/* padding-left: 50px; */
  }
  .one img{
  	position: absolute;
  	left: 20px;
  	top: 10px;
  	width: 20px;
  	height: 20px;
  }
  //并且图片和文字重合时，图片的优先级更高，出现的是图片的点击事件
  ::-webkit-input-placeholder给placehodler添加样式需要针对不同浏览器使用不同样式
  /* 垂直居中lne-height=父元素height是不行的，因为这不是文字！ */

```
## 文本框中的文字垂直居中
1. `设置text-align:center;水平居中line-height行高为文本框高度(也就是高度在中间，行间距填满剩下的文本框高度)`
```
			<div class="btn">
				<span>水平垂直都居中</span>
			</div>
			.btn{
				width: 100%;
				height: 40px;
				background: rgba(90,90,90,.7);
				text-align: center;//水平居中
			}
			.btn span{
				line-height: 40px;//line-height=父元素的height，垂直居中
				font-size: 20px;
			}
```
* `另外如果想要让文本框宽度随文本数量而自适应，那么文本框应该是inline-block;如果是block则会自动宽度100%`

## css样式覆盖
1. `css样式在优先级相同的情况下，遵循后来者居上的原则，写在后面的反而优先级比前面的更高`
2. `例如一个元素的类名为one, .one{color:red;}  然后在后面又写了 .one{color:blue;}那么实际显示的是后来的样式(重复的部分),也就是蓝色`

## 瀑布流布局
```
			<div class="pubu">
				<div class="column">
					<img src="one/3.jpg" >
					<img src="one/4.jpg" >
					<img src="one/5.jpg" >
					<img src="one/3.jpg" >
				</div>
				<div class="column">
					<img src="one/5.jpg" >
					<img src="one/3.jpg" >
					<img src="one/3.jpg" >
					<img src="one/4.jpg" >
				</div>
			</div>
			<!-- 页面结构为
				1 1
				2 2
				3 3 
				4 4
				一一对应，所以不应该增加column数量，如果确定只有两列，那么新增加的元素
				就必须加进这两列其中之一！-->
			.pubu{
				display: flex;
				flex-direction: row;
				flex-wrap: wrap;
			}
			.column{
				flex-direction: column;
				width: calc(100%/2 - 10px);
				/* 注意，calc函数可以使用+-* /,但是 + - 必须前后都有空格！
				 所以建议乘除 * /前后也要用空格 */
				display: flex;
			}
			.column img{
				padding: 10px;
			}
```
* `重点在于父元素使用row排列顺序，而子元素被套上column，column是column排序顺序，使得两列始终是一一对应的`
* [参考](https://codepen.io/ramenhog/pen/PpEPWG)
* `在瀑布流布局中需要设置宽度不变，高度改变的图片，使用mode为widthFix`

## calc函数
1. calc是css3新增的一个功能，用来指定元素的长度，可以用来给元素的border,margin,padding等设置值
2. 运算法则
3. `使用 + - * /`
4. `可以使用百分比 px rem em运算`
5. `可以混用单位运算`
6. `表达式中有 +加号 - 减号的时候必须前后都要有空格！！！`
7. `表达式中没有* / 的时候，可以前后没有空格，但是建议有！`

## flex使用三栏布局(不再需要float:right了)
1. `对父元素使用display:flex;width:100%;(设置死宽度)对子元素，前两个如果宽度固定则不用管，然后最后一个是需要在最右边显示`
2. `对最后一个使用flex:1;跟着宽度变化，填满剩余宽度，然后再使用text-align:right；这样就可以让文本偏向右边了！实现了三栏布局`

## 三栏布局垂直对齐问题
1. `父元素使用flex之后，三个子元素设置了display:inline-block;vertical-align:middle;也是无法对齐`
2. `解决方法:使用line-height对齐，三个子元素的line-height都设置为父元素的高度，即使是图片也有效`

## 部分列表被背景覆盖(列表内容需要显示)
1. `添加一个元素，设置宽度与高度，然后在这个元素下面添加一个兄弟元素，该兄弟元素的margin-top:-height;这个高度是负的背景元素的高度！这样就能得到想要的效果`

## 改变padding却不想增大width?
1. `想让元素宽度不被padding改变，那就用box-sizing: border-box;改为使用IE怪异盒子模型，width=padding+border+content;本来是标准盒子模型的，width=content,占据的宽度才是width+padding+border`

## flex-basis和width(flex-basis和width并存时，宽度听flex-basis!)
```
		<div class="two">
			<div class="child"></div>
			<div class="child"></div>
			<div class="child"></div>
		</div>
		.two{
			display: flex;
		}
		.child{
			flex-basis: 250px;
			width: 100px;
			height: 100px;
			background: red;
			margin-right: 20px;
			max-width:200px;
			min-width:150px;
			<!-- 缩小浏览器查看效果，当元素缩小到150px后，如果不设置换行，那么就会被遮住多出部分！ -->
		}
```
* `但是flex-basisi的宽度高于总宽度的时候，如果没有设置flex-shrik:0,那么就会自动缩小`
* `也可以使用min-width,max-width来限制flex-basis,flex-basis会听max-width/min-width的，width会听flex-basis的`

## 动态进度条
```
			<div class="out">
				<div class="inner"></div>
			</div>
			.out{
				height: 10px;
				width: 90%;
				border-radius: 10px;
				margin: auto;
				background: black;
			}
			.inner{
				height: 10px;
				width: 0;
				/* box-shadow: 0px 0px 10px rgba(0, 198, 255, 1) inset; */
				border-radius: 8px;
			}
			.progress{
				width: 100%;
				box-shadow:10px 10px 10px rgba(0, 198, 255, 1) inset;
			}
			.ts{
				transition: width 1000ms ease 20ms;
			}
			
			var innerEl = document.querySelector(".inner");
			function reset() {
				//innerEl.classList.remove("progress");
				innerEl.setAttribute('class',att_class.replace('progress',''))
				//获取类名和设置类名可以使用 元素.getAttribute,元素.setAtrribute
				innerEl.classList.remove("ts");
			}
			document.body.addEventListener("click", function () {
				reset();//移除类名
				window.getComputedStyle(document.body);
				// window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画
				requestAnimationFrame(function () {
					console.log(innerEl.classList)
					innerEl.classList.add("ts");//添加类名(动画)
					if (!innerEl.classList.contains("progress")) {
						innerEl.classList.add("progress");
					}
				})
			})
```

## 多重背景
1. `background: url(one/3.jpg) center no-repeat,url(one/6.jpg) center no-repeat;`
2. 使用bacckgroud进行多重背景设置，如果有多个图片就使用逗号隔开，然后可以设置图片所在位置，no-repeat这些，但是逗号之后的图片需要很小才行
3. 如果图片都很大，那么看不出效果的！
4. 那样还不如直接加个父元素flex relative，然后大图绝对定位，小元素居中，这样还能对小图进行圆角处理！

## 文字渐变色
1. 第一种方法:`使用-webkit-background-clip属性设置背景色显示区域为文字text;然后把文字颜色设为transparent,透明，使得文字背景色漏出来，然后设置通过background-image背景色为渐变`
2. 需要注意的是，`设置渐变用的是background-image属性，而不是background-color属性！因为背景图才有渐变`
```
		<span class="one">
		    文字渐变色
		</span>
		
		.one{
			-webkit-background-clip: text;
			/* 背景色区域为文字,有兼容性，目前只支持谷歌 */
			background-image:linear-gradient(to right,red,blue);
			/* 设置渐变色使用background-image属性 */
			color: transparent;
			/* color: transparent;是设置文字为透明色，让后面的背景色漏出来 */
		}
```
* `background-clip的取值有border-box;padding-box;content-box`
3. 第二种方法是使用mask属性，但是这个属性也是谷歌才支持，所以就先不讲了


