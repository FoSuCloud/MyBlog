## 伪元素选择器
1. last-child选择器是选择父元素的最后一个元素的所有xx元素，不好用。。
2. `一般来说，想要选择同名元素中的最后一个，就这样使用`
```
<div id="one">
			<div class="a">1</div>
			<div class="a">2</div>
			<div class="a">3</div>
</div>

//这样就可以选中最后一个class类名为a的元素啦！
//需要注意的是，.a元素必须是某元素中的子元素，不能是根元素
.a:last-child{
	color: red;
}
```
3. 第二种情况
```
<div id="one">
			<div class="two">
				<div class="a">1</div>
				<div class="a">2</div>
			</div>
			<div class="a">3</div>
		</div>
//此时是2,3都变色，因为他们都是各自父元素的最后一个.a类名的元素
```
4. nth-child(n)选择第n个元素
```
		<div id="one">
			<div class="a">1</div>
			<div class="a">2</div>//红
			<div class="a">3</div>
		</div>
		//选择第二个.a元素
		.a:nth-child(2){
			color: red;
		}
```
5.nth-child(2n)选择偶数元素
```
	//只选择偶数的.a元素，奇数的话选择(2n-1)
	.a:nth-child(2n){
		color: red;
	}
	<div id="one">
			<div class="a">1</div>
			<div class="a">2</div>//red
			<div class="a">3</div>
			<div class="a">1</div>//red
			<div class="a">2</div>
			<div class="a">3</div>//red
		</div>
	//需要注意的是，始终是针对一个父元素来说的
	<div id="one">
		<div class="a">1</div>
		<div class="a">2</div>//red
		<div class="a">3</div>
		<div>      //因为父元素不同，所以计数的索引重新开始
			<div class="a">1</div>
			<div class="a">2</div>//red
			<div class="a">3</div>
		</div>
	</div>
```
6. nth-child(n+3)表示是从第三个开始之后的所有元素(包括第三个)
```
.a:nth-child(n+3){
	color: red;
}
<div id="one">
			<div class="a">1</div>
			<div class="a">2</div>
			<div class="a">3</div>//red
			<div class="a">1</div>//red
			<div class="a">2</div>//red
			<div class="a">3</div>//red
		</div>
```
7. nth-child(-n+3),=>3,2,1,0,-1....(0之后的都不算),所以指代1开始到3的元素
8. nth-last-child(2),选择倒数第二个元素
9. `如何选择某个父元素下最后一个xx元素呢？`
```
//通过子选择器指定某个父元素下的子元素，然后通过last-child指定该父元素下的最后一个xx子元素
.two .a:last-child{
				color: red;
			}
			
<div id="one">
			<div class="a">1</div>
			<div class="a">2</div>
			<div class="a">3</div>
			<div class="two">
				<div class="a">1</div>
				<div class="a">2</div>
				<div class="a">3</div>
			</div>
		</div>
```

## a标签链接
1. 锚点链接:`在一个文件可以定义多个锚点，点击a链接可以跳转到锚点所在位置`
```
<div id="one">
			<div class="d" id="t">2</div>
			<div class="two" style="height: 2000px;">
				<div class="a">1</div>
			</div>
			<a href="#t">ww</a>
		</div>
```
* `需要注意的是，锚点定位要使用id,使用class无效；并且要在页面高度足够滚动的时候才能看出效果`
2. 功能性链接:`点击链接可以跳转到外部文件或者启动其他程序`
3. 双向定位:(文件之间，文件两处地方都可以双向定位)
```
<div class="two" style="height: 2000px;">
				<div class="a">1</div>
				<a href="#w" id="t">双向定位</a> //可以从这里跳转到本文件的#w处
			</div>
			<a href="#t" id="w">ww</a>//可以从这里跳转到本文件的#t处
```
4. 单向定位
```
<div class="two" style="height: 2000px;">
				<div class="a">1</div>
				<a href="one.html#w" id="t">单向定位</a> //可以跳转到某文件的某个锚点处
			</div>
```
5. [参考](https://blog.csdn.net/cccdf_jjj/article/details/80930148)

## opacity继承的问题(父元素设置透明度，子元素必定继承！)
1. 遇到的实际问题:父元素设置圆角背景透明度，子元素是黑体字，但是子元素因为父元素是白色0.5透明，所以子元素也变得透明，此时的黑是模糊的黑！
2. 原因:`如果父元素设置了opacity属性，那么子元素必定会继承！`
3. 解决方法：
```
1. 使用rgba()来代替opacity，rgba也能设置透明度，但是不会被子元素继承，
2. 失败:对子元素使用z-index:2,尝试提高子元素优先级(提高了优先级，但是不会影响到继承问题)，但是子元素依旧继承父元素透明度，失败！
3. 失败:对子元素使用opacity:1,虽然对子元素设置样式的优先级高于继承的优先级，但是子元素的opacity:1也是基于父元素的opacity来设置的，所以依旧是低于预期效果(可以进一步在父元素opacity的基础上降低透明度，但是提高是没办法的)

```

## canvas
1. 实际应用:`在小程序中制造分享海报的时候需要用到canvas自己画图，想到做app也需要，所以学了一下js的canvas`
```
<div>
			<canvas id="one" width="600" height="600"></canvas>
			<img src="one/3.jpg" id="two">
		</div>

function draw(){
				var canvas=document.getElementById('one');
				if(!canvas.getContext) return;
				var can=canvas.getContext('2d');
				// canvas对于每个图形的起点都是0,0,即使指定起点,也是相对位置,所以图形都需要指定相对坐标
				can.beginPath(); //每创建一个图形都要开始一个路径
				// can.arc(100,100,50,0,Math.PI/2,false);
				can.strokeRect(50,50,50,50);//该方法可以绘制矩形,不需要使用stroke
				can.fillStyle='rgb(153,153,153)'
				
				can.beginPath();
				can.font='20px sans-serif';//字体样式要设置在文本之前,否则无效
				can.strokeText('我在下遗憾',50,150);//绘制的是文本边框
				can.fillText('我在下遗憾',50,200);//绘制文本
				// can.closePath();//从起始点到当前点画线,有点多此一举!
				// can.stroke();//通过线条来绘制图形轮廓
				
				can.beginPath();
				var img=document.getElementById('two');
				//必须在图片加载完再绘制图片,否则会失效
				img.onload=function(){
					can.drawImage(img,50,250,100,100);
				}
				
				can.beginPath();
				var img2=new Image();//可以自己创建一个图片元素
				//指定一个src属性
				img2.src='https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture'
				img2.onload=()=>{
					can.drawImage(img2,50,400,100,100)
				}
			}
			draw()

```
* 弧度和度数换算:`1度=PI/180*弧度`，`需要注意的是cancas中绘制图形使用的是弧度`
* [强烈推荐](https://blog.csdn.net/u012468376/article/details/73350998)

