## 设计模式之一(原型模式)--实现继承
1. `原型模式是一种用于创建对象的模式，如果我们想创建一个对象，那么一般先指定对象类型，然后通过类来创建这个对象`
2. `原型模式不再关心对象的具体类型，而是找到一个对象，通过克隆的方式来创建一个一模一样的对象`
3. `如果需要一个跟某个对象一模一样的对象，那就可以使用原型模式；但是使用原型模式需要注意该语言是否提供了克隆的方法，javascript中就是Object.create方法`
```
			var one=function(){
				this.name='one';
				this.age=22;
			}
			var two=new one();
			console.log(two);
			two.name='two';
			two.age=11;//改变实例的属性
			console.log(two);
			//通过Object.create方法克隆一个和two实例一模一样的对象
			var two_child=Object.create(two);
			console.log(two_child);//two_child.__proto__指向two
			// 有些浏览器可能不支持Object.create方法,则使用
			Object.create=Object.create||function(obj){
				var F=function(){};
				F.prototype=obj;// 所以使用Object.create方法克隆其实就是创建一个对象指向obj,然后返回该对象的实例,由于该实例没有重新定义属性方法,所以自然寻找不到,就会通过__poto__属性往上查找到two对象,也就实现了克隆
				return new F();
			}
```
4. 原型模式同时也是一种编程范式，也存在原型编程的基本规则
* 1.所有书都是对象(但是在js中存在基本数据类型，所以js是绝大数是对象，但是所有对象都存在一个根对象，所有的对象都可以通过__proto__追溯到该对象)
```
			var one=new Object();
			// Object.getPrototypeOf()方法可以获取到对象的原型
			console.log(Object.getPrototypeOf(one));
			console.log(Object.getPrototypeOf(one)===Object.prototype);//true
			// 也就表明了通过new Object()得到的one实例的原型是Object.prototpe 
			// 并且js中所有的对象的原型(或者是最终原型指向)都是Object.prototype
```
* 2.要得到一个对象，不是通过实例化类，而是通过找到一个对象作为原型并克隆它
* `但是js一般不是通过new来创建对象吗？的确是，但是new运算符来调用函数时，此时的函数就是一个构造器`
* `使用new运算符来创建对象的过程其实就是先克隆Object.prototpe对象，然后再通过一些操作来进行克隆的过程`
* 3.对象会记住他的原型(`通过__proto__隐藏属性`)
* `每个对象的__proto__属性默认会指向它的构造器对象，也就是{Construtor}.prototype`
* 注意:不是所有浏览器都会公开__proto__属性
```
			var one=new Object();
			console.log(one.__proto__===Object.prototype);//true
			
			var Person=function () {};
			//修改obj对象的__proto__指向
			one.__proto__=Person.prototype;
			console.log(one.__proto__===Person.prototype);
```
* 4.如果对象无法响应某个请求，那么它会把该请求委托给它的构造器的原型，直到要一个可以处理该请求的对象为止
* `虽然在js中，每个对象的原型都是Object.prototype,但是通过修改__proto__指向可以改变对象原型`
```
//闭包封装
			var one=(function(){
				return {
					getName:function (name){
						return name;
					}
				}
			})();
			var one_child=function(){};
			// var one_child_child=new one_child();
			// console.log(one_child_child.getName('yiyi'));//往上找getName()方法,但是不存在
			
			one_child.prototype=one;//修改one_child原型指向为one函数
			var one_child_child=new one_child();
			console.log(one_child_child.getName('dsa'));//改变原型后,可以往上找到方法,这也就是继承,也就是原型链
```
* `任何对象，除了Object.prototype之外，都会有原型，而通过Object.create(null)可以创建出没有原型的对象`
