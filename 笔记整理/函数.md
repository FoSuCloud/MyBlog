## new function(){}默认返回空对象
```
			// 1.使用new Number/String/Boolean一定会返回Number/String/Boolean对象
			var n=new Number('3')
			console.log(n);//Number {3},数字对象3
			var a=new String(function(){return String('a')});
			console.log(a);//'function(){return String('a')}'
			
			var b=new function (){return new String('b')};
			console.log(b);//b 
			
			// 2.使用new 运算符去调用函数，一定会返回一个对象
			var c=new function (){return String('c')};
			console.log(c);//{}
			// 因为String作为普通函数使用时，将值转为字符串而不是对象，所以默认返回的是空对象
			
			var d=new function(){return 'e'};
			console.log(d);//new function(){}返回的是字符串时默认也返回空对象
			
			var e=new function(){};
			console.log(e);//new function(){}没有return的时候默认就是返回空对象
```

## 函数没有返回值依旧被赋值了！！！
```
			function one(x){
				x=x+5
			}
			var d=10;
			d=one(d);
			console.log(d);//undefined
			// 因为函数没有return 返回值，所以在函数内部并没有真的改变基本数据类型的形参
			// 除非形参是对象，但是对象也没有用，因为最后还有一次赋值语句！！！
			// d=one(d)其实应该返回值得，但是没有返回值，所以默认就是undefined了！
			
			function two(y){
				y.name='hahahy'
			}
			var c={name:'c'};
			c=two(c);
			console.log(c);//undefined
```
* `函数没有返回值的时候，如果依旧被赋值，那么只会是undefined`


## 函数需要event和形参时
1. 依旧传递形参，但是不要写e为event，因为此时有形参了
2. `此时直接用event就可以代表事件  var e=event;`
```
function one(i){
	var e=event;//此元素的事件，不是window.event
}
```

## 阻塞主线程
```
       // var old=this.$refs.s_detail.getAttribute('class')
       // this.$refs.s_detail.setAttribute('class',old+' out');
       // console.log(this.$refs.s_detail.getAttribute('class'));//s_detail out
       // var start=new Date().getTime();
       // while(new Date().getTime()-start<1000){
       //   continue;
       // }
       // 销毁之前，虽然也能设置class类名成功，但是整个元素其实都被销毁了，添加了依旧无效
```
* `阻塞主线程可以通过while()来实现，设置开始时间，如果当前时间-开始时间小于1秒则继续`

## 返回函数（多个括号！！）
1. 实例:一个最简单的返回函数
```
function functionFunction(str) {
    return function f(param){
        return str+', '+param;
    }
}
```
2. functionFunction('Hello')('world'),结果就是Hello, world
3. `返回函数的难点就在于处理不确定括号数的返回函数`

## 闭包(循环下的闭包)
1. [参考](https://www.cnblogs.com/xiangqianjin/p/6595115.html)
2. 在for循环中闭包返回参数i,那么返回的参数是循环之后的i
3. 因为闭包里面寻找变量，也就是return的那个变量是在执行闭包函数之后，也就是调用的时候，而那个时候索引已经是超过length了
```
//循环里面包含闭包函数
function box(){
    var arr = [];
    for(var i=0;i<5;i++){
        arr[i] = function(){
            return i;                            //由于这个闭包的关系，他是循环完毕之后才返回，最终结果是4++是5
        }                                        //这个匿名函数里面根本没有i这个变量，所以匿名函数会从父级函数中去找i，
    }                                            //当找到这个i的时候，for循环已经循环完毕了，所以最终会返回5
    return arr;
}
//alert(box());                   //执行5次匿名函数本身
//alert(box()[1]);　　　　　　　　　//执行第2个匿名函数本身
//alert(box().length);            //最终返回的是一个数组，数组的长度为5
alert(box()[0]());                //数组中的第一个数返回的是5，这是为什么？
```
* `上面是因为等到执行该调用语句采取寻找return的i,而此时的i已经是5了！`
* `解决办法:把for的var改为let;使用立即执行函数`