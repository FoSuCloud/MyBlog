* es6中允许按照一定模式，从`数组和对象`中提取值，对变量进行赋值，这被称为解构赋值
1. 数组的解构赋值
* 解构赋值本质上相当于模式匹配，只要等号两边的模式相同，左边的变量就会被赋予对应的值
* 下面是一些例子(需要对迭代器和生成器有基本了解)
```
			// 1. 完全解构(数组)
			let [a,b,c]=[1,2,3]
			console.log(a,b,c);//1,2,3
			// 1.1 多维数组
			let [foo,[bar,baz],bac]=[1,[2,3],4]
			console.log(foo,bar,baz,bac);//1,2,3,4
			
			// 1.2 使用展开运算符接收剩余数据
			let [head,...tail]=[1,2,3,4]
			// 此时的展开运算符变量是一个数组
			console.log(head,tail);//1,[2,3,4]
			
			// 2. 不完全解构(右边有些值没有被变量得到)
			let [,,third]=[1,2,3]
			console.log(third);//3
			
			// 2.1 中间没有变量的话，那么右边也会直接轮到下一个值
			let [x,,y]=[1,2,3]
			console.log(x,y);//1,3(2没有被赋值)
			
			// 3. 解构不成功(左边变量太多，超过右边的值的数量)
			let [t,tt,...ttt]=[1]
			// 注意:普通变量解构失败默认是undefined,但是如果是展开运算符的变量那么默认是[]
			console.log(t,tt,ttt);//1,undefined,[]
			
			// 4. 解构错误(右边不是具有迭代器接口的变量)
			// Uncaught TypeError: 1 is not iterable
			// let [fooo]=1;
			// let [fooo]=undefined;
			// let [fooo]=null;
			// let [fooo]=NaN;
			// let [fooo]=false;
			
			// 4.1 string属于迭代器！
			// 具有迭代器接口的有array,string,arguments,map,set,nodelist
			// let [fooo]='';
			// console.log(fooo);//undefined
			
			// let [fooo]=new Set([2,3]);
			// console.log(fooo);//2
			
			// let [fooo]=new Map([['a',1]]);
			// console.log(fooo);//["a", 1],key,value
			
			// 4.2 对自定义的迭代器(使用生成器生成)也可以使用解构赋值
			function* func(){
				var a=0;
				var b=1;
				while(true){
					yield a;
					[a,b]=[b,a+b];
				}
			}
			let [yy,yyy,yyyy,yyyyy,yyyyyy,m]=func();
			// 0 1 1 2 3 5
			console.log(yy,yyy,yyyy,yyyyy,yyyyyy,m);
			
			// 4.3 Object对象{}不属于迭代器，下面几个例子都会报错 not a iterable
			// let [fooo]={};
			// let [fooo]={a:'33'};
```

## 2. 默认值
* `解构赋值允许指定默认值，当赋值为undefined的时候仍然使用默认值`
* `由于es6内部使用严格相等运算符===，所以null/0/false还是可以赋值成功的`
```
			// 1.赋值undefined的话相当于没赋值
			let [c]=[undefined]
			console.log(c);//undefined
			
			// 1.1 为空相当于undefined 
			let [a,b]=[]
			console.log(a,b);//undefined,undefined
			
			// 1.2 赋值为null/0/false的话赋值成功
			// 因为在严格运算符下，null/0/false不等于undefined
			let [d]=[null];
			console.log(d);//null
			let [e]=[false];
			console.log(e);//false
			let [f]=[0];
			console.log(0);//0
```
* 当存在默认值时
```
			// 2. 存在默认值时
			// 2.1 赋值为undefined无效
			let [x=1]=[undefined]
			console.log(x);//1
			
			// 2.2 赋值为null/0/false有效
			let [y]=[null]
			console.log(y);//null
			
			// 2.3 默认值为function时(惰性执行)
			var my='outer'
			function func(){
				my='inner'
				console.log('ffff')
			}
			// 无论该赋值的函数是否有括号，都是不执行的，只有用到的时候才执行
			let [p=func]=[1]
			let [t=func()]=[1]
			console.log(p);//1
			console.log(t);//1
			console.log(my);//outer
			// 2.3.1 此时调用i()才会执行,如果不调用的话，依旧是outer
/* 			let [i=func]=[]
			i();
			console.log(my);//inner */
			// 2.3.2 或者设置i=func(),此时如果赋值依旧是undefined,那么才会执行
			let [i=func()]=[]
			console.log(my);//inner
```
* 默认值可以引用解构赋值的其他变量，但是该变量必须已经声明
```
			// 1. 没有赋值，引用的变量尚未声明
			// ReferenceError: y is not defined
			// let [x=y,y=1]=[]
			// 2. 赋值了，引用的变量尚未声明
			let [x=y,y=1]=[2]
			// 此时由于赋值不为undefined,所以不会用到引用的变量
			console.log(x,y);[2,1]
			
			// 3. 赋值了，引用的变量也声明了(赋值的值优先！)
			let [a=1,b=a]=[2,4]
			console.log(a,b);//2,4
```

## 对象的解构赋值
* `注意:对象的解构赋值不要求赋值的是迭代器！`
* 对象的解构赋值和数组的解构赋值不同，对象的解构赋值不要求顺序，只要属性名对得上就行
* 但是如果没有对应的属性名，那么就解构失败
```
			let {a,b}={a:1,b:111}
			console.log(a,b);//1 111
			
			let {c,d}={c:'1',t:'1'}
			console.log(c,d);//1 undefined
			let {foo}={bar:'e',haha:'r'}
			console.log(foo);//undefined
			
			// 如果被赋值的是对象且不存在赋值的属性，那么会报错
			// 1.有对应属性时
			/* let {foo:{aa}}={foo:{aa:'1'}}
			console.log(aa);//1 */
			// 2.存在对象，不存在对应属性时 undefined
			/* let {foo:{aa}}={foo:{b:'1'}}
			console.log(aa);// undefined */
			// 3.不存在对象时，报错
			// Cannot destructure property `aa` of 'undefined' or 'null'.
			// 无法对undefined或者null的属性进行解构
			let {foo:{aa}}={}
			// 由于对象不存在属性foo,所以 {aa} =undefined 
			// 然后需要对{aa}进行解构，对undefined寻找属性aa,这就报错了
			// 因为undefined不属于对象，没有属性
```
---
* `对象的解构赋值可以很方便的进行应用！`
```
			// 1. 对象的解构赋值可以很方便的把对象的同名方法赋值到变量
			let {max:max,min:min}=Math;
			// 相当于
			// let {max,min}=Math;
			// ƒ max() { [native code] } ƒ min() { [native code] }
			console.log(max,min);// 赋值Math对象的max,min方法到max,min变量
			// 实际应用:max=Math.max
			console.log(max(3,2,44));//44
			console.log(min(3,2,44));//2
			// 但是当被赋值的变量名一致{log:log}可以写成{log}
			let {log}=console;
			log("log");//log
```
* `但是当变量名和属性名不一致的时候需要注意哦！`
```
			// 1. 赋值的对象是a:b中的b ,冒号之后的内容
			let {a:b}={a:'i am a'}
			// 所以打印b就是赋值的内容
			console.log(b);//'i am a'
			// 打印变量a却会报错，因为变量a并没有被赋值
			// console.log(a);// a is not defined
```
* 对于嵌套解构的对象，解构赋值更加需要注意
```
			// 1. 冒号之前的是模式，冒号之后的是变量
			var obj={
				p:['hello',{a:'world'}]
			}
			let {p:[x,{a}]}=obj;
			console.log(x,a);//hello world
			// 注意，由于变量p是模式，所以并没有声明赋值
			// 所以打印变量p会报错ReferenceError: p is not defined
			// console.log(p)
			
			// 2.如果想要使用一个变量保留模式匹配的内容
			// let {p:p,p:[m,{a:n}]}=obj;
			// 也可以简写成
			let {p,p:[m,{a:n}]}=obj;
			console.log(p);//['hello',{a:'world'}]
			console.log(m,n);//hello world
			
			// 3. 同一个属性可以匹配多次(也就是多次解构赋值)！
			// 也就是y属性，第一次y:y;第二次y:{yyy},第三次:{yy,yyy:haha}
			let one={y:{yy:'e',yyy:{yyyy:'t'}}};
			let {y,y:{yyy},y:{yy,yyy:haha}}=one;
			console.log(y);//{yy: "e", yyy: {…}}
			console.log(yyy);//{yyyy:'t'}
			console.log(haha);//{yyyy:'t'} 
```
* 解构赋值`可以获取到对象继承的属性`
```
			var obj1={}
			// var obj1={name:'1'}
			var obj2={name:'对象的解构赋值可以获取到继承的属性'}
			// 把对象obj2挂载到对象obj1的原型上
			Object.setPrototypeOf(obj1,obj2)
			// 虽然参与解构赋值的是没有属性name的对象obj1
			// 但是由于它的原型含有属性name,所以依旧可以解构成功
			// 当然，在obj1自身含有属性name的时候就使用自身的属性
			let {name}=obj1;
			console.log(name);//对象的解构赋值可以获取到继承的属性
```
---
* `对象的解构赋值也有默认值，除非赋值是undefined,否则都会生效，因为es6内部使用严格相等运算符`
```
			let {x:y=3}={};
			console.log(y);//3
			
			let {a:b=1}={a:null}
			console.log(b);//null
```
---
* `对象解构赋值的易错点:`
```
			// 1. 使用已声明的变量进行解构赋值
			let a;
			// SyntaxError: Unexpected token =
			// {a}={a:1}
			// 此时会有语法错误，提示=等号不合法
			// 因为在花括号{}处于行首的时候({}前面为空)，js引擎会把{}解析为块级作用域！！！
			
			// 但是如果还是想使用已声明的变量怎么办？
			({a}={a:1})
			console.log(a);//1
			// 可以使用括号包裹，此时行首就是括号了！js引擎就不会把这语句识别为块级作用域了
			// 而括号就是就是起到一个限定的作用，类似if/for/while
			
			// 2. 等号左边的对象可以为空
			let {}={c:1};// 没报错
			// 2.1 此时等号右边不为对象也没问题！
			let {}=false;
			let {}=0;
			let {}='11';
			// 3. 等号右边不是对象也可以！(虽然会解构失败，但是不报错)
			let {y}='11';
			let {yy}=[1];
			let {yyy}=[3,4,2];
			console.log(y,yy,yyy);//undefined undefined undefined
			// 3.1 但是需要注意，数组本身也是对象，只是数组的值的键是0,1
			// 所以如果等号左边的属性是0,1...那就可以解构赋值成功！
			var arr=[0,1,2,3,4,5555]
			// 注意，[arr.length-3]:mid这种中括号为属性的表达方式请看对象的拓展
			let {0:bar,[arr.length-3]:mid,5:num}=arr
			console.log(bar,mid,num);//0 3 5555
```