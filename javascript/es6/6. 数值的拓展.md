## 二进制和八进制
* es6提供了二进制和八进制新的写法，分别使用前缀0b/0B,0o/0O表示
* `并且在es5开始，严格模式下，八进制不再允许使用前缀0表示了！`
* 在es6中明确要用前缀0o,0O表示！
```
			console.log(0b110);//6
			console.log(0B110);//6
			console.log(0o110);//72
			console.log(0O110);//72
			
			// 非严格模式下，八进制可以用0作为前缀
			console.log(0o11===011);//true
			// es5开始，严格模式下0前缀不再是合法的八进制前缀表示了
			function one(){
				'use strict'
				// Uncaught SyntaxError: Octal literals are not allowed in strict mode.
				console.log(0o11===011);
			}
			one()
```
* `除了toString/parseInt可以进行进制转换，Number可以把任何进制转换为十进制`
```
			// Number把进制转换为十进制
			console.log(Number(0b110));//7
			console.log(Number(0o110));//72
			console.log(Number(0x110));//272
```

## Number.isFinite()/Number.isNaN()
* `es6在Number对象中添加了isFinite,isNaN方法用于判断数值是否是有限的，是否是数值`
```
			/* 判断是否是有限的！！！数值 */
			console.log(Number.isFinite(1.5));//true
			console.log(Number.isFinite(2/3));//true
			console.log(Number.isFinite(3/2));//true
			console.log(Number.isFinite(-0.5555));//true
			/* Infinity,NaN,布尔值，字符串，(类型不是Number)都返回false */
			console.log(Number.isFinite(Infinity));//false
			console.log(Number.isFinite(-Infinity));//false
			console.log(Number.isFinite(NaN));//false
			console.log(Number.isFinite('A'));//false
			console.log(Number.isFinite('2'));//false
			console.log(Number.isFinite(false));//false
			console.log(Number.isFinite(true));//false
```
* `isNaN对于非NaN一律返回false,但是如果属于非数值的运算结果则相当于运算后的结果是NaN`
```
			/* isNaN用于判断一个数值是否是NaN */
			console.log(Number.isNaN(NaN));//true
			console.log(Number.isNaN(-NaN));//true
			console.log(Number.isNaN(2/NaN));//true
			console.log(Number.isNaN(NaN/0));//true
			console.log(Number.isNaN('true'/0));//true
			console.log(Number.isNaN('true'-1));//true
			console.log(Number.isNaN('true'*false));//true
			console.log('----')
			
			console.log(Number.isNaN('a'));//false
			console.log(Number.isNaN(Infinity));//false
			console.log(Number.isNaN(1));//false
			console.log(Number.isNaN(2/3));//false
			console.log(Number.isNaN(1*false));//false
			console.log(Number.isNaN(false));//false
```
---
* `另外在es6之前，存在全局方法，isFinite(),isNaN()`
* `区别在于之前的全局方法会将非Number数据类型转换为Number类型再判断，而Number.isFinite(),Number.isNaN()只对Number数据类型有效`
```
			var {log}=console;
			log(isNaN('NaN'));//true,因为先转换为Number数据类型了
			log(Number.isNaN('NaN'));//false
			log(isNaN(NaN));//true
			log(Number.isNaN(NaN));//true
			
			/* 但是在下面，先执行括号内部，得到的肯定是一个非Number的东西 */
			log('true'/2);//NaN
			log(isNaN('true'/2));//true
			log(Number.isNaN('true'/2));//true
			
			/* 判断是否是有限的 */
			/* 先转换为数值Number数据类型 */
			log(isFinite('22'));//true
			/* 因为没有转换类型，所以数据类型不是Number的变量只会返回false */
			log(Number.isFinite('22'));//false 
```

## parseInt/parseFloat
* `将全局方法parseInt/parseFloat移植到Number对象中，行为完全一致！`
```
			/* 虽然移植到了Number对象中，但是不是数值类型依旧会先转换为Number类型！ */
			console.log(Number.parseInt(110,2));//6
			console.log(parseInt(110,2));//6
			console.log(Number.parseInt('110',2));//6
			console.log(parseInt('110',2));//6
			
			/* parseFloat */
			console.log(parseFloat(20));//20
			console.log(Number.parseFloat(20));//20
			console.log(Number.parseFloat(10,2));//10
			console.log(parseFloat(10,2));//10
			console.log(parseFloat("20y"));//20
			console.log(Number.parseFloat("20y"));//20
```

## Number.isInteger
* `Number.isInteger用于判断一个数是否是整数，但是有精度要求，超过精度会判断错误`
* `注意js内部对整数和浮点数使用同样的存储方式，所以25和25.0等于同一个数！`
```
			/* 1. 判断是否是整数 */
			console.log(Number.isInteger(2));//true
			console.log(Number.isInteger(2.1));//false
			console.log(Number.isInteger(-2.1));//false
			/* 2. js内部的整数和浮点数使用相同的存储方式 */
			console.log(25===25.0);//true
			console.log(Number.isInteger(25));//true
			console.log(Number.isInteger(25.0));//true
			/* 3.不是Number数据类型的话返回false,表示不是整数 */
			console.log(Number.isInteger('false'));//false
			console.log(Number.isInteger(true));//false
			console.log(Number.isInteger(null));//false
			console.log(Number.isInteger(undefined));//false
```
* `注意精度：js内部数值存储为64位双精度格式，这种精度最多可以达到53个二进制位`
* `如果超过这个精度，那么后面的位就会被丢失，函数可能会误判`
```
			console.log(Number.isInteger(3.000000000002));//false
			console.log(Number.isInteger(3.000000000000000002));//true
			
			/* 小于最小值的话无法识别，被转为整数 */
			console.log(Number.isInteger(Number.MIN_VALUE));//false
			console.log(Number.isInteger(Number.MIN_VALUE-1));//true
			console.log(Number.MIN_VALUE);//5e-324
			console.log(Number.MIN_VALUE-1);//-1
			console.log(Number.MIN_VALUE-2);//-2
```

## Number.EPSION
* ES6在Number对象中增加了一个极小的`常量Number.EPSION：表示1与大于1的最小浮点数之间的差`
* `对于64位浮点数来说，大于1的最小浮点数是1.0000...1，有51个0；`
* `1.0000...1减去1就相当于Math.pow(2,-52)，也就是最小精度为52位(指的是二进制)`
* `这个是js能够表示的最小精度，误差小于这个精度就相当于不存在误差！(相当于指定了误差的范围)`
```
	  console.log(Number.EPSILON===Math.pow(2,-52));//true
	  console.log(0.1+0.2);//0.30000000000000004
	  console.log(0.1+0.2-0.3);//5.551115123125783e-17
	  /* 从减法不等于0可以看出，0.1+0.2不等于0.3！存在误差*/
	  console.log((0.1+0.2)===0.3);//false
```
* `由于Number.EPSION相当于设置误差为2的-52次方(二进制)，所以可以设置误差范围`
```
	function withinMinError(a,b,n){
		return Math.abs(a-b)>Number.EPSILON*Math.pow(2,n)
	}
	console.log(withinMinError(0.1+0.2,3,2));//true,误差范围为2的-50次方
	console.log(withinMinError(0.1+0.2,3,0))//true,误差范围为2的-52次方
	/* 此时误差范围较小，不符合要求 */
	console.log((0.1+0.2)-0.3);//5.551115123125783e-17
	console.log(withinMinError(0.1+0.2,0.3,50))//false,误差范围为2的-2次方
```

## 安全整数
* `js能够准确表达的整数范围在-2^53--2^53范围之间，不包含端点，超过该范围就不能正确表示这个数`
```
	  /* 此时没超过范围*/
	console.log(Math.pow(2,52));//4503599627370496
	console.log(Math.pow(2,52)+1);//4503599627370497
	
	console.log(Math.pow(2,53));//9007199254740992
	/* 因为此时已经是端点，所以继续增加也是一样的 */
	console.log(Math.pow(2,53)+1);//9007199254740992
	console.log(Math.pow(2,53)+1===Math.pow(2,53));//9007199254740992
```
* `es6引入了Number.MAX_SAFE_INTEGER和MIN_SAFE_INTEGER来表示整数的上下限`
* `Number.isSafeInteger()用于判断一个整数是否在安全整数范围之内`
```
	/* 注意安全范围是不包含端点的 */
	var {log}=console;
	log(Number.MAX_SAFE_INTEGER===Math.pow(2,53));//false
	log(Number.MAX_SAFE_INTEGER===Math.pow(2,53)-1);//true
	
	/* Number.isSafeInteger() */
	log(Number.isSafeInteger(3));true
	log(Number.isSafeInteger(9007199254740991));//true
	log(Number.isSafeInteger(9007199254740992));//false
	
	/* 对于非Number数据类型及非整数，都返回false */
	log(Number.isSafeInteger(3.222));//false
	log(Number.isSafeInteger(NaN));//false
	log(Number.isSafeInteger(Infinity));//false
	log(Number.isSafeInteger(null));//false
	log(Number.isSafeInteger(undefined));//false
	log(Number.isSafeInteger('2'));//false
	log(Number.isSafeInteger(true));//false
```

## Math对象的拓展

