## 一、函数参数的默认值
## 1.1、基本用法
* 在es6之前不能给函数设置默认参数，只能在函数内部巧妙设置
```
	function func(a){
		a=a||'hha'
		return a
	}
	console.log(func(1));//1
	console.log(func());//hha
	console.log(func(false));//hha
```
* `但是传递的是false的时候依旧使用默认值，这是不对的！`
* `修改为判断typeof 是否== undefined`
* `a=typeof a=='undefined'?'hha':a`
---
* `而在es6中就可以直接给参数赋默认值`
```
	function func(a=1){
		return a
	}
	console.log(func(10));//10
	console.log(func());//1
	console.log(func(false));//false
```
* `但是在使用函数默认值的时候，不能使用let/const重新声明该变量!`
```
	function func(a=1){
		let a=111;//Identifier 'a' has already been declared
		return a
	}
```
* `在编译阶段就会报错啦~`
---
* `注意默认参数赋值顺序`
```
	/* 此时先执行a=1,然后才执行b=a,所以没错 */
	function func(a=1,b=a){
		return a
	}
	/* Cannot access 'a' before initialization */
	function func(b=a,a=1){
		return a
	}
```
---
* `存在同名的函数参数时`
```
	/* 函数不存在默认值参数时，如果存在同名变量，那么会使用后一个赋值的变量
	 也就是会进行赋值的覆盖*/
	function func(a,a,b){
		return [a,a,b]
	}
	console.log(func(10,5,1));//[5, 5, 1]
	
	/* 函数存在默认值参数时，存在同名参数，会报错！ */
	function foo(a,a,b=3){
		return [a,a,b]
	}
	/* 编译时报错 */
	/* Duplicate parameter name not allowed in this context */
	console.log(foo(3,4,5))
```
---
* `函数参数默认值是惰性求值的(也就是每次调用该函数，都会重新计算函数参数的默认值！！！)`
* `也就是函数参数的默认值也是会改变的！不是一成不变的`
```
	var x=100
	function add(y=x+1){
		return y 
	}
	console.log(add());//101,100+1
	/* 那么修改函数参数默认值所使用的变量 */
	x=1;
	console.log(add());//2,1+1
	/* 由此可知，每次调用函数，函数的参数默认值都会重新赋值一次的！(所以参数默认值也是会改变的！) */
```

## 1.2、与解构赋值的默认值结合使用
```
	function func({a,b=5}){
		console.log(a,b);
	}
	// 相当于{a,b=5}={xxx}形式的解构赋值
	func({});//undefined,5
	func({a:1});//1,5
	func({a:1,b:2});//1,2
	
	/* 如果传递的参数不是{},那么就是解构失败了 */
	/* Cannot destructure property 'a' of 'undefined' as it is undefined. */
	// func(undefined);//Cannot destructure property 'a' of 'undefined' as it is undefined
	// func();// 其实就相当于赋值了undefined,
	
	/* 对象的解构赋值不要求右边也是对象，但是是undefined的话会报错
	 右边不是对象的话则默认是没有赋值，解构失败，但是不报错*/
	func(1);//undefined 5
	func(12);//undefined 5
	func([1,2]);//undefined 5
```
---
* `在刚才的情况中，当不传递参数时会报错，这就违背了我们设置默认参数的初衷`
* `解决方法:设置两重的默认参数，也就是参数右边设置空对象{}`
```
	function foo({a,b=5}={}){
		console.log(a,b)
	}
	foo();//undefined 5
	foo(1);//undefined 5
	foo({a:3});//3 5
	foo({a:3,b:4});//3 4
```
---
* `一个小应用：http请求设置默认值`
```
	function fetch(url,{method="get",body=""}={}){
		console.log(method)
	}
	fetch('baidu.com');//get
	fetch();//get
```
---
* `两层解构赋值的不同位置`
```
	function m1({x = 0, y = 0} = {}) {
	  return [x, y];
	}
	
	function m2({x, y} = { x: 0, y: 0 }) {
	  return [x, y];
	}
	/* 1.此时m1相当于赋值为{}，使用默认值0,0
	 m2本来右边是{ x: 0, y: 0 }，但是被重新赋值为{}
	 所以没有对象的属性，所以结果为[undefined, undefined]*/
	log(m1({}));//[0, 0]
	log(m2({}));//[undefined, undefined]
	
	/* 2.赋值为空，此时相当于没有重新赋值，所以m2右边依旧是{ x: 0, y: 0 }) 
	m1右边依旧是{}*/
	log(m2());//[0, 0]
	log(m1());//[0, 0]
	
	/* 3. 只给一个属性赋值，此时m1右边是{x:3},结果是[3,0]
	 m2右边是{x:3},所以结果是[3,undefined]*/
	 log(m1({x:3}));//[3, 0]
	 log(m2({x:3}));//[3, undefined]
```

## 1.3、参数默认值的位置
* `一般来说，参数默认值都是函数的末尾的参数，方便使用`
* `如果是函数开头的参数是默认参数，那么就没法省略这个参数没办法通过,逗号来省略`
* `应该使用undefined来省略开头的函数参数`
```
	function func(x=1,y){
		console.log(x,y)
	}
	func();//1,undefined
	func(2);//2,undefined
	func(2,3);//2,3
	/* 使用,来省略是会报错的！ */
	// func(,3);//Unexpected token ','
	
	/* 应该使用undefined来省略 */
	func(undefined,3);//1,3
```
* `必须使用undefined来省略参数，null是不可以的！`

## 1.4、函数的length属性
* `给函数指定了具有默认值的参数之后，length属性会失真！`
* `也就是 返回的length只会计算具有参数默认值之前的参数的个数！`
```
	console.log((function (a){}).length);//1
	console.log((function (a,b=3){}).length);//1
	console.log((function (a,b=3,c){}).length);//1
	/* 此时c具有参数默认值，前面具有两个参数，所以长度为2 */
	console.log((function (a,b,c=3){}).length);//2
```
---
* `rest参数不就计入length的计算，rest参数也就是使用了...的参数`
```
	console.log((function (...args){}).length);//0
	console.log((function (a,...args){}).length);//1
	/* 此时两个规则不会冲突~，b=2该参数前面只有一个参数，所以长度为1 */
	console.log((function (a,b=2,c,...args){}).length);//1
```

## 1.5、作用域
* `一旦设置了函数的默认值，在函数进行声明初始化的时候，参数就会形成一个单独的作用域`
* `注意:函数初始化完成，这个参数作用域就会消失`
* `并且在不设置函数默认值的时候，这个参数作用域是不会出现的`
```
	var x=1;
	/* 有默认参数的话，函数的参数会形成作用域 */
	function foo(x,y=x){
		console.log(x,y)
	}
	foo(2);//2,2
	/* 此时就相当于给函数参数所在作用域赋值了 */
	
	/* 默认参数的默认值不会指向函数内部声明的变量
	 因为在初始化函数参数作用域的时候，函数内部还没执行
	 但是如果默认值指向外部，那么就是指向外层的变量*/
	var x=1;
	/* y指向的是外层的变量x */
	function func(y=x){
		let x=1000000;
		console.log(x,y);//1000000,1
	}
	func();
```
---
* `之前困扰很久的一个问题，函数参数为x=x`
```
	var x=10;
	function func(x=x){
		return x;
	}
	// console.log(func());
	/* Cannot access 'x' before initialization */
	/* 报错原因是：因为设置了函数参数默认值，所以形成了函数参数的作用域
	 所以就相当于 let x=x;但是此时在外层存在变量x
	 但是也使用了let x,那么使用了let x,但是却在声明x变量之前
	 使用了变量x,也就是此时x还在临时性死区，那么就会会报错！
	 */
	
	function foo(y=x){
		console.log(y,x);//10,10
	}
	foo()
	/* 
	 此时相当于let y=x,x依旧指向外层的变量x
	 然后let y并不冲突，因为没有在声明之前使用变量y
	 */
```
* `再看两道题目`
```
	var str="hello"
	/* 注意，此时形成了函数参数作用域
	 箭头函数中的str变量指向外层的str
	 与内部变量无关*/
	function func(foo= ()=> str){
		let str='hhh'
		return foo();
	}
	console.log(func());//hello
	console.log(str);//hello
```
* `有点混淆的一个题`
```
	var x=1;
	function func(x,y=function(){ x=3 }){
		var x=2;
		y();
		/* 即使执行了函数y,但是函数y中指向
		 的变量x属于参数作用域的x,与函数内部的x不一样！*/
		console.log(x);//2
	}
	func()
	/* 函数内部执行的var x=2;只是函数内部的变量，与外层变量无关 */
	console.log(x);//1
	
	
	var a=4;
	function foo(a,y=function(){ a=3 }){
		/* 此时由于没有使用var a=2,所以相当于改变了参数a的值为2！*/
		a=2;
		console.log('a:',a);//2
		y();// 此时改变参数a的值为3
		console.log(a);//3
	}
	foo()
	console.log(a);//4,此时没有使用外层的变量a
	
	var b=5;
	function foo(y=function(){ b=3 }){
		/* 此时的变量b指向的是外层的变量b */
		console.log('b:',b);//5
		y();// 此时改变外层变量b的值为3
		console.log(b);//3
	}
	foo()
	console.log(b);//3
```

## 二、rest参数
* `ES6中引入了rest参数(...变量名)，用于获取函数的多余参数，这样就不需要arguments对象了`
* `rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中`
```
	/* 使用... rest参数的做法 */
	function add(...args){
		return args.reduce((a,b)=> a+b)
	}
	console.log(add(3,4,5,6));//18
	/* 使用arguments的做法 */
	function myadd(){
		// console.log(arguments instanceof Array);//false
		// console.log(arguments instanceof Object);//true
		/* 由于arguments是一个非数组的对象，所以需要先转换为数组 */
		return Array.prototype.slice.call(arguments).reduce((a,b)=> a+b )
		/* Array.from可以用类数组对象的浅拷贝~ */
		// return Array.from(arguments).reduce((a,b)=> a+b )
	}
	console.log(myadd(3,4,5,6));//18
```
---
* `注意，在rest参数之后不能再有其他参数，否则会报错`
```
	/* Rest parameter must be last formal parameter */
	function func(a,...b,c){}
	/* 也就是rest参数必须是最后一个参数！ */
```

## 三、严格模式


function add(a,b){
	// console.log(a,b,this);//函数位于window作用于，内部this就是window
	return ()=>{
		return this.a+this.b;//NaN
	}
}
console.log(add(3,4)())
console.log(undefined+0);//NaN