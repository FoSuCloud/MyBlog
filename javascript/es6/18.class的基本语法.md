
## 一.简介
#### 类的由来
* 在js中，生成实例对象的传统方法是通过构造函数，如下所示
```javascript
		// ES6之前实例化对象只能使用函数
		function Point(x,y){
			this.x=x;
			this.y=y;
		}
		Point.prototype.toString=function(){
			return '('+this.x+','+this.y+')'
		}
		var one=new Point(1,2)
		console.log(one.toString());//(1,2)
		
		// ES6中可以使用类进行实例化对象
		class Person{
			constructor(x,y) {
			    this.x=x;
				this.y=y;
			}
			toString(){
				return '('+this.x+','+this.y+')'
			}
		}
		var two=new Person(3,4)
		console.log(two.toString());//(3,4)
```  
   
   
* `在本质上，类的数据类型就是函数，类本身就是指向自身的构造函数`
* `本质上，类的所有方法都是定义在类的prototype属性上面`
* `也就是说，类的实例的constructor===类的原型的constructor`  

```javascript
		class Point{}
		// 1. 类的数据类型是函数
		console.log(typeof Point) // function
		// 2. 类的原型链上的构造函数指向类
		console.log(Point===Point.prototype.constructor)  //true 
		// 3. 类的实例可以调用类的方法是因为类的方法相当于定义在类的原型上
		// 所以类的实例通过原型链能够找到方法来调用
		
		// 4. 类的实例的constructor全等于类的原型的constructor
		console.log(new Point().constructor === Point.prototype.constructor) //true
		
		// 5. 不能声明同名类。Identifier 'Point' has already been declared
		class Other{
			constructor(name) {
			    this.name=name;
			}
			toValue(){
				return this.name+'原型链上'
			}
		}
		var one=new Other('hh')
		console.log(one.toValue()) //hh原型链上
```
   
* `类内部定义的方法都是不可枚举的！外部使用原型定义的方法是可以枚举的`
```javascript
		// 1.类的内部定义的方法是不可枚举的
		class Other{
			constructor() {
			}
			toValue(){
				return this.name+'原型链上'
			}
		}
		// 1. 类的原型链上定义的方法是可以枚举的
		// 必须的啊！因为挂在原型链上，那么可以直接访问到的，除非使用Object.defineProperty设置不可枚举
		Other.prototype.getData=function(){}
		// ["getData"]
		console.log(Object.keys(Other.prototype))
```
   
#### constructor方法
* `constructor方法是类的默认方法，在通过new命令生成对象实例时，会自动调用该方法`
* 一个类是默认具有constructor方法的，即使没有显示声明，但是会默认具有一个空的constructor方法
* `constructor方法默认会返回类的实例对象，但是可以显式使用return返回其他`
```javascript
	// 1.一个没有constructor函数的类
	class One{}
	console.log(new One()) //One
	// 2. 一个具有空构造器constructor函数的类(相当于One)
	class Two{
		constructor(){}
	}
	console.log(new Two()) //Two
	// 3. 一个constructor函数不为空的类
	class Three{
		constructor(){
			console.log('构造器')
		}
	}
	console.log(new Three()) //打印构造器 ，Three
	// 4. 构造器返回其他对象
	class Four{
		constructor(){
			return {name:'a',age:10}
		}
	}
	console.log(new Four()) //{name: "a", age: 10}
```
* `类和函数的一个区别在于，类必须使用new调用否则会报错！而函数不需要使用new也可以执行`
```javascript
	class Func{
		static a(){
			return 'ddds'
		}
	}
	console.log(Func.a())
```
* `但是对于类的实例方法，可以直接用类去调用`
   
#### 类的实例
* `类的实例的属性都是定义在原型上的。除非类在构造器声明了！`
```javascript
		class Point{
			constructor(x,y){
				this.x=x;
				this.y=y;
			}
			a(){
				return '定义在原型链上'
			}
		}
		var p=new Point(2,3)
		// 1. x,y属性定义在构造器中，所以实例可以直接得到
		console.log(p.hasOwnProperty('x'))//true
		console.log(p.hasOwnProperty('y'))//true
		// 2. a方法不在构造器中定义，需要通过实例的原型链获取
		console.log(p.hasOwnProperty('a'))//false
		console.log(p.__proto__.hasOwnProperty('a')) //true
```
* `在类里面，所有的实例共享一个原型对象`
```javascript
	class Point{}
	var one=new Point()
	var two=new Point()
	// 1. 同一个类new出来的两个实例对象共享一个原型对象
	console.log(one.__proto__===two.__proto__)//true
	// 2. 给一个实例的原型添加方法，另一个实例也会有该方法
	one.__proto__.add=function(){
		return 'add'
	}
	console.log(one.add()) // add
	console.log(two.add()) // add 
```

#### getter和setter
* `在类内部可以使用get和set关键字，对某个属性设置存值函数和和取值函数`
* `set和get函数都是设置在函数的Descriptor对象上的`
```javascript
	class one{
		a='使用getter,setter函数'
		get a(){
			return this.a;
		}
		set a(val){
			this.a=val;
		}
	}
	var p=new one()
	console.log(p.a) // 使用getter,setter函数
	p.a='改变'
	console.log(p.a) // 改变
	
	// 获取对象的Descriptor属性
	var desc=Object.getOwnPropertyDescriptor(one.prototype,'a')
	console.log(desc) //{enumerable: false, configurable: true, get: ƒ, set: ƒ}
	console.log('get' in desc) // true 
	console.log('set' in desc) // true
```

#### class表达式
* class类也可以使用表达式的形式定义，需要注意的是:
```javascript
	var outer=class inner{
		getName(){
			// return this;  //inner {}
			return inner.name;
		}
	}
	// 1.outer是类在外部的名称，在类的外部必须使用该名称
	var c=new outer()
	console.log(c.getName()) // inner
	// 2. inner是类的内部名称，只能在类的内部使用
	// inner.getName() //ReferenceError: inner is not defined
```
* `另外还有一种立即执行的class表达式，但是不可取，使用频率太低`
```javascript
    let person=new class{
		constructor(name) {
		    this.name=name;
		}
		getName(){
			console.log(this.name)
		}
	}('yiye')
	person.getName() //yiye
```

#### 注意点
1. `只要在类或者模块中，那么默认就是严格模式，不需要使用'use strict'来指定运行模式`
2. `类中不存在变量提升(因为必须保证子类在父类的后面！)`
`class one{}; class two extends one{};`
3. `类也具有函数的name属性，可以通过类.name来获取类的名称`
4. 类的 [Symbol.iterator]方法默认就是类被循环时使用的迭代器
```javascript
	class Point{
		constructor(...args) {
		    this.args=args
		}
		*[Symbol.iterator](){
			for(let arg of this.args){
				yield arg;
			}
		}
	}
	var p=new Point(1,3,'d')
	for(var item of p){
		console.log(item); //1 3 d
	}
```
5. `this的指向需要额外注意，this默认指向类的实例，但是有时会报错`
```javascript
	class one{
		constructor(name) {
		    this.name=name;
		}
		getName(){
			return this.name;
		}
	}
	var a=new one('yiye')
	var {getName}=a; // 获取a这个·对象的getName方法
	
	// 因为只解构得到getName这个方法，而这个方法的this在此时指向的是运行环境的this 
	// console.log(getName()) // Cannot read property 'name' of undefined
	//添加name属性,也是报错。
	var name='hh'
	console.log(getName()) // Cannot read property 'name' of undefined
	// 这是因为在类内部使用的是严格模式，所以this实际指向的是undefined
```

## 二.静态方法
* 类相当于实例对象的原型对象，所以所有在类上定义的方法，都会被实例继承。
* `如果在一个方法前加上static关键字，那么就表示该方法不会被实例继承，而是直接通过类来调用`
```javascript
	class Foo{
		static getName(){
			return 'yiye'
		}
	}
	// 1. 直接通过类来调用static方法
	console.log(Foo.getName()) //yiye
	// 2.通过类的实例来调用static方法会报错！
	// (intermediate value).getName is not a function
	console.log(new Foo().getName())
```
* `如果在静态方法中包含this关键字，那么这个this指的是类，而不是实例！`   
    
```javascript
	class Foo{
		static bar(){
		// static方法内部的this指的是类本身，而不是实例！
			return this.func()
		}
		// 一个类里面可以存在同名函数，一个是静态的(类直接调用)，一个是普通的(类的实例调用)
		static func(){
			console.log('static方法是类直接调用')
		}
		// 类的实例来调用
		func(){
			console.log('普通方法是类的实例来调用')
		}
	}
	//1. static方法是类直接调用
	Foo.bar()
	// 2.类的实例来调用
	var f=new Foo()
	// 2.1 类的实例对象不可以调用静态方法
	// f.bar() //f.bar is not a function
	// 2.2 类的实例可以调用普通函数
	f.func() //普通方法是类的实例来调用
```   
   
* `父类的静态方法可以被子类继承，子类可以通过super.xxx()来调用父类的方法`
```javascript
	class Foo{
		static getName(){
			return 'foo'
		}
	}
	class child extends Foo{
		static print(){
			console.log('父类的名字是:'+super.getName())
		}
	}
	child.print() //父类的名字是:foo
```
   
## 三.实例属性的简洁写法
* 实例属性除了可以定义在constuctor构造函数中之外。还可以定义在类的顶层`和类的方法处于同一层级`
```javascript
	// 1. 构造器函数中饭定义的实例属性写在顶层
	class Foo{
		// 注意这里不要使用let/var/const(因为相当于属性了) !!!
		name='foo';
		get val(){
			return this.name;
		}
		print(){
			console.log('name:'+this.name)
		}
	}
	var f=new Foo()
	console.log(f.name) // foo
	console.log(f.val) // foo
	f.print() //name:foo
```
* `这样写的好处就在于一眼看过去就知道该类具有什么实例属性`

## 四.静态属性
* `在类的外部想要定义静态属性可以直接赋值`
```javascript
	class Foo{}
	// 1.静态属性
	Foo.a='yiye'
	console.log(Foo.a)  //yiye
	// 2.静态方法
	Foo.func=function(){
		return 'i am yiye'
	}
	console.log(Foo.func()) // i am yiye
```

## 五.私有方法和私有属性
* 目前ES6还没有提供私有方法和私有属性，只有ts才能提供private关键字。
* 替代方案是约定命名为`_xxx(){}这种为私有方法，_xxz为私有属性`
* 另一种方法是使用`Symbol来模拟，但是在外部依旧可以通过Reflect.ownKeys()来获取`
```javascript
	const bar=Symbol('bar')
	const foo=Symbol('foo')
	class F{
		// 私有方法
		[bar](){
			this[foo]='yiye'
			return this[foo]
		}
		// 公有方法
		getName(){
			console.log('ddd')
		}
	}
	var f=new F()
	f.getName()  // ddd
	console.log(f[bar]()) //yiye
	// 一般情况下，没办法获取类的[bar]方法
	console.log(Reflect.ownKeys(f)) //[Symbol(foo)]
	console.log(Reflect.ownKeys(f.__proto__)) // ["constructor", "getName", Symbol(bar)]
	
	// 类的内部定义的方法都是不可枚举的！除非在类的原型上定义
	console.log(Object.keys(f.__proto__)) //[]
	// {writable: true, enumerable: false, configurable: true, value: ƒ}
	console.log(Object.getOwnPropertyDescriptor(f.__proto__,'getName'))
```

## 六.new.target属性
* new是从构造函数生成实例对象的命令，ES6为new命令引入了一个`new.target属性`
* `如果构造函数不是通过new或者Reflect.construct()调用的，net.target会返回undefined`
* `注意:如果是子类继承父类，那么父类内部的new.target返回的是子类！`
```javascript
    // 1. 对于函数来说
	function person(name){
		if(new.target!==undefined){
			this.name=name;
		}else{
			throw new Error('必须使用new命令来生成实例')
		}
	}
	var per=new person('yiye')
	console.log(per.name) //yiye
	// 2. 对于func.call(xxx,'')来说
	// Error: 必须使用new命令来生成实例
	// var b=person.call(per,'yiye')
	
	// 3.类使用new.target返回的是自身
	class one{
		constructor(name) {
		    if(new.target===one){
				console.log(name)
			}else{
				console.log(new.target)
				throw new Error('必须使用new命令生成类的实例')
			}
		}
	}
	new one('hh') // hh 
	
	// 4.子类继承父类，但是父类此时内部的new.target是子类
	class c extends one{
		constructor() {
		    super('bb')
		}
	}
	new c() //Error: 必须使用new命令生成类的实例
	/* class c extends one{
		constructor() {
		    super('bb')
		}
	} */
```
* `也可以使用这个属性来实现抽象类，判断new.target为本类的时候报错，不为本类才可以和抽象类一致(只能被继承)`
