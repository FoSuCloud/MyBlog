对象Object是js最重要的数据结构，ES6对对象进行了许多拓展，并介绍了对象的一些新增方法

## 一.属性的简洁表示法
1. 含义
* ES6允许在大括号里面直接写入变量，作为对象的属性和方法，此时属性名就是变量名，属性值就是变量值
```
	/* 1.变量 */
	var foo="i am foo"
	// const bar={foo};// foo属性指向foo变量
	/* 其实相当于 */
	const bar={foo:foo};// foo属性指向foo变量
	console.log(bar.foo);//i am foo
	
	// 2.函数参数
	function f(x,y){
		// return {x,y};// x指向参数x,y指向参数y 
		// 相当于
		return {x:x,y:y}
	}
	var res=f(2,3);
	console.log(res);//{x: 2, y: 3}
	
	// 3.对象的方法简写
	var a=1,b="b";
	var obj={
		a,
		// 相当于b:b 
		b,
		// 方法的简写，相当于func:function(){}
		func(){
			return `a is ${this.a}`;
		}
	}
	console.log(obj.a);//1
	console.log(obj.b);//b
	console.log(obj.func());//a is 1
```

2. 小应用案例
* `对象属性的取值器和赋值器使用的是简洁的对象方法写法`
```
	const obj={
		_car:4,
		// 取值器
		get car(){
			return this._car;
		},
		// 赋值器
		set car(value){
			this._car=value;
		}
	}
	console.log(obj.car);//4
	obj.car=44;
	console.log(obj.car);//44
```
* 打印对象也可以使用简洁写法
```
	var a={name:'a',age:30}
	var b={name:'b',age:1}
	console.log(a,b);//{name: "a", age: 30} {name: "b", age: 1}
	// 此时相当于{a:a,b:b}
	console.log({a,b})//{a:{name: "a", age: 30},b:{name: "b", age: 1}}
```

3. 简洁写法的方法不能作为构造函数使用!
```
	var obj={
		name:'初始值',
		func:function(){
			this.name="func"
		},
		foo(){
			this.name="foo"
		}
	}
	console.log(obj.name);//初始值
	// 不是简洁写法的对象方法可以作为构造函数
	var func=new obj.func()
	console.log(func.name);//func 
	// 简洁写法的对象方法不可以作为构造函数
	// 此时会报错:(obj.foo不是构造器函数)obj.foo is not a constructor
	// var foo=new obj.foo();
```

## 二.属性名表达式
1. 含义
* 在js中定义对象的属性有两种方法，方法一是直接使用标识符作为属性名，方法人是使用表达式作为属性名(`此时的表达式放入中括号内[]`)
* 使用字面量方式`花括号方式`定义对象,在ES5中只能使用标识符，`在ES6中可以使用表达式`
```
	var b='foo';// 表达式形式1
	// 1.字面量形式的对象
	var obj={
		a:1,
		[b]:'i am foo',
		// 表达式形式二
		['a'+'b']:'i am ab'
	}
	console.log(obj.a);//1
	console.log(obj.b);//undefined,[b]里面的b是指向变量b 
	console.log(obj.foo);// i am foo 
	console.log(obj.ab);// i am ab 
	
	// 2.给表达式形式对象添加属性
	obj.d="d"
	var e='y'
	obj[e]='i am y'
	console.log(obj.d);//d
	console.log(obj.e);//undefined
	console.log(obj.y);//i am y
	console.log(obj['y']);//i am y
```

2. 使用方法
* `对象的属性名表达式可以用于定义方法名`
* `注意:属性名表达式不能和简洁表达法同时使用，会报错`
* `如果属性名表达式是一个对象，那么属性指的都是[object Object]`
```
	// 1. 用于方法名定义
	var obj={
		['h'+'ello'](){
			return 'hi'
		}
	}
	console.log(obj.hello());//hi
	
	// 2. 属性名表达式不能和简洁表达式一起使用，会报错
	var a='a'
	// var bar={[a]};// 编译的时候报错,Uncaught SyntaxError: Unexpected token '}'
	// console.log(bar)
	// 因为[a]指的是变量a,得到的只是一个属性名！
	var dog={a};// 正确
	console.log(dog);//{a: "a"}
	var c={[a]:'i am a'}
	console.log(c);//{a: "i am a"}
	
	// 3. 如果属性名表达式指向的变量是一个对象，那么属性名肯定是[object Object]
	var m={a:1}
	var n={a:2}
	const mn={
		[m]:'i am m',
		[n]:'i am n'
	}
	// 因为m/n属性都是对象，所以解析为属性名表达式，属性名肯定是[object Object]字符串
	// 因为存在同名属性，所以最后的属性[object Object]被覆盖为 i am n 
	console.log(mn);//{[object Object]: "i am n"}
```

## 三.方法的name属性
1. 含义
* 函数和对象方法都具有name属性
```
	// 1. 对象的方法
	var obj={
		sayName(){
			return 'say'
		}
	}
	console.log(obj.sayName.name);//sayName
	
	// 2. 函数的name属性
	function func(){
		return ' i am func'
	}
	console.log(func.name);//func
	
	// 3. 借助变量(依旧指向所赋值的函数)
	var a=func;
	console.log(a.name);//func
```

2. 注意事项
* `如果对象的方法使用了取值器和赋值器，那么不能直接获得name属性，需要借助get,set属性`
* `bind绑定之后的函数会在name属性前加上 bound 字符串`
* `Function构造函数创造的函数，获取name属性返回anonymous`
* `如果对象的方法是Symbol值，那么获取name属性返回的是Symbol值的描述`
```
	// 1. 对象方法使用取值器和赋值器
	var obj={
		_foo:1,
		get foo(){
			return this._foo
		},
		set foo(val){
			this._foo=val;
		}
	}
	// 此时直接获取函数name属性只能得到undefined 
	console.log(obj.foo.name);//undefined
	// 应该通过取值器和赋值器获取name 
	// 首先获取对象自身的属性描述符
	var desc=Object.getOwnPropertyDescriptor(obj,'foo');
	console.log(desc);//{enumerable: true, configurable: true, get: ƒ, set: ƒ}
	console.log(desc.get.name);//get foo
	console.log(desc.set.name);//set foo
	
	// 2.bind方法绑定的函数
	var func=function(){}
	console.log(func.bind().name);//bound func
	
	// 3.Function构造函数创造的函数，name属性返回anonymous
	console.log((new Function).name);//anonymous
	
	// 4.对象的方法是一个Symbol值
	const key1=Symbol("description")
	const key2=Symbol()
	let c={
		[key1](){},
		[key2](){}
	}
	console.log(c[key1].name);//["description"]
	console.log(c[key2].name);// 空
```

## 四.数组的可枚举性和遍历
1. 可枚举性
* 对象的每个属性都有一个描述对象(Descriptor),`用于控制该属性的行为`
* 使用Object.getOwnPropertyDescriptor来获取属性的描述对象
```
	var obj={a:'111'}
	console.log(Object.getOwnPropertyDescriptor(obj,'a'));
	// {value: "111", writable: true, enumerable: true, configurable: true}
```
* 其中，存在属性enumerable用于描述是否可枚举
* `以下几个方法会忽略不可以枚举属性`
- for...in 循环:只遍历对象自身的和继承的可枚举属性
- Object.keys():返回对象自身的可枚举属性的键名
- JSON.stringfy():返回的字符串只包含对象自身的可枚举属性
- Object.assign():只拷贝对象自身的可枚举属性
* `由此得知for in 循环为何得不到对象的toString属性和length属性，因为这两个属性都是不可枚举的`
* `引入枚举属性的初衷也就是让某些属性可以避免for in 操作，不会被遍历到`
```
	// 1. toString属性是不可枚举属性(通过对象的原型获取)
	var obj={a:'a',b:'b'};
	console.log(obj);// 打印出来没有toString属性
	// 但是可以调用该方法！(因为原型链上有)
	console.log(obj.toString());// [object Object]
	console.log(Object.getOwnPropertyDescriptor(obj,'toString'));//undefined
	// {writable: true, enumerable: false, configurable: true, value: ƒ}
	console.log(Object.getOwnPropertyDescriptor(obj.__proto__,'toString'));
	// 注意,obj的原型对象具有toString属性，但是属于不可枚举属性
	
	// 2. 数组的length属性也是不可枚举属性(实例中自身就有该属性!)
	var arr=[4,2,6]
	console.log(arr);//[4, 2, 6]
	console.log(arr.length);//3,原型对象才有length属性
	// 	// {value:3, writable: true, enumerable: false, configurable: false}
	console.log(Object.getOwnPropertyDescriptor(arr,'length'))
	// {value: 0, writable: true, enumerable: false, configurable: false}
	console.log(Object.getOwnPropertyDescriptor(arr.__proto__,'length'))
	// 可以看到arr获取的length的值为3，而arr的原型是0，所以数组的length属性虽然不可枚举，但是在实例中就能获取
	
	// 1. for in 循环(遍历对象自身属性和继承的可枚举属性)
	var father={child:'父对象可枚举属性'}
	Object.setPrototypeOf(obj,father)
	console.log(obj.__proto__);//{child: "父对象可枚举属性"}
	// 给对象添加不可枚举属性
	Object.defineProperty(obj,'no',{
		enumerable:false,
		value:'我是不可枚举属性'
	})
	for(var item in obj){
		console.log(item);//a b child 
	}
	// 属性no没有被遍历出来
	console.log(obj);//{a: "a", b: "b", no: "我是不可枚举属性"}
	
	// 2. Object.keys()遍历对象自身的可枚举属性
	console.log(Object.keys(obj));// ["a", "b"]
	
	// 3. JSON.stringfy() (返回的字符串只包含对象自身的可枚举属性)
	console.log(JSON.stringify(obj));//{"a":"a","b":"b"}
	
	// 4. Object.assign() 只拷贝对象自身的可枚举属性
	var y={}
	console.log(Object.assign(y,obj));//{a: "a", b: "b"}
	// 但是目标对象是obj的时候，之前的不可枚举属性不会被删除的
	console.log(Object.assign(obj,y));//{a: "a", b: "b", no: "我是不可枚举属性"}
```
* `ES6规定，所有类的原型的方法都是不可枚举的`
```
	// ES6规定，类的原型的方法都是不可枚举的
	class foo{
		f(){}
	}
	// 类不具有对应方法
	console.log(Object.getOwnPropertyDescriptor(foo,'f'));//undefined
	
	// 类的原型具有f方法，但是不可枚举
	// {writable: true, enumerable: false, configurable: true, value: ƒ}
	console.log(Object.getOwnPropertyDescriptor(foo.prototype,'f'));
	
	// 类的实例的原型具有f方法，但是也是不可枚举的
	var a=new foo()
	console.log(Object.getOwnPropertyDescriptor(a.__proto__,'f'))
```

2. 属性的遍历
* ES6中有五种遍历对象属性的方法:
- for...in循环:`对象自身和继承的可枚举属性(不包含Symbol属性)`
- Object.keys():返回数组，`包含对象自身的枚举属性的键名(不包含Symbol属性)`
- Object.getOwnPropertyNames():返回数组，`包含对象自身所有属性的键名(除了Symbol属性)`
- Object.getOwnPropertySymbols():返回数组，包含`对象自身所有Symbol属性`
- Reflect.ownKeys():返回一个数组，包含`对象自身所有键名,包括Symbol属性`
* `遍历的规则都是:`
- 先遍历所有数值键，按照`数值升序排列`
- 然后遍历所有字符串键，按照`字符串键加入时间排序`
- 最后遍历所有Symbol键，`按照Symbol键加入时间排序`
```
	// 首先创建一个对象,加入数值键
	var obj={
		0:1,
		11:12,
		2:5
	}
	// 添加一个不可枚举属性
	Object.defineProperty(obj,'d',{
		enumerable:false,
		value:'dog'
	})
	Object.defineProperty(obj,'e',{
		enumerable:false,
		value:'egg'
	})
	console.log(obj);//{0: 1, 2: 5, 11: 12, d: "dog", e: "egg"}
	// 然后加入Symbol属性
	Object.defineProperty(obj,Symbol('y'),{
		enumerable:false,
		value:'i am symbol'
	})
	Object.defineProperty(obj,Symbol('x'),{
		enumerable:false,
		value:'i am symbol x'
	})
	console.log(obj);//{0: 1, 2: 5, 11: 12, d: "dog", e: "egg", Symbol(y): "i am symbol", Symbol(x): "i am symbol x"}
	
	// 最后加入继承
	var father={
		child:'我是原型对象'
	}
	Object.setPrototypeOf(obj,father);
	
	// 1. for...in循环 (包含继承)(不遍历不可枚举，Symbol属性)
	for(var item in obj){
		console.log(item);// 0 2 11 child 
	}
    
	// 2. Object.keys() (不包含继承)(不遍历不可枚举，Symbol属性)
	console.log(Object.keys(obj));//["0", "2", "11"]
	
	// 3. Object.getOwnPropertyNames()(不包括继承) (不包括Symbol)
	console.log(Object.getOwnPropertyNames(obj));//["0", "2", "11", "d", "e"]
  
	// 4. Object.getOwnPropertySymbols(不继承)(只有Symbol属性)
	console.log(Object.getOwnPropertySymbols(obj));//[Symbol(y), Symbol(x)]
	
	// 5. Reflect.ownKeys() (对象自身所有属性，除了继承的)
	console.log(Reflect.ownKeys(obj));//["0", "2", "11", "d", "e", Symbol(y), Symbol(x)]
```

## 五.super关键字
1. 含义
* `this指向的当前函数对象，而ES6新增的关键字super可以指向当前对象的原型对象`



## 六.Object.is()
## 七.Object.assign()
## 八.原型对象的操作方法
## 九.Object.keys/values/entries


## 十.小应用题
1. 找到对象中大于1的键值对
```
	var obj={a:1,b:2,c:3}
	var res=Object.entries(obj).filter(([key,value]) => value>1)
	console.log(res);//["b", 2],["c", 3]
```