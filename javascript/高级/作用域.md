## with,try catch,eval可以改变作用域链

#### 块作用域
但函数不是唯一的作用域单元。
`块作用域指的是变量和函数不仅可以属于所处的作用域`，也可以属于某个`代码块`（通常指{ .. }内部）。

#### 词法作用域
* 词法作用域是一套关于`引擎如何寻找变量以及会在何处找到变量的规则`。
* 词法作用域最重要的特征是它的`定义过程发生在代码的书写阶段`


#### 作用域链的应用
* 有些开源项目会把document使用一个局部变量存储起来，方便函数后面使用多次
* 因为默认会沿着作用域链往下走，一步步找到document，会有一些细微的性能差异，如果查找的次数多的话
* 高性能js 这本书有提到 https://weread.qq.com/web/reader/6ab32db0813ab7c31g0187d7?

* `作用域链关联的属性是[Scope] 开发者无法获取到的，注意原型链关联的属性是prototype和__proto__`

## with,try catch,eval可以改变作用域链（动态作用域）
* with会把括号()里面的对象作为默认全局作用域，例如 with(document) {getElementById} 我们就不需要指定document了
* try-catch ,会把错误对象e放到作用域链头部，之前的作用域都往下挪一位

#### 代码编译过程
[编译器] [引擎] [作用域]
· 引擎: 从头到尾负责整个JavaScript程序的`编译及执行过程`。
· `编译器`:引擎的好朋友之一，负责`语法分析及代码生成等脏活累活`。
· 作用域:引擎的另一位好朋友，负责`收集并维护由所有声明的标识符（变量）组成的一系列查询`，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

* 当你看见`var a = 2`；这段程序时，很可能认为这是一句声明。但我们的新朋友引擎却不这么看。
* 事实上，`引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理`。
* 下面我们将var a = 2；分解，看看引擎和它的朋友们是如何协同工作的。
* `编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构`。
* 但是当编译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。
* 可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：
* “为一个变量分配内存，将其命名为a，然后将值2保存进这个变量。”
* 然而，这并不完全正确。事实上编译器会进行如下处理。

* 1．遇到var a，`编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中`。
* 如果是，编译器会忽略该声明，继续进行编译；`否则它会要求作用域在当前作用域的集合中声明一个新的变量`，并命名为a。

* 2．`接下来编译器会为引擎生成运行时所需的代码`，这些代码被用来处理a = 2这个赋值操作。
* `引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a的变量`。如果是，引擎就会使用这个变量；
* 如果否，引擎会继续查找该变量


