## 事件委托
* [参考](https://www.jb51.net/article/71236.htm)
* `当事件绑定在目标节点时，按照注册顺序执行`
* `当事件绑定在非目标节点时，按照捕获->冒泡的顺序执行`
* addEventListener的第三个参数是true表示捕获阶段触发
```
  <div class="outer">
	  <input type="button" id="btn" value="事件委托" />
  </div>
  
	  /* 
	  注意事件委托的三个阶段:
	  捕获阶段:从根节点到元素父节点的阶段
	  目标阶段:此时到达目标节点，触发事件！
	  冒泡阶段:根据捕获阶段创建的路线，从父节点冒泡回根节点
	  */
     var btn=document.getElementById('btn')
	 /* 注意在目标节点的时候会按照事件注册的顺序进行触发(事件都是在目标元素阶段执行的，但是传递顺序固定是捕获阶段，目标阶段，冒泡阶段)！
	 打印为:捕获阶段1,冒泡阶段,捕获阶段2 */
	 btn.addEventListener('click',function(){
	 		 console.log("捕获阶段1")
	 },true)
	 btn.addEventListener('click',function(){
		 console.log("冒泡阶段")
	 })
	 btn.addEventListener('click',function(){
	 	 console.log("捕获阶段2")
	 },true)
	 
	 /* 当内部元素的父元素/外层元素也绑定了相同事件，那么执行顺序是
	 外层元素捕获阶段,捕获阶段1,冒泡阶段,捕获阶段2,外层元素冒泡阶段*/
	 /* 由于捕获到btn元素的时候，到达了外层元素节点，触发了外层元素的捕获事件*/
	 var outer=document.getElementsByClassName('outer')[0]
	 outer.addEventListener('click',()=>{
		 console.log("外层元素冒泡阶段")
	 })
	 /* 即使把上面三行代码移动到头部，依旧是最后打印，因为要等到冒泡到外层元素才会执行！*/
	 outer.addEventListener('click',()=>{
	 		 console.log("外层元素捕获阶段")
	 },true)
```


## 阻止冒泡/默认事件
1.如果是IE浏览器
* 阻止冒泡:window.event.cancelBuble=true;
* 阻止默认事件:window.event.returnValue=false;
2. 阻止非IE浏览器
* 阻止冒泡:event.stopPropagation()
* 阻止默认事件:event.preventDafault();
3. 但是火狐浏览器不太一样,虽然火狐也是使用W3C标准的用法，但是注意火狐使用的`event一定是要从参数中传递过来的`


## 41.支持冒泡的事件
* 支持冒泡的事件有:click,scroll,input,keyup,keydown,mousemove,mousedown,mouseover,mouseout,mouseup,select
1. mousemove :当鼠标指针在元素内移动时，mousemove事件就会被触发，任何HTML元素都可以接受此事件
2. mouseenter(不会冒泡`IE`):鼠标移入元素的时候触发
3. mouseover:鼠标穿过被选元素或者子元素的时候触发
4. mouseout:鼠标离开被选元素及其子元素的时候触发
5. mouseleave(不会冒泡`IE`):鼠标离开被选元素的时候触发
* [鼠标事件](https://blog.csdn.net/u010297791/article/details/57412796)
* [冒泡事件](https://www.cnblogs.com/rubylouvre/p/5080464.html)


## 6.js事件的三个阶段
* 1.首先事件从根节点流向目标节点，途中会经过各级DOM节点，在各个节点上触发捕获事件，还没有流到目标节点的这段时间被称为捕获阶段
* 2.当事件从根节点流到目标节点就触发目标节点的事件，这个阶段称为目标阶段
* `捕获阶段的主要任务是建立传播路经，等到了冒泡阶段就沿着这个路径流向根节点`
* 3.当事件在目标节点上被触发之后不会停止，而是会沿着捕获阶段建立的传播路径一层层流向根节点，触发节点的事件
* `注意:我们平时一般只阻止冒泡事件，因为捕获阶段默认是不触发事件的(或者说触发的是捕获的事件)，而冒泡事件是默认触发的`

## 事件委托
1. 事件委托的原理就是冒泡机制
2. `通过事件委托可以减少内存占用，减少事件注册(例如给一个ul元素绑定事件就可以了，不用给她所有li元素绑定，减少了内存占用和注册的事件数)`
3. `并且ul元素新增li元素之后，也可以监听到该li元素的事件，因为li元素的父元素ul已经被绑定了`

## 监听事件
1. `通用的方式是 元素.onclick=function(){} 这种绑定`
2. 但是··`onclick这种方式只能绑定一个点击事件，后来加入的会覆盖掉之前的，不能同时执行`
3. 解决方法，`IE使用attachEvent,其他适用addEventListener`
```
btn.attachEvent("click",()=>{});

btn.addEventListener("click",()=>{});
```
* `attachEvent和addEventListener可以存在多个，不会被覆盖，可以同时执行`

## 事件解绑
```
			var one=document.getElementById('one');
			// 1.1 on绑定
			one.onclick=function(){
				alert('on绑定')
			}
			// 1.2 on解绑使用 onclick=null;
			var cancelone=document.getElementById('cancelone');
			cancelone.onclick=function(){
				one.onclick=null;
				alert('on解绑了再试试~')
			}
			
			// 2.1 addEventListener监听绑定
			var two=document.getElementById('two');
			var func=function(){
				alert('监听器绑定啦~')
			}
			two.addEventListener('click',func)
			// 2.2 监听器绑定使用removeEventListener解绑
			var canceltwo=document.getElementById('canceltwo');
			canceltwo.addEventListener('click',function(){
				// 2.3 需要注意:removeEventListener至少有两个参数
				// 第一个参数表示绑定的是什么事件
				// 第二个参数存在是因为addEventListener可以给一个事件绑定多次
				// 所以必须指定绑定的函数是哪个，所以预先应该用函数表达式存储函数
				two.removeEventListener('click',func);
			})
```

## 把网络图片保存到本地
1. 根据网络上的思路，创建一个a元素，然后触发点击事件
2. 该方法与我想的不太一样，但是也有值得学习的地方
```
  var a = document.createElement("a"); // 生成一个a元素
  var event = new MouseEvent("click"); // 创建一个单击事件
  a.download = name || "photo"; // 设置图片名称
  a.href = imgsrc; // 将生成的URL设置为a.href属性
  a.dispatchEvent(event); // 触发a的单击事件