## 函数柯里化(提高复用性，多个括号的情况！)
* https://juejin.cn/post/6844903665308794888#heading-4
1. `柯里化:也就是把接收多个参数的函数变换成接受单个参数的函数，并且返回接受余下的参数的新函数的技术`
2. 例子:
```
//add函数接受a,b两个参数，返回数字和
function add(a,b){
	return a+b;
}
console.log(add(1,2));//3
<!-- new_add函数接受一个参数，返回接受余下参数的新函数 -->
function new_add(a){
	return function result(b){
		return a+b;
	}
}
console.log(new_add(1)(2));//3
```
3. 本来只需要调用一层函数就可以解决的问题为什么要调用两层？多封装一层的好处在于可复用性提高了
4. 例子:
```
			function reg_t(reg,str){
				return reg.test(str)
			}
			console.log(reg_t(/^\w+/,'agb444'));
			
			function n_reg_t(reg){
				return function(str){
					return reg.test(str)
				}
			}
			// 保存第一层调用的结果，可复用性提高
			var o_reg=n_reg_t(/^\d+/)
			console.log(o_reg(545));//true
			console.log(o_reg('tr4'));//false
```
5. `优点就在于，如果除第一个参数外的其他参数可能会多次改变，那么多封装一层就会方便很多，不需要每次都再写第一个参数`
6. `柯里化其实就相当于func.bind(),延迟执行，仅仅先保留返回函数，优点之一:延迟执行`
7. `!!!超经典例题，多括号，不确定几层调用，不确定参数个数情况！！！`
```
			function add() {
			    // 第一次执行时，定义一个数组专门用来存储所有的参数
			    var _args = [...arguments];
			
			    // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
			    var _adder = function() {
			        _args=_args.concat([...arguments]);
			        return _adder;
			    };
				
				function getsum(a,b){
					return a+b;
				}
			
			    // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
			    _adder.toString = function () {
			        return _args.reduce(getsum,0)
			    }
				// 需要注意哦，因为是隐式调用toString方法，所以最后的结果是 f value;
				// 也就是数据类型是函数function!!!但是值是相等的
			    return _adder;
			}
			console.log(add(1)(2,3));// f 6
			console.log(add(1)(2,3)==6);// true
			console.log(add(3));//f 3
			console.log(add(3)(2,5)(3));//f 13
```
8. `实现思路:由于不确定调用层数，所以每次调用都是返回同一个函数，并且函数内部也是返回自身，这样下一层也就可以继续调用`
9. `重点在于调用完了之后需要使用toString隐式转换，如果没有这一步，那么最终返回的也就是函数内部代码`
10. `由于toString/valueOf是隐式调用的，所以重写了就可以了`
11. `但是需要注意返回的数据类型是function`

### 柯里化的用途
* 柯里化实际是`把简答的问题复杂化`了，但是复杂化的同时，我们在`使用函数时拥有了更加多的自由度`。 
* 而这里对于函数参数的自由处理，正是柯里化的核心所在。 
* 柯里化本质上是`降低通用性，提高适用性`。来看一个例子：

* 我们工作中会遇到各种需要通过正则检验的需求，比如校验电话号码、校验邮箱、校验身份证号、校验密码等， 这时我们会封装一个通用函数 checkByRegExp ,接收两个参数，校验的正则对象和待校验的字符串
```javascript
function checkByRegExp(regExp,string) {
    return regExp.test(string);  
}

checkByRegExp(/^1\d{10}$/, '18642838455'); // 校验电话号码
checkByRegExp(/^1\d{10}$/, '13109840560'); // 校验电话号码
checkByRegExp(/^1\d{10}$/, '13204061212'); // 校验电话号码

checkByRegExp(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/, 'test@163.com'); // 校验邮箱
checkByRegExp(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/, 'test@qq.com'); // 校验邮箱
checkByRegExp(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/, 'test@gmail.com'); // 校验邮箱
```
* 我们每次进行校验的时候都需要输入一串正则，再校验同一类型的数据时，相同的正则我们需要写多次，
  这就导致我们在使用的时候效率低下，并且由于 checkByRegExp 函数本身是一个工具函数并没有任何意义，
  一段时间后我们重新来看这些代码时，如果没有注释，我们必须通过检查正则的内容，
  我们才能知道我们校验的是电话号码还是邮箱，还是别的什么。

* 我们可以借助柯里化对 checkByRegExp 函数进行封装，以简化代码书写，提高代码可读性。
```javascript
//进行柯里化
let _check = curry(checkByRegExp);
//生成工具函数，验证电话号码
let checkCellPhone = _check(/^1\d{10}$/);
//生成工具函数，验证邮箱
let checkEmail = _check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/);

checkCellPhone('18642838455'); // 校验电话号码
checkCellPhone('13109840560'); // 校验电话号码
checkCellPhone('13204061212'); // 校验电话号码

checkEmail('test@163.com'); // 校验邮箱
checkEmail('test@qq.com'); // 校验邮箱
checkEmail('test@gmail.com'); // 校验邮箱
```
* 经过柯里化后，我们生成了两个函数 checkCellPhone 和 checkEmail，
*  checkCellPhone 函数只能验证传入的字符串是否是电话号码，
*  checkEmail 函数只能验证传入的字符串是否是邮箱，
*  它们与 原函数 checkByRegExp 相比，从功能上通用性降低了，但适用性提升了。
*  `柯里化的这种用途可以被理解为：参数复用`

* 我们已经知道了，`当柯里化函数接收到足够参数后，就会执行原函数`，那么我们如何去确定何时达到足够的参数呢？
我们有两种思路：
1. `通过函数的 length 属性，获取函数的形参个数，形参的个数就是所需的参数个数`
2. `在调用柯里化工具函数时，手动指定所需的参数个数`
```javascript
/**
 * 将函数柯里化
 * @param fn    待柯里化的原函数
 * @param len   所需的参数个数，默认为原函数的形参个数
 */
function curry(fn,len = fn.length) {
    return _curry.call(this,fn,len)
}

/**
 * 中转函数
 * @param fn    待柯里化的原函数
 * @param len   所需的参数个数
 * @param args  已接收的参数列表
 */
function _curry(fn,len,...args) {
    return function (...params) {
        let _args = [...args,...params];
        if(_args.length >= len){
            return fn.apply(this,_args);
        }else{
            return _curry.call(this,fn,len,..._args)
        }
    }
}
```
```javascript
let _fn = curry(function(a,b,c,d,e){
    console.log(a,b,c,d,e)
});

_fn(1,2,3,4,5);     // print: 1,2,3,4,5
_fn(1)(2)(3,4,5);   // print: 1,2,3,4,5
_fn(1,2)(3,4)(5);   // print: 1,2,3,4,5
_fn(1)(2)(3)(4)(5); // print: 1,2,3,4,5
```

#### 手动调用toString
```javascript
function _curry(fn, ...oldArgs) {
    // params是新参数
    return function(...params){
        // oldArgs 第一次不会传递，后面就作为旧参数
        const _args = [...oldArgs, ...params];
        // 绑定this， 如果调用没结束就继续返回 _curry对应的函数
        const func = _curry.call(this, fn, ..._args);
        // 调用-toString
        func.toString = function(){
            return fn.apply(this, _args);
        }
        return func;
    }
}

const add = _curry(function(a,b,c,d,e){
    return a+b+c+d+e
})

console.log(add(1,2)(3)(4,5).toString())
```





