## 箭头函数的this
* `箭头函数的this指向被定义时的函数外层作用域`
* `1. 如果箭头函数在对象中，那么外层作用域是window`
* `2. 如果箭头函数在函数中，那么外层作用域的就是外层的函数定义时的this`
* `2.1 如果是箭头函数内包含箭头函数，那么外层箭头函数的this指向就是内层箭头函数this指向`
* `3. 另外即使绑定其他对象，箭头函数绑定优先级高于其它绑定，依旧指向外层作用域`
* `3.1 如果想要改变箭头函数的指向，不应该直接改变箭头函数绑定，而是去改变箭头函数外部作用域绑定`
```
			var a='window.a'
			var obj={
				a:'obj.a',
				// 此时箭头函数是在对象内部，所以外层作用域就是window
				foo:()=>{
					return this.a;//window.a
				},
				foo2:function(){
					console.log(this.a);// obj.a
					// 此时的箭头函数的外层作用域是函数foo2
					return ()=>{
						return this.a;//obj.a
					}
				},
				foo3:()=>{
					// 由于是在对象内，所以外层作用域是window 
					console.log(this.a);//window.a 
					// 由于是在函数内，所以外层作用域是foo2
					// 但是由于foo2是箭头函数，foo2定义时所在作用域是window
					// 所以箭头函数内的箭头函数也是指向window
					return ()=>{
						return this.a;//window.a
					}
				}
			}
			console.log(obj.foo())
			console.log(obj.foo2()())
			console.log(obj.foo3()())
			<!-- 另外即使绑定其他对象，箭头函数绑定优先级高于其它绑定，依旧指向外层作用域 -->
			console.log(obj.foo3().call(obj))
			<!-- 改变箭头函数外层作用域绑定，间接改变箭头函数绑定 -->
			var obj2={a:'2'}
			console.log(obj.foo2.call(obj2)());// 2 2
```


## Function和Object的关系
* `相当于Function,匿名函数function (){},Object构成了一个圆环`
```
//①构造器Function的构造器是它自身
console.log(Function.constructor=== Function);//true

//②构造器Object的构造器是Function（由此可知所有构造器的constructor都指向Function）
console.log(Object.constructor === Function);//true

// ③构造器Function的__proto__是一个特殊的匿名函数function() {}
console.log(Function.__proto__);

//④这个特殊的匿名函数的__proto__指向Object的prototype原型。
console.log(Function.__proto__.__proto__ === Object.prototype);//true

//⑤Object的__proto__指向Function的prototype，也就是上面③中所述的特殊匿名函数
console.log(Object.__proto__ === Function.prototype);//true
console.log(Function.prototype === Function.__proto__);//true

console.log(Function.__proto__.__proto__ === Object.prototype);//true
console.log(Object.__proto__ === Function.prototype);//true

console.log(Object.prototype.__proto__);//null Object原型链上走到了尽头

```

## 箭头函数例子
* `看起来箭头函数会立马执行，但是不会的！箭头函数也是等待被调用的`
```
var array = [];
for(var i = 0; i <3; i++) {
  array.push(() => i);
}
// () =>{} 这样只是把一个函数从尾添加进了数组中,函数并没有执行
console.log(array); 
var newArray = array.map(el => el());//此时执行函数,但是此时的i已经变成了3
console.log(newArray); // [3,3,3]
```

## 28.函数执行完毕之后?
```
	function output(str){
		console.log(str);
	};
	// 最后一层output打印undefined
	output(typeof (function(){
		output('hello world');//'hello world'
	})());
	// 任何函数执行完一次，如果没有 return 返回值和声明变量接受返回值，都会立即消失，永远找不到值！
	//所以在立即执行函数执行完毕之后，typeof 之后的代码相当于为空,所以就是相当于未赋值
	//如果在output('hello world');后面添加一个return 'i am'则会打印string
```

## 30.错误的函数表达式
```
var f = function g() {
        return 23;
    };
typeof g();//报错
<!-- 如果是 -->
typeof g;//undefined,因为这样仅仅是查询该变量的类型并没有去使用，而g();则是去调用该函数，但是该函数并不存在，所以报错
```
* var a=function b(){};这种函数声明方式是错误的，因为函数已经被变量a所引用了，又给函数命名为b,这样是错误的！
* 这样做的结果就是b();这种调用得不到结果,因为并不存在这个函数，所以调用的后果就是报错

## 19.js中的同名变量/函数优先级
* `变量声明<函数声明<变量赋值`
* 也就是函数声明可以覆盖同名的变量声明,但是函数声明没办法覆盖被赋值之后的变量,赋值变量反而会覆盖函数,但是需要注意变量赋值的顺序
```
	// var a=3;
	// function a(){
	// 	console.log('i am')
	// }
	// console.log(a);
```
* 相当于
```
	function a(){
	console.log('i am')
	}
	var a;
	a=3;
	console.log(a);//3
	// 因为函数声明没办法覆盖被赋值的变量
```
* 变量赋值在函数声明之前与之后		
```
	function a(){
		console.log('i am')
	}
	console.log(a);//fn(){}
	var a=3;
	console.log(a);//3
```
* 此时预解析顺序为
```
	function a(){
	console.log('i am')
	} 
	var a;//虽然再次声明了a，但是存在了同名函数，所以等于没用
	console.log(a);
	a=3;//虽然存在同名变量赋值，但是执行顺序在打印之后，所以还是打印函数
	console.log(a);//而在此时，变量a已经被赋值了，而变量赋值会覆盖函数声明，所以打印变量a
```


## 箭头函数特性
1. 箭头函数不可以被用来当做构造函数，也就是不可以new 对象
2. `箭头函数没有arguments,也就是可以通过arguments获取形参`
3. `箭头函数内部的this是箭头函数定义时所在作用域的this,例如点击事件内部使用了setTimeout,如果setTimeout的函数是普通函数，那么函数内部的this指的是window,但是如果是箭头函数，那么箭头函数内部的this指的是点击事件的元素`
```
			var one=document.getElementsByClassName('one')[0];
			one.addEventListener('click',function(){
				//1.箭头函数
				setTimeout(()=>{
					console.log(this);//one这个元素
				},0)
				// 2.普通函数
				setTimeout(function(){
					console.log(this);//window
				},0)
				// 3.箭头函数不可以使用arguments
				var add=(a,b)=>{
					console.log(a+b);
					console.log([...arguments]);//MouseEvent,不是我们期待的a,b的值
				}
				add(1,2)
			})
```

## 箭头函数当做函数属性时
```
function createModule(str1, str2) {
			    return {
			        greeting:str1,
			        name:str2,
			        sayIt:()=>{
			            // 箭头函数内部的this指向的是函数所定义时作用域所在的this
			            //也就是this指向createModule函数作用域，也就是window
			            return this.greeting+', '+this.name
			        }
			    }
			}
			var greeting='g';
			var name='n'
			console.log(createModule('2','3').sayIt());//g,n
```
* 箭头函数当做对象属性来被使用时，箭头函数内部的this不是指向函数本身，而是函数所在的作用域，也就是window

## Object.prototype. __proto__=== null，说明原型链到Object.prototype终止

## 函数内部调用还未声明的方法要使用prototype
```
// 对象是电子狗AIDog,实例有白，黑
			//clor指的是狗的颜色，many指的是24小时内打扫几次,time参数是小时:分钟提供闹钟服务,sound参数是闹钟声音
			function AIDog(color,many,time,sound){
				 var day=24*60*60*1000/parseInt(many);//一天的时间戳
				setInterval(()=>{
				   AIDog.prototype.clean();
				},day);//每隔xx时间调用一次clean方法
				var now=new Date()
				var hour=now.getHours();
				var minute=now.getMinutes();
				var second=now.getSeconds();
				//console.log(hour,minute,second)
				var s_hour=time.split(":")[0];
				var s_minute=time.split(":")[1];
				if(hour==s_hour && minute==s_minute && second==0){
					AIDog.prototype.wakeUp(sound)
				}
				return {
					color:color
				}
			};
			
			AIDog.prototype.clean=function(){
				console.log("去打扫卫生")
			};
			
			AIDog.prototype.wakeUp=function(sound){
				console.log(sound)
			}
			var whi=new AIDog("white",1,"11:43","汪汪")
```
