## 比较循环和迭代器的性能
* 尽管迭代器是一种高层次的抽象，`但是迭代器在编译后生成了与手写底层代码几乎一样的产物`
* `迭代器是rust语言中的一个零开销抽象，意味着我们在使用这些抽象时不会引入额外的运行时开销`
* `c++大体上遵从了零开销原则，无须为你没有使用过的功能付出代价`

#### 例子
* 还有一个例子，其代码如下所示，这段代码来自一个实际的音频解码器。这个解码算法基于线性预测来将之前的样本拟合成一个线性函数，并用它去预* 测未来可能出现的样本。这段代码使用了链式的迭代器来对作用域中的以下3个变量进行数学计算：buffer是一段数据的切片，coefficients 是一* 个长度为12的数组，qlp_shift代表需要移动的二进制位数。注意，我们只在例子中声明了变量而没有赋值。尽管这段代码在脱离了原有的上下文环境* 后没有太大的意义，但它仍然可以作为一个简捷、真实的案例来演示Rust是如何将高层概念转换为底层代码的。
```rust
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```
* 为了计算prediction的值，这段代码遍历了coefficients中所有的12个元素，并用zip方法将其与buffer的前12个值一一配对。接着，将每一对* 数值相乘并对所有得到的乘积求和，最后将总和向右移qlp_shift位得到结果。

* 遍历coefficients根本不会用到循环：`因为Rust知道这里会迭代12次，所以它直接“展开”（unroll）了循环。展开是一种优化策略，它通过将循环代码展开成若干份重复的代码来消除循环控制语句带来的性能开销。`

* `这样能让所有coefficients中的值都存储在寄存器中，进而使得对它们的访问变得异常快速。`
同时，我们也就无须在运行时浪费时间对数组访问进行边界检查了。Rust引入的所有这些优化使最终产出的代码极为高效。现在你知道了，我们完全可以无所畏惧地使用迭代器和闭包！它们既能够让代码在观感上保持高层次的抽象，又不会因此带来任何运行时性能损失。


* `访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。`

跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的存在就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。
















