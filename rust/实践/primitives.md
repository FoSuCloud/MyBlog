## 数据类型
* rust是一个静态类型语言，这意味着它在编译程序的过程中需要知道所有变量的具体类型
* 在大部分情况下，编译器都可以根据我们绑定、使用变量的值来自动推导出变量的类型。
* `但是当我们需要进行类型转换的时候，就必须显式的添加一个类型标注`
  `let g:u32 = "42".parse().expect("Not a number!");`
* 如果我们移除u32这个类型标注，那么rust就会在编译的过程中输出如下所示的错误提示：
```text
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
```
* `这段信息表明当前的编译器无法自动推导出变量的类型，为了避免混淆需要我们手动的添加类型标准`

## primitives
* primitives指的是原语，或者说原始数据类型

### 标准数据类型
* 有符号整数：i8,i16,i32,i64,i128,isize(指针大小), `默认整数类型为i32`
* `8位有符号整数，取值范围：-128 ~ +127`
* 无符号整数：u8,u16,u32,u64,u128,usize(指针大小)
* `8位无符号整数，取值范围（0000 0000-1111 1111）：0 ~ 255 `
* 浮点数：f32,f64 `默认浮点数类型为f64`
* char Unicode标量值，如 "a","A",">", `字符使用单引号，字符串使用多引号`
* bool 为 true false 
* unit type,唯一可能的值是一个空元组  ()

### 组合类型
* rust提供了两个内置的基础组合类型，元组(tuple)和数组(array)

#### 元组
* 元组是一种相当常见的复合类型，可以将其他不同类型的多个值组合进一个复合类型中
* 元组还拥有一个固定的长度：无法在声明结束后增加或者减少其中的元素数量
* `元组中的值可以是不同类型的,可以不给元组手动添加类型标注`
```rust
fn add(){
  let num = 5 as f64 +7.222; // 整数和浮点数相加，不是同一类型，所以需要最后as 定义一个类型
  let tup = (1,444.1,true,num); // 如果在元组里面进行不同类型的求和，会编译失败
  let (x1,x2,x3,x4) = tup; // let () = xx 属于元组德解构赋值
  println!("{},{},{},{}",x1,x2,x3,x4); // 1,444.1,true,12.222000000000001
  println!("索引访问：{},{},{},{}",tup.0,tup.1,tup.2,tup.3); // 索引访问：1,444.1,true,12.222000000000001
}
```

#### 数组类型
* 我们同样可以在数组中存储多个值的集合
* `和元组不同的是，数组中的每一个元素都必须是相同的类型。`
* `rust中的数组拥有固定的长度，一旦声明就再也不能随意更改大小！`
```rust
// 函数名称：小写组合_下划线的形式
fn create_array(){
    let arr = [1,2];
    println!("arr======={},{}",arr[0],arr[1]); // arr=======1,2
    // 编译成功 但是运行时报错了
    // 实际上，每次通过索引来访问一个元素，rust都会检查这个索引是否会超过这个数组的长度，假如超过了，rust就会发生panic
    // println!("arr======={},{},{}",arr[0],arr[1],arr[2]) // index out of bounds: the length is 2 but the index is 2
}
```
* 当我们想再栈上而不是堆上为数据分配空间时，或者想要确保总有固定数量的元素时，数组是一个非常有用的工具
* `但是rust也提供了一个动态数组类型(vector),允许用户自由地调整数组长度`











