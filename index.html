<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width" />
    <title>demo</title>
</head>
<body>
<div onclick="start()">start</div>
<script>
    // 用于模拟代码执行耗费时间
    const sleep = delay => {
        for (let start = Date.now(); Date.now() - start <= delay;) {}
    }

    // performWorkUntilDeadline 的执行时间，也就是一次批量任务执行的开始时间，通过现在的时间 - startTime，来判断是否超过了切片时间
    let startTime;

    let scheduledHostCallback;
    let isMessageLoopRunning = false;
    let getCurrentTime = () => performance.now();

    const taskQueue = [{
        expirationTime: 1000000,
        callback: () => {
            sleep(30);
            console.log(1)
        }
    }, {
        expirationTime: 1000000,
        callback: () => {
            sleep(30);
            console.log(2)
        }
    }, {
        expirationTime: 1000000,
        callback: () => {
            // 如果<5，那么和下面的任务同一个workLoop；
            // 如果>5，那么单独一个workLoop
            sleep(6);
            console.log("==========")
        }
    }, {
        expirationTime: 1000000,
        callback: () => {
            sleep(30);
            console.log(3)
        }
    }]

    function requestHostCallback(callback) {
        scheduledHostCallback = callback;
        if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            schedulePerformWorkUntilDeadline();
        }
    }

    const channel = new MessageChannel();
    const port = channel.port2;

    // 接收到消息，执行
    function performWorkUntilDeadline() {
        if (scheduledHostCallback !== null) {
            const currentTime = getCurrentTime();
            startTime = currentTime;
            const hasTimeRemaining = true;

            let hasMoreWork = true;
            try {
                // 执行任务，并且根据返回值判断是否还可以执行下一个任务
                hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
            } finally {
                console.log('hasMoreWork', hasMoreWork);
                if (hasMoreWork) {
                    // 还有任务，那么就让出主线程，通过 postMessage 把下一个任务推到任务队列，避免阻塞主线程
                    schedulePerformWorkUntilDeadline();
                } else {
                    isMessageLoopRunning = false;
                    scheduledHostCallback = null;
                }
            }
        } else {
            isMessageLoopRunning = false;
        }
    }

    channel.port1.onmessage = performWorkUntilDeadline;
    // 发送消息，通知更新
    let schedulePerformWorkUntilDeadline = () => {
        port.postMessage(null);
    };

    function flushWork(hasTimeRemaining, initialTime) {
        return workLoop(hasTimeRemaining, initialTime);
    }

    let currentTask;
    // 执行任务队列的任务，并且返回一个值 判断任务是否还存在
    // initialTime -> currentTime -> performance.now()
    function workLoop(hasTimeRemaining, initialTime) {
        currentTask = taskQueue[0];
        while (currentTask != null) {
            console.log(currentTask);
            // 结束
            if (
                currentTask.expirationTime > initialTime &&
                (!hasTimeRemaining || shouldYieldToHost())
            ) {
                break;
            }

            const callback = currentTask.callback;
            // 执行任务
            callback();

            taskQueue.shift();
            currentTask = taskQueue[0];
        }
        return currentTask != null;
    }

    const frameInterval = 5;
    // 如果没有过默认的切片时间（5ms），那就再执行一个任务
    function shouldYieldToHost() {
        const timeElapsed = getCurrentTime() - startTime;
        return timeElapsed >= frameInterval;
    }
    // 开始测试demo
    function start(){
        requestHostCallback(flushWork)
    }

</script>
</body>
</html>
