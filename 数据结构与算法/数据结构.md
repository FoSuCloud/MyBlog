## Linux权限
1. 以chmod 777为例，表示`文件所有者，群组用户，其他用户对该文件的权限皆为可读，可运行，可写`
2. `chmod命令是三位数，第一位表示文件所有者，第二位表示群组用户，第三位表示其他用户`
3. `chmod命令的数字为7表示可读可运行可写，5表示可读可运行，4表示可读`

## sql查询优化
1. `如果有可变长的字段，那么把可变长的字段改为定长可以改进性能，因为定长的字段是很容易计算下一个数据的偏移量的，所以读取速度的自然也会很快`
2. `太过于长的列可以单独做一个表`
3. (unsigned表示非负数)

## 前缀表达式/中缀表达式/后缀表达式
1. 中缀表达式就是平常的表达式，如`(3+4)*5-6=29`
2. `前缀表达式又称为波兰式，也就是运算符位于数字前面，如 -*+3456`
3. `后缀表达式又称为逆波兰式，也就是运算符位于数字后面，如 3 4 + 5 × 6 -`
* 后缀表达式转中缀表达式，ab+cd+*
```
后缀表达式转为中缀表达式要点：遇到操作数都进栈，等到碰到运算符就把栈顶两个元素出栈，运算后再入栈，直到结束。
1. a入栈，b入栈，`栈为 a b`
2. 遇到运算符+，b出栈，a出栈，运算为(a+b),再入栈，栈为`(a+b)`
3. c入栈，d入栈，栈为`(a+b) c d`
4. 遇到运算符+,d出栈，c出栈，运算为(c+d),入栈，结果为`(a+b) (c+d)`
5.遇到运算符*，栈顶两个元素出栈，运算结果为(a+b)*(c+d)
```
* 后缀表达式转中缀表达式,"3 4 + 5 × 6 -" => ((3+4)*5)-6  => 29
---
* `中缀表达式转为后缀表达式(从左到右扫描)`
* `分为两个栈，结果栈和运算栈，遇到的情况有`
```
1. 如果是操作数(数字、字母)，则进入结果栈
2. 如果是左括号，那么入运算栈；
3. 如果是右括号，那么把运算栈的栈顶元素出栈，入栈到结果栈，知道遇到左括号，遇到左括号后，这一对括号都消灭
4.1 如果是运算符，如果运算栈为空，那么入栈
4.2 如果是运算符，此时运算栈顶运算符不为左括号！！！，且栈里不存在优先级大于或等于该运算符的运算符，则该运算符入栈，
否则大于等于该运算符的其他运算符先出栈再入栈到结果栈
4.3 如果是运算符，此时栈顶运算符是左括号，那么入栈
```
* 已知一算数表达式的中缀表达式为 a*f+(b-c/d)*e，其后缀形式
* 首先a是操作数，进结果栈；`结果栈为 a`
* * 是运算符，运算栈空，进运算栈
* f是操作数，进结果栈  `结果栈为 a f`
* +是运算符，但是栈中存在优先级大于等于的*，所以 * 先出栈，然后 * 入运算栈 `结果栈为 a f *`
* (是左括号，入运算栈，`运算栈为 + (`
* b是操作数，入结果栈，`结果栈 a f * b`
* -是运算符，栈顶元素是左括号，所以-入运算栈 `运算栈 + ( -`
* c是操作数，入结果栈， `结果栈 a f * b c`
* /是运算符，运算栈顶元素不是左括号，`运算栈 + ( -`不存在优先级大于等于 / 的元素，所以 / 入运算栈
* d是操作数，d入结果栈，`结果栈 a f * b c d`
* )是右括号，所以运算栈的栈顶元素出栈，知道左括号，入栈后进到结果栈
* 此时运算栈是 `+ ( - /` ，所以结果栈变为 `a f * b c d / -`,运算栈变为 `+`,左右括号消灭了
* 然后*是运算符，运算栈中不存在大于等于的元素，所以入运算栈,运算栈为`+ *`
* e是操作数，e入结果栈，结果栈为`a f * b c d / - e`,
* 扫描结束，所以运算栈全部出栈到结果栈，为 `a f * b c d / - * +`
---
* `中缀表达式转为二叉树(操作数是左右叶子结点，运算符是根节点)`
* [参考](https://blog.csdn.net/qq_22771739/article/details/88077977)


## select count语句
```
select count(*) from table 表示返回表中包括空行和重复行在内的行数,但是会扫描所有列
select count(1) from table 也是返回表中包括空行和重复行在内的行数，不会扫描所有列,1其实就是表示有多少个符合条件的行，但是此时没有where,所有没条件也就是返回总行数
select count(id) from table 表示返回表中存在该列id的行数，但是该列的值不为空，为空的不计算，所以在此题中是不能用这个，因为tg_email都为空，用主键可以，因为主键肯定不为空
```

## sql的模糊查询匹配模式
1. `% 表示0个或者多个字符`
2. `_表示任意单个字符！`
3. `[]匹配中括号内的某一个字符`
4. `[^]匹配不在中括号内的某一个字符`
* 例子:`WHERE LIKE '_YOU%' 可以匹配到 IYOUHAHA `
* `WHERE LIKE '[ABC]YOU[^ABC]' 匹配到 AYOUE`

## 汉诺塔问题——栈
```
汉诺塔问题之前记错了。。其实真的是个栈问题
汉诺塔问题就像是深拷贝问题，刚开始的圆盘是完好的，顺序正确的，从上到下分别是1 2 3
然后我们需要把圆盘搬到另一个圆盘，顺序依然是 1 2 3
所以搬运的顺序就是栈！！！
刚开始虽然搬走了1，但是2也搬走了，然后需要把后进的2先搬走，最后才搬走第一个进入的1，也就是栈的后进先出
```

## 栈不能删除栈底元素！！！
* `每当要把一个数字推进栈中，都是沿着"栈顶到栈底的方向"，也就是第一个元素位于栈底，最后一个进入的元素位于栈顶！！元素删除都是先删除栈顶的元素，也就是先进后出，后进先出`

## 散列表
1. `对于散列表的长度为m,散列函数是 H(k)=key%p,那么p应该选择小于等于m的最大素数`
2. `素数就是除了1和本身不能被其他数整除的数`

## 二叉树的计算公式
1. `n个节点的二叉树最多有多少种类? (2n!)/(n!*(n+1)!) 例如: n=3, (6!)/(3!*4!)=5 就是 6!=6*5*4*3*2*1`
2. `n层二叉树的第n层最多2^(n-1)个`
3. 对于一棵二叉树，如果度为0的节点有n个，那么度为2的节点就有n-1个
4. `拥有n个节点的完全二叉树的深度是log2(n)+1`

## 线性表的顺序存储结构和链式存储结构
1. [参考](https://www.cnblogs.com/fly-me/p/lian-shi-cun-chu-jie-gou-he-shun-xu-cun-chu-jie-go.html)
2. 顺序存储：查找结点O(1)，删除结点O(n),需要注意，删除之前需要先执行查找
3. 链式存储：查找结点O(n)，删除结点O(1),需要注意哦，删除之前需要先执行查找

## (链表)删除指针p的后继节点
1. `指针 P 指向单链表 L 中的非尾部结点，则删除其后继结点的语句是 p.next = p.next.next`

## git的分支指令
1. [参考](https://www.cnblogs.com/printN/p/6259115.html)
2. `git branch -a查看远程分支和本地分支;git branch -r查看远程分支(服务器);git branch查看所有分支(包含master主支)`
3. `git branch test;创建本地分支名为test`
4. `把本地分支推送到远程服务器，git push origin test;如果直接是git push那么是默认分支; origin后面是分支名称`
5. `切换分支 git checkout test;切换到test分支`
6. `添加本地要上传的文件git add one.js;文件夹 git add img;添加本地所有文件 git add .`
7. `删除分支 git branch -d test;删除test分支`

## linux恢复
1. 不小心commit了，如何恢复到上一状态？`最好用git reset --soft HEAD^`
`如果用git reset --hard HEAD^具有破坏性，导致难以恢复`
2. 回退到上几个commit状态用`git reset --soft HEAD~x(x在这里就是一个数量)`

## linux系统的cron服务用于系统日常资源的调度
## linux系统中网络管理员对WWW服务器进行访问，控制存取和运行是通过httpd.conf文件体现的

## 希尔排序，快速排序,堆排序是不稳定的，也就是存在两个相同的数字时，可能依旧会颠倒这两个数字的顺序
## 堆排序和快速排序都可以达到O（nlogn）但是堆排序和快速排序是不稳定的,而归并排序是稳定的！

## linux在给定文件中查找与设定条件相符字符串的命令是grep
## linux cp复制命令 例子 cp -r test/ one将test目录下的所有文件和目录都复制到新建的one文件夹下

## 顺序栈操作
1. s->top是栈顶指针
2. s->top == -1表示空栈
3. s->top++ 表示插入元素
4. s->top-- 表示出栈
5. s->top == MaxSize-1表示栈满

## js中变量存储位置(栈/堆)
1. `基本数据类型都是存储在栈中，而对象的内容存储在堆中，但是对象的内存地址存储在栈中！`
2. 例题:`以下哪个不是分配在栈上的？函数内动态申请的对象,重点是这是对象，对象内容都是存储在堆中的，内存地址才是放在栈中`
3. `内容在栈中:函数内局部变量,函数内局部指针变量,函数内指向动态申请的对象的局部指针变量`

## 归并排序
1. `在总数量数大于内存存储范围时，数据无法一次全部装入内存，那么就需要使用外部排序`
2. `也就是使用归并排序不断交换外部数据和内部数据的方式实现`
3. 例子:`假设你只有100MB的内存，需要对1GB的数据进行排序,那就是用归并排序`

## 拆箱/装箱操作
1. [参考](https://www.cnblogs.com/wenber/p/3628944.html)

## 流处理和批处理