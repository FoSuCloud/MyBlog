## 前缀表达式/中缀表达式/后缀表达式
1. 中缀表达式就是平常的表达式，如`(3+4)*5-6=29`
2. `前缀表达式又称为波兰式，也就是运算符位于数字前面，如 -*+3456`
3. `后缀表达式又称为逆波兰式，也就是运算符位于数字后面，如 3 4 + 5 × 6 -`
* 后缀表达式转中缀表达式，ab+cd+*
```
后缀表达式转为中缀表达式要点：遇到操作数都进栈，等到碰到运算符就把栈顶两个元素出栈，运算后再入栈，直到结束。
1. a入栈，b入栈，`栈为 a b`
2. 遇到运算符+，b出栈，a出栈，运算为(a+b),再入栈，栈为`(a+b)`
3. c入栈，d入栈，栈为`(a+b) c d`
4. 遇到运算符+,d出栈，c出栈，运算为(c+d),入栈，结果为`(a+b) (c+d)`
5.遇到运算符*，栈顶两个元素出栈，运算结果为(a+b)*(c+d)
```
* 后缀表达式转中缀表达式,"3 4 + 5 × 6 -" => ((3+4)*5)-6  => 29
---
* `中缀表达式转为后缀表达式(从左到右扫描)`
* `分为两个栈，结果栈和运算栈，遇到的情况有`
```
1. 如果是操作数(数字、字母)，则进入结果栈
2. 如果是左括号，那么入运算栈；
3. 如果是右括号，那么把运算栈的栈顶元素出栈，入栈到结果栈，知道遇到左括号，遇到左括号后，这一对括号都消灭
4.1 如果是运算符，如果运算栈为空，那么入栈
4.2 如果是运算符，此时运算栈顶运算符不为左括号！！！，且栈里不存在优先级大于或等于该运算符的运算符，则该运算符入栈，
否则大于等于该运算符的其他运算符先出栈再入栈到结果栈
4.3 如果是运算符，此时栈顶运算符是左括号，那么入栈
```
* 已知一算数表达式的中缀表达式为 a*f+(b-c/d)*e，其后缀形式
* 首先a是操作数，进结果栈；`结果栈为 a`
* * 是运算符，运算栈空，进运算栈
* f是操作数，进结果栈  `结果栈为 a f`
* +是运算符，但是栈中存在优先级大于等于的*，所以 * 先出栈，然后 * 入运算栈 `结果栈为 a f *`
* (是左括号，入运算栈，`运算栈为 + (`
* b是操作数，入结果栈，`结果栈 a f * b`
* -是运算符，栈顶元素是左括号，所以-入运算栈 `运算栈 + ( -`
* c是操作数，入结果栈， `结果栈 a f * b c`
* /是运算符，运算栈顶元素不是左括号，`运算栈 + ( -`不存在优先级大于等于 / 的元素，所以 / 入运算栈
* d是操作数，d入结果栈，`结果栈 a f * b c d`
* )是右括号，所以运算栈的栈顶元素出栈，知道左括号，入栈后进到结果栈
* 此时运算栈是 `+ ( - /` ，所以结果栈变为 `a f * b c d / -`,运算栈变为 `+`,左右括号消灭了
* 然后*是运算符，运算栈中不存在大于等于的元素，所以入运算栈,运算栈为`+ *`
* e是操作数，e入结果栈，结果栈为`a f * b c d / - e`,
* 扫描结束，所以运算栈全部出栈到结果栈，为 `a f * b c d / - * +`
---
* `中缀表达式转为二叉树(操作数是左右叶子结点，运算符是根节点)`
* [参考](https://blog.csdn.net/qq_22771739/article/details/88077977)


## 汉诺塔问题——栈
```
汉诺塔问题之前记错了。。其实真的是个栈问题
汉诺塔问题就像是深拷贝问题，刚开始的圆盘是完好的，顺序正确的，从上到下分别是1 2 3
然后我们需要把圆盘搬到另一个圆盘，顺序依然是 1 2 3
所以搬运的顺序就是栈！！！
刚开始虽然搬走了1，但是2也搬走了，然后需要把后进的2先搬走，最后才搬走第一个进入的1，也就是栈的后进先出
```
* `汉诺塔问题在f(2)的时候，可以拆分为把头部f(2-1)放到中转盘的次数+1(底部移动到目的盘)+中转盘f(2-1)移动到目标盘(此时起点盘为中转盘)`
* `也就是f(1)+1+f(1),因为中转盘与起点盘的位置会颠倒一次，f(3)=先把头两个转移到中点盘+1+中点盘转移到目的盘`
* `汉诺塔问题的解答公式是 f(n)=2f(n-1)+1, f(1)=1,f(2)=3,f(3)=7`
* 以f(3)为例
```
1. 首先把中点盘作为目的盘，目的盘作为中转盘，把f(n-1)=f(2)移到中点盘
1.1 起点盘 1移动到假设中点盘(真实目的盘)，把2移动到假设目的盘(真实中点盘)
1.2 把假设中点盘(真实目的盘)的1移动到假设目的盘(真实中点盘)2的位置
1.3 此时就是  3 ，1/2 ，无；  f(2)完成，移动次数为3，也就是f(2)的次数
2. 把起点盘3移动到目的盘，此时是 无，1/2，3，执行次数为1
3. 此时把中点盘的1/2移动到目的盘，需要执行f(2)次，
3.1 中点盘1把起点盘作为中点盘移动，此时是 1,2,3
3.2 此时中点盘2移动到目的盘3，此时是 1，无，2/3
3.3 把起点盘的1移动到目的盘，此是是 无，无，1/2/3，完成
4. 执行次数就是 f(2)+1+f(2)
```

## 栈不能删除栈底元素！！！
* `每当要把一个数字推进栈中，都是沿着"栈顶到栈底的方向"，也就是第一个元素位于栈底，最后一个进入的元素位于栈顶！！元素删除都是先删除栈顶的元素，也就是先进后出，后进先出`

## 散列表
1. `对于散列表的长度为m,散列函数是 H(k)=key%p,那么p应该选择小于等于m的最大素数`
2. `素数就是除了1和本身不能被其他数整除的数`


## 线性表的顺序存储结构和链式存储结构
1. [参考](https://www.cnblogs.com/fly-me/p/lian-shi-cun-chu-jie-gou-he-shun-xu-cun-chu-jie-go.html)
2. 顺序存储：查找结点O(1)，删除结点O(n),需要注意，删除之前需要先执行查找
3. 链式存储：查找结点O(n)，删除结点O(1),需要注意哦，删除之前需要先执行查找

## (链表)删除指针p的后继节点
1. `指针 P 指向单链表 L 中的非尾部结点，则删除其后继结点的语句是 p.next = p.next.next`


## 希尔排序，快速排序,堆排序是不稳定的，也就是存在两个相同的数字时，可能依旧会颠倒这两个数字的顺序
## 堆排序和快速排序都可以达到O（nlogn）但是堆排序和快速排序是不稳定的,而归并排序是稳定的！

## 顺序栈操作
1. s->top是栈顶指针
2. s->top == -1表示空栈
3. s->top++ 表示插入元素
4. s->top-- 表示出栈
5. s->top == MaxSize-1表示栈满

## 归并排序
1. `在总数量数大于内存存储范围时，数据无法一次全部装入内存，那么就需要使用外部排序`
2. `也就是使用归并排序不断交换外部数据和内部数据的方式实现`
3. 例子:`假设你只有100MB的内存，需要对1GB的数据进行排序,那就是用归并排序`

## 对于二叉树的后序遍历，最后一个节点必定是根节点！
## 对于中序遍历，在根节点左边的是左子树内容，在根节点右边的是右子树内容


## 拆箱/装箱操作
1. [参考](https://www.cnblogs.com/wenber/p/3628944.html)

## 流处理和批处理

## 在n个有序顺序表中插入一个新元素，并保持原来的顺序不变，平均要移动的元素次数是n/2

## 在循环链表中，只要指出表中任何一个节点的位置，就可以从它出发`依次`访问到表中其他的所有节点

## 单向链表
* head头结点指向第一个元素-->(第一个元素只有一个尾指针)-->(尾指针指向下一个元素)-->(最后一个元素的尾指针指向null)
* [参考](https://segmentfault.com/a/1190000017569816)
## 双向链表
* `1. 依旧是head节点指向第一个元素`
* `2. 第一个元素的头指针指向null(因为它不存在上一个元素)`
* `3. 第一个元素的尾指针指向下一个元素`
* `4. 第二个元素的头指针指向上一个元素(也就是第一个元素)`
* `5. 第二个元素的尾指针指向下一个元素`
* `6. 最后一个元素的尾指针指向null`
* `双向链表有头指针和尾指针，单向链表只有尾指针`

## 全排列
1. `如果没有重复值的话，全排列就是 n!`
2. `但是如果有重复的值，那么就先拍不重复再拍重复的`
* 例子: 字符串 "YONYOU"，有几种不同的全排列方式?
* A(2,6)*C(2,4)*C(2,2)=6*5*(4*3/2*1)*(2*1/2*1)=180种

## 堆其实就是一个完全二叉树！！！
## 大顶堆(第一个元素是最大值，(每一个分支的根节点，左节点，右节点)根节点都是最大值)
## 小顶堆(第一个元素是最小值)
## 堆排序
* 堆排序大概就是先一步步生成大顶堆再生成小顶堆
* `堆排序成完成二叉树后要变成数组，那么就是按照一层层来的，先写第一层，再从左到右写第二层这样！`
* [例题](https://www.nowcoder.com/questionTerminal/6bcda62a3b2146c7bddee626c78207fd)
* [堆排序](https://blog.csdn.net/u013384984/article/details/79496052)

## 哈希表的线性探查法
* 公式为`Hash(key)=len%p, p是小于哈希表长度len的最小质数`
* 给出一组元素，它们的关键码为：37，25，14，36，49，68，57，11，散列表为HT[12]，表的大小 m=12
* 假设采用Hash（key）= key % p ；（p=11）11是最接近m的质数`表的范围是0-11,有arr[11]`
* `首先按照顺序， 37%11 ==6 ,arr[6] =37`
* `25%11 ==3 ,arr[3]=25`
* `14%11 ==3 ,由于 arr[3]已经有位置了，所以就发生哈希冲突了，所以后移，arr[4]=14`
* `36%11==3,由于arr[3],arr[4]都有位了，所以继续后移，arr[5]=36`
* `49%11==5,由于arr[5]，arr[6]有位了，所以arr[7]==49`
* `68%11==2,arr[2]=68`
* `57%11==2,由于arr[2]有位了，3,4,5,6,7都有位了,所以arr[8]=57`
* `11%11==0，arr[0]=11`
* `所以最后就是 11 [] 68 25 14 36 37 49 57 `
* `线性探查法就是一直+1`

## 但是哈希表还有二次探查法
* `二元探查法与线性探查法的区别就在于，二次探查法每次遇到冲突不是+1`
* `遇到冲突选择 进行遍历，i++,i的初始值是1，那么比较是i^2,-i^2`
* `也就是如果出现冲突，执行 n+i^2,如果有位置就坐，没位置就执行n-i^2,如果还没有就i++`
* [参考](https://www.nowcoder.com/test/question/done?tid=31309191&qid=372706#summary)

## 有序线性表进行查找
* `五次查找成功的节点数量？根据二叉树来寻找`
* 如有序线性表arr[1...30]
* `首先找到中点，也就是 (1+30)/2, 15,根节点是15`
* `1.小于15的时候，左子树的根节点是 (1+14)/2 ,7`
* `2. 左子树的左节点是 (1+7)/2 ,3`
* `3. 左子树的右节点是 (8+14)/2 ,11`
* `4. 然后再继续画下去`
* [参考](https://www.nowcoder.com/test/question/done?tid=31253144&qid=372728#summary)

## 有向图
1. 已知一个由5个顶点8条边构成的有向图，`则边数=出度数=入度数=8`
2. `若以邻接表为节点，那么节点数=顶点数+边数=(5+8)=13`

## 广义表
* 广义表K=(m,n,(p,(q,s)),(h,f)),则head[tail[head[tail[tail(K)]]]]的值为
* `head[]返回列表的的第一个元素`
* `tail[]返回删除第一个元素之后的元素`

## 希尔排序的增量
* 对序列{10, 15,22，18，3，6，33}用希尔排序方法排序，经一趟排序后序列变为{10,3，6，18，15,22，33}, 则该趟排序采用的增量是( )
```
一般选取增量的公式是 (n/3)+1,增量也就是两个元素之间的间隔(隔着增量-1个元素)
然后本题目的增量不按照该公式，通过观察看到3和15交换了，中间隔着2个元素，所以增量为2+1，也就是3
```
