## 回溯算法
* [https://leetcode-cn.com/tag/backtracking/problemset/]()
* 回溯算法一般是对树状结构或者图形结构进行一次深度优先遍历。类似于枚举的搜索尝试过程，在遍历的过程中查找问题的解答
* 深度优先遍历的特点就是当发现不满足条件时就返回，尝试别的路径。此时对象类型就需要重置成为和之前一样。类似状态重置
* 实际上回溯算法就是暴力破解方法。被称为通用解题方法。

## 全排列
```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    let res=[]
    function fn(arr){
        if(arr.length === nums.length){
            res.push(arr);
            return;
        }
        for(let i=0;i<nums.length;i++){
            if(arr.includes(nums[i])){
                continue;
            }
            arr.push(nums[i]);
            fn(arr.slice(0))
            arr.pop();
        }
    }
    fn([]);
    return res;
};
```

## 电话号码的字母组合
```javascript
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
    if(digits.length === 0){
        return []
    }
    let res=[];
    let arr=[['a','b','c'],['d','e','f'],['g','h','i'],['j','k','l'],['m','n','o'],['p','q','r','s'],['t','u','v'],['w','x','y','z']]
    function fn(str,k){
        if(str.length === digits.length){
            res.push(str);
            return;
        }
        let chars=arr[digits[k] - 2];
        for(let j=0;j<chars.length;j++){
            str+=chars[j];
            fn(str,k+1)
            str=str.substr(0,str.length-1)
        }
    }
    fn('',0)
    return res;
};
```
