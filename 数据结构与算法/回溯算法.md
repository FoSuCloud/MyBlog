## 回溯算法
* [https://leetcode-cn.com/tag/backtracking/problemset/]()
* 回溯算法一般是对树状结构或者图形结构进行一次深度优先遍历。类似于枚举的搜索尝试过程，在遍历的过程中查找问题的解答
* 深度优先遍历的特点就是当发现不满足条件时就返回，尝试别的路径。此时对象类型就需要重置成为和之前一样。类似状态重置
* 实际上回溯算法就是暴力破解方法。被称为通用解题方法。

## 全排列(不存在重复元素)
```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    let res=[]
    function fn(arr){
        if(arr.length === nums.length){
            res.push(arr);
            return;
        }
        for(let i=0;i<nums.length;i++){
            if(arr.includes(nums[i])){
                continue;
            }
            arr.push(nums[i]);
            fn(arr.slice(0))
            arr.pop();
        }
    }
    fn([]);
    return res;
};
```

## 电话号码的字母组合
```javascript
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
    if(digits.length === 0){
        return []
    }
    let res=[];
    let arr=[['a','b','c'],['d','e','f'],['g','h','i'],['j','k','l'],['m','n','o'],['p','q','r','s'],['t','u','v'],['w','x','y','z']]
    function fn(str,k){
        if(str.length === digits.length){
            res.push(str);
            return;
        }
        let chars=arr[digits[k] - 2];
        for(let j=0;j<chars.length;j++){
            str+=chars[j];
            fn(str,k+1)
            str=str.substr(0,str.length-1)
        }
    }
    fn('',0)
    return res;
};
```

## 字符串的排列
* 注意：虽然也是全排列，但是存在重复元素！！
```javascript
/**
 * @param {string} s
 * @return {string[]}
 */
var permutation = function(s) {
        let res=new Set(); // 去重
        // 回溯算法
        function fn(str,indexArr){
            if(str.length===s.length){
                res.add(str)
                return;
            }
            for(let i=0;i<s.length;i++){
                // 判断索引
                if(indexArr.includes(i)){
                    continue;
                }
                indexArr.push(i)
                fn(str+s[i],indexArr.slice())
                indexArr.pop()
            }
        }
        fn('',[])
        return [...res];
    };
```

## 三数之和
* 但是注意超时了。虽然可以解答正确
```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
        let res=[]
        nums=nums.sort() // 排序
        function fn(arr,num,index){
            if(arr.length===3){
                if(num===0){
                    res.push(arr);
                }
                return;
            }
            for(let i=index;i<nums.length;i++){
                if(i!==index && nums[i]===nums[i-1]){
                    continue;
                }
                fn(arr.concat(nums[i]),num+nums[i],i+1)
            }
        }
        fn([],0,0)
        return res;
    };
```
