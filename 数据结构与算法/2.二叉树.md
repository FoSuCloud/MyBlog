
## 后序遍历
1. 递归方法:
```
			var postorderTraversal = function(root) {
			    if(!root) return []
			    return [...postorderTraversal(root.left),...postorderTraversal(root.right),root.val]
			};
```
2. 迭代方法:关键在于，只有左右节点为空的时候才入数组，并且根节点设置为{val:val}
```
var postorderTraversal = function(root) {
    if(!root) return []
    let tem=[];
    let node=root;
    let res=[]
    while(node){
        // 根据节点是否没有左节点和右节点来判断是否该入数组
        let {left,val,right}=node;
        if(!left&&!right){
            res.push(val)
        }else{
            tem.push({val:val})
            if(right) tem.push(right)
            if(left) tem.push(left)
        }
        node=tem.pop();
    }
    return res
};
```

## 对称二叉树
* 迭代法
```
var isSymmetric = function(root) {
    if(!root) return true
    let arr=[]; // 保存每一层的值
    let len=0;
    let nodes=[root]; // 保存每一层的节点
    while(nodes.length>0){
        let tem=[]
        for(let i=0;i<nodes.length;i++){
            let {val,left,right}=nodes[i]
            // 为了保存顺序，所以即使null也添加进入
			arr.push(left==null?'null':left.val)
			arr.push(right==null?'null':right.val)
            if(left) tem.push(left)
            if(right) tem.push(right)
        }
        let mid=arr.length/2;// 中间索引
        if(arr.slice(0,mid).join('')!=arr.slice(mid).reverse().join('')) return false
        nodes=tem;
        arr=[];
        len++;
    }
    return true
};
```
