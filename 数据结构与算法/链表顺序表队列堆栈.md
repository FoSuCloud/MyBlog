## 在n个有序顺序表中插入一个新元素，并保持原来的顺序不变，平均要移动的元素次数是n/2

## 全排列
1. `如果没有重复值的话，全排列就是 n!`
2. `但是如果有重复的值，那么就先拍不重复再拍重复的`
* 例子: 字符串 "YONYOU"，有几种不同的全排列方式?
* A(2,6)*C(2,4)*C(2,2)=6*5*(4*3/2*1)*(2*1/2*1)=180种

## 堆其实就是一个完全二叉树！！！
## 大顶堆(第一个元素是最大值，(每一个分支的根节点，左节点，右节点)根节点都是最大值)
## 小顶堆(第一个元素是最小值)
## 堆排序
* 堆排序大概就是先一步步生成大顶堆再生成小顶堆
* [堆排序](https://blog.csdn.net/u013384984/article/details/79496052)

## 哈希表的线性探查法
* 公式为`Hash(key)=len%p, p是小于哈希表长度len的最小质数`
* 给出一组元素，它们的关键码为：37，25，14，36，49，68，57，11，散列表为HT[12]，表的大小 m=12 
* 假设采用Hash（key）= key % p ；（p=11）11是最接近m的质数`表的范围是0-11,有arr[11]`
* `首先按照顺序， 37%11 ==6 ,arr[6] =37`
* `25%11 ==3 ,arr[3]=25`
* `14%11 ==3 ,由于 arr[3]已经有位置了，所以就发生哈希冲突了，所以后移，arr[4]=14`
* `36%11==3,由于arr[3],arr[4]都有位了，所以继续后移，arr[5]=36`
* `49%11==5,由于arr[5]，arr[6]有位了，所以arr[7]==49`
* `68%11==2,arr[2]=68`
* `57%11==2,由于arr[2]有位了，3,4,5,6,7都有位了,所以arr[8]=57`
* `11%11==0，arr[0]=11`
* `所以最后就是 11 [] 68 25 14 36 37 49 57 `
* `线性探查法就是一直+1`

## 但是哈希表还有二次探查法
* `二元探查法与线性探查法的区别就在于，二次探查法每次遇到冲突不是+1`
* `遇到冲突选择 进行遍历，i++,i的初始值是1，那么比较是i^2,-i^2`
* `也就是如果出现冲突，执行 n+i^2,如果有位置就坐，没位置就执行n-i^2,如果还没有就i++`
* [参考](https://www.nowcoder.com/test/question/done?tid=31309191&qid=372706#summary)

## 有序线性表进行查找
* `五次查找成功的节点数量？根据二叉树来寻找`
* 如有序线性表arr[1...30]
* `首先找到中点，也就是 (1+30)/2, 15,根节点是15`
* `1.小于15的时候，左子树的根节点是 (1+14)/2 ,7`
* `2. 左子树的左节点是 (1+7)/2 ,3`
* `3. 左子树的右节点是 (8+14)/2 ,11`
* `4. 然后再继续画下去`
* [参考](https://www.nowcoder.com/test/question/done?tid=31253144&qid=372728#summary)

## 有向图
1. 已知一个由5个顶点8条边构成的有向图，`则边数=出度数=入度数=8`
2. `若以邻接表为节点，那么节点数=顶点数+边数=(5+8)=13`

## 广义表
* 广义表K=(m,n,(p,(q,s)),(h,f)),则head[tail[head[tail[tail(K)]]]]的值为
* `head[]返回列表的的第一个元素`
* `tail[]返回删除第一个元素之后的元素`
