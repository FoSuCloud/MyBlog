### 索引
* `在 MySQL 中，索引是一种特殊的数据结构，它可以帮助 MySQL 快速地查找表中的数据。`
* `当您在 MySQL 中创建索引时，MySQL 会为表中的每个索引条目创建一个指针，这些指针指向表中的实际数据行。`
* `这样，当您查询表时，MySQL 可以使用这些指针来快速定位表中的数据。`

* `要使用索引，请在查询语句中使用 WHERE 子句`

#### 使用索引
* 例如，如果您有一个名为 customers 的表，并且该表具有一个名为 last_name 的列，则可以使用以下查询来查找名为 “Smith” 的客户：
* `SELECT * FROM customers WHERE last_name = 'Smith';`
* 如果您已经在 last_name 列上创建了索引，则 MySQL 将使用该索引来快速查找名为 “Smith” 的客户。
* `不管有没有在last_name上建立索引，其实都可以查找到，但是加了索引会更快`

#### 什么时候使用索引
* 使用索引和不使用索引的区别在于查询速度
* `如果您没有在查询语句中使用索引，则 MySQL 必须扫描整个表来查找匹配的行。`

* `当您在 MySQL 中创建索引时，MySQL 会为表中的每个索引条目创建一个指针，这些指针指向表中的实际数据行。`

* 不是所有的表都有索引。您可以在创建表时指定要创建的索引，或者在表已经存在时使用 ALTER TABLE 命令添加索引。

* 虽然索引可以提高查询速度，但是过多的使用索引将会造成滥用。
* 因此索引也会有它的缺点：
* `虽然索引大大提高了查询速度，同时却会降低更新表的速度`，如对表进行INSERT、UPDATE和DELETE。
* `因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件`。 
* `建立索引会占用磁盘空间的索引文件。`
并发性能： 在高并发的情况下，索引的存在可能增加锁的竞争，从而影响并发性能。
* `这是因为在插入和更新操作时，数据库可能需要获取和释放索引上的锁。`
数据分布的影响： `如果数据分布不均匀`，索引可能无法充分发挥其性能优势。例如，如果一个列上的值大部分相同，那么在该列上创建索引可能不会显著提高查询性能。

* 因此，不是所有的列都需要添加索引。一般来说，只有在以下情况下才需要添加索引：
1. 对于经常需要搜索的列
2. 对于经常使用 WHERE 子句的列
3. 对于经常需要连接的列
4. 对于经常需要排序的列
5. 对于经常使用 GROUP BY 和 DISTINCT 的列

#### 查看索引
* MySQL 中查看某个表的索引的方法是使用 SHOW INDEX 语句，语法格式如下：
* SHOW INDEX FROM <表名> [ FROM <数据库名>]
```sql
SHOW INDEX  FROM `experiment`
```
SHOW INDEX 语句的结果列表中包含以下字段：

Table：表示创建索引的数据表名。
Non_unique：表示该索引是否是唯一索引。若不是唯一索引，则该列的值为 1；若是唯一索引，则该列的值为 0。
Key_name：表示索引的名称。
Seq_in_index：表示该列在索引中的位置，如果索引是单列的，则该列的值为 1；如果索引是组合索引，则该列的值为每列在索引定义中的顺序。
Column_name：表示定义索引的列字段。
Collation：表示列以何种顺序存储在索引中。在 MySQL 中，升序显示值“A”（升序），若显示为 NULL，则表示无分类。
Cardinality：索引中唯一值数目的估计值。基数根据被存储为整数的统计数据计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。
Sub_part：表示列中被编入索引的字符的数量。若列只是部分被编入索引，则该列的值为被编入索引的字符的数目；若整列被编入索引，则该列的值为 NULL。
Packed：指示关键字如何被压缩。若没有被压缩，值为 NULL。
Null：用于显示索引列中是否包含 NULL。若列含有 NULL，该列的值为 YES。若没有，则该列的值为 NO。
Index_type：显示索引使用的类型和方法（BTREE、FULLTEXT、HASH、RTREE）。
Comment：显示评注。


