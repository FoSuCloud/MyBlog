## 联结表
* `分解数据为多个表能更有效地存储，更方便地处理，并且具有更大的可伸缩性`。但这些好处是有代价的。




#### 主键
* `主键（primary key）是表中用来标识这个表的每条记录唯一性的列`

#### 外键
* `外键（foreign key） 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。`


#### 联结
* 如果数据存储在多个表中，怎样用单条SELECT语句检索出数据？答案是使用联结。
* 简单地说，联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。
* 使用特殊的语法，可以`联结多个表返回一组输出，联结在运行时关联表中正确的行`。

* 要理解联结不是物理实体。换句话说，它在实际的数据库表中不存在。联结由MySQL根据需要建立，它存在于查询的执行当中。

* 下面就是通过联结查询出了两个表的列
```mysql
select resource_id,project_id from a,b where a.resource_id=b.id;
```
* resource_id是a表的列，project_id是b表的列，a,b是表名，where a.resource_id=b.id是联结条件。

#### 完全限定列名
* 在引用的列可能出现二义性时，必须使用完全限定列名（用一个点分隔的表名和列名）。
* 如果引用一个没有用表名限制的具有二义性的列名，MySQL将返回错误。

#### where语句的重要性
* 利用WHERE子句建立联结关系似乎有点奇怪，但实际上，有一个很充分的理由。
* 请记住，在一条SELECT语句中联结几个表时，相应的关系是在运行中构造的。
* 在数据库表的定义中不存在能指示MySQL如何对表进行联结的东西。你必须自己做这件事情。
* 在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。
* `WHERE子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行。`
* 没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。


#### 笛卡尔积
* `笛卡尔积（Cartesian product）是指在没有WHERE子句的情况下，联结两个表得到的结果。`
* 由没有联结条件的表关系返回的结果为笛卡儿积。`检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。`
```mysql
select resource_id,project_id from a,b;
```

#### 内联结
* `内联结（inner join）是最常见的联结类型，它返回满足联结条件的行。`
* `目前为止所用的联结称为等值联结（equijoin），它基于两个表之间的相等测试。`

```mysql
select resource_id,project_id from a inner join b on a.resource_id=b.id;
```
* `这里，两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定。`
* `在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。`

#### 联结多个表
* SQL对一条SELECT语句中可以联结的表的数目没有限制。
* 创建联结的基本规则也相同。首先列出所有表，然后定义表之间的关系。

```mysql
select resource_id,project_id,resource_count from a , b, c where a.resource_id=b.id and a.resource_spec_id=c.id;
```

