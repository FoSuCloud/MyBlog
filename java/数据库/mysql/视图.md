## 视图
* `视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。`
* `作为视图，它不包含表中应该有的任何列或数据，它包含的是一个SQL查询`

#### 为什么使用视图
❑ `重用SQL语句`。
❑ `简化`复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。
❑ `使用表的组成部分`而不是整个表。
❑ 保护数据。可以`给用户授予表的特定部分的访问权限`而不是整个表的访问权限。
❑ `更改数据格式和表示`。视图可返回与底层表的表示和格式不同的数据。

* 在视图创建之后，可以用与表基本相同的方式利用它们。
* 可以对视图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据

* 重要的是知道视图仅仅是用来查看存储在别处的数据的一种设施。
* `视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。`
* `在添加或更改这些表中的数据时，视图将返回改变过的数据。`

#### 视图的性能问题
* 因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。
* 如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。
* 因此，在部署使用了大量视图的应用前，应该进行测试。

#### 视图的规则和限制
❑ 与表一样，`视图必须唯一命名`（不能给视图取与别的视图或表相同的名字）。
❑ 对于可以创建的视图数目没有限制。
❑ 为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。
❑ 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。
❑ ORDER BY可以用在视图中，但如果从该视图检索数据的SELECT语句中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。
❑ `视图不能索引，也不能有关联的触发器或默认值。`
❑ `视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。`

#### 利用视图简化复杂的联结
```mysql
create view ylp as select a.name,b.create_time,a.myage from ylp_example as a,ylp_time_table as b where a.id=b.id and a.myage>40 
```
* 然后我们就可以在视图上看到对应的数据了
* `然后我们可以基于视图的结果进行数据的增删改查`
```mysql
SELECT name from ylp where myage>60;
```
* 然后就能看到基于视图的结果 的 myage>60 的数据了

* `视图极大地简化了复杂SQL语句的使用。利用视图，可一次性编写基础的SQL，然后根据需要多次使用。`

#### 更新视图
* 通常，`视图是可更新的（即，可以对它们使用INSERT、UPDATE和DELETE）`。
* 更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。
* `如果你对视图增加或删除行，实际上是对其基表增加或删除行`。

但是，并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。
这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：
❑ 分组（使用GROUP BY和HAVING）；❑ 联结；❑ 子查询；❑ 并；❑ 聚集函数（Min()、Count()、Sum()等）；❑ DISTINCT；❑ 导出（计算）列。

* `非常不建议更新视图数据`





