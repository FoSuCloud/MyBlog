## 多机功能
* 复制功能是Redis提供的多机功能中最基础的一个，这个功能是通过主从复制（`master-slave replication`）模式实现的，
* 它允许用户为存储着`目标数据库`的服务器`创建出多个拥有相同数据库副本`的服务器，
* 其中存储目标数据库的服务器被称为`主服务器（master server）`，
* 而存储数据库副本的服务器则被称为`从服务器（slave server，或者称为replica）`

* 对于Redis来说，`一个主服务器可以拥有任意多个从服务器`，而`从服务器本身也可以用作其他服务器的主服务器`，并以此构建出一个树状的服务器结构

* 虽然一个主服务器可以拥有多个从服务器，`但一个从服务器只能拥有一个主服务器`。换句话说，Redis提供的是单主复制功能，而不是多主复制功能。

* `在默认情况下，处于复制模式的主服务器既可以执行写操作也可以执行读操作，而从服务器则只能执行读操作`

* 注意： `对于开启了复制功能的主从服务器，主服务器在每次执行写操作之后，都会与所有从服务器进行数据同步，以此来将写操作产生的改动反映到各个从服务器之上。`

* 举个例子，在主服务器执行了客户端发来的写命令W之后，主服务器会`将相同的写命令W`发送至`所有从服务器执行`，以此来保持主从服务器之间的数据一致性

#### 复制功能作用
* Redis的复制功能可以从`性能`、`安全性`和`可用性`3个方面提升整个Redis系统：
●首先，在性能方面，Redis的复制功能可以给系统的读性能带来线性级别的提升。
* 从理论上来说，用户`每增加一倍数量的从服务器，整个系统的读性能就会提升一倍。`
●其次，通过增加从服务器的数量，用户可以降低系统在遭遇灾难故障时丢失数据的可能性。
* 具体来说，如果用户只有一台服务器存储着目标数据库，那么当这个服务器遭遇灾难故障时，目标数据库很有可能会随着服务器故障而丢失。
* 但如果用户为Redis服务器（即主服务器）设置了从服务器，那么即使主服务器遭遇灾难故障，用户也可以通过从服务器访问数据库。
* `从服务器的数量越多，因为主服务器遭遇灾难故障而出现数据库丢失的可能性就越低。`
●最后，通过同时使用Redis的复制功能和Sentinel功能，用户可以为整个Redis系统提供高可用特性。
* 具有这一特性的Redis系统在`主服务器停机时`，`将会自动挑选一个从服务器作为新的主服务器`，以此来继续为客户提供服务，
* 避免造成整个系统停机。

#### REPLICAOF：将服务器设置为从服务器
* 用户可以通过执行REPLICAOF命令，将接收这个命令的Redis服务器设置为另一个Redis服务器的从服务器：
```shell
        REPLICAOF host port
```
* 命令的host参数用于指定`主服务器`的地址，而port参数则用于指定`主服务器`的端口号。
* 因为Redis的复制操作是以`异步`方式进行的，所以收到REPLICAOF命令的服务器在记录主服务器的地址和端口之后就会向客户端返回OK，
* `至于实际的复制操作则会在后台开始执行`。

* 在接收到REPLICAOF命令之后，主从服务器将执行数据同步操作：
* `从服务器原有的数据将被清空`，`取而代之的是主服务器传送过来的数据副本`。`数据同步完成之后，主从服务器将拥有相同的数据`。

* 注意：`如果主服务器设置了密码，那么在执行REPLICAOF命令之前，用户需要先通过AUTH命令对主服务器进行身份验证`。

#### 通过配置选项设置从服务器
* 用户除了可以使用REPLICAOF命令将运行中的Redis服务器设置为从服务器之外，还可以通过设置replicaof配置选项，在启动Redis服务器的同时将它设置为从服务器：
```shell
        replicaof host port
```
* `        $ redis-server --port 10086--replicaof 127.0.0.16379`
* 比如，通过执行以下命令，我们可以在启动服务器127.0.0.1:10086的同时，将它设置为127.0.0.1:6379的从服务器：

#### 取消复制
* 在使用REPLICAOF命令或者replicaof配置选项将一个服务器设置为从服务器之后，我们可以通过执行以下命令，
* `让从服务器停止复制，重新变回主服务器：`
`        REPLICAOF no one`
*  命令返回OK表示复制已经停止。因为`服务器在停止复制之后仍然会保留复制时产生的数据`，所以我们可以继续访问之前设置的msg键：

#### ROLE
* 查看服务器的角色
```shell
127.0.0.1:6379> role
1) "master"
2) (integer) 0
3) (empty list or set)
```
●数组的第1个元素是字符串"master"，它表示这个服务器的角色为主服务器。
●数组的第2个元素是这个主服务器的`复制偏移量（replication offset）`，它是一个整数，
`记录了主服务器目前向复制数据流发送的数据数量`。
●数组的第3个元素是一个数组，`它记录了这个主服务器属下的所有从服务器`。这个数组的每个元素都由3个子元素组成，
第1个子元素为从服务器的IP地址，第2个子元素为从服务器的端口号，而第3个子元素则为从服务器的复制偏移量。
从服务器的复制偏移量记录了从服务器通过复制数据流接收到的复制数据数量，
当从服务器的复制偏移量与主服务器的复制偏移量保持一致时，它们的数据就是一致的。

* 从服务器的ROLE
```shell
127.0.0.1:6379> ROLE
1) "slave"
2) "a-redis"
3) (integer) 6379
4) "connect"
5) (integer) -1
```
●数组的第1个元素是字符串"slave"，它表示这个服务器的角色是从服务器。
●数组的第2个元素和第3个元素记录了这个从服务器正在复制的`主服务器的IP地址和端口号`。
●数组的第4个元素是主服务器与从服务器当前的连接状态，这个状态的值及其表示的意义如下：
○"none"：主从服务器尚未建立连接。
○"connect"：主从服务器正在握手。
○"connecting"：主从服务器成功建立了连接。
○"sync"：主从服务器正在进行数据同步。
○"connected"：主从服务器已经进入在线更新状态。
○"unknown"：主从服务器连接状态未知。
●数组的第5个元素是从服务器`当前的复制偏移量`。

#### 数据同步
* 当用户将一个服务器设置为从服务器，让它去复制另一个服务器的时候，`主从服务器需要通过数据同步机制来让两个服务器的数据库状态保持一致`。

* 当一个Redis服务器接收到REPLICAOF命令，开始对另一个服务器进行复制的时候，主从服务器会执行以下操作：
* 1）主服务器执行`BGSAVE命令(异步)`，生成一个RDB文件，`并使用缓冲区存储起在BGSAVE命令之后执行的所有写命令`。
* 2）`当RDB文件创建完毕`，主服务器会通过套接字将`RDB文件`传送给从服务器。
* 3）从服务器在接收完主服务器传送过来的RDB文件之后，就会载入这个RDB文件，从而获得主服务器在执行BGSAVE命令时的所有数据。
* 4）当从服务器完成RDB文件载入操作，并开始上线接受命令请求时，`主服务器就会把之前存储在缓存区中的所有写命令发送给从服务器执行`。

* 因为主服务器存储的写命令都是在执行BGSAVE命令之后执行的，所以当从服务器载入完RDB文件，并执行完主服务器存储在缓冲区中的所有写命令之后，主从服务器包含的数据库数据将完全相同。

* 这个通过创建、传送并载入RDB文件来达成数据一致的步骤，我们称之为`完整同步操作`。每个从服务器在刚开始进行复制的时候，都需要与主服务器进行一次完整同步。

#### 在线更新
* 主从服务器在执行完完整同步操作之后，它们的数据就达到了一致状态，但这种一致并不是永久的：
* 每当主服务器执行了`新的写命令`之后，它的数据库就会被改变，`这时主从服务器的数据一致性就会被破坏`。

* 为了让主从服务器的数据一致性可以保持下去，让它们一直拥有相同的数据，Redis会对从服务器进行在线更新：
  ●每当主服务器执行完一个写命令之后，它就会将相同的写命令或者具有相同效果的写命令发送给从服务器执行。
* ●因为完整同步之后的主从服务器在执行最新出现的写命令之前，两者的数据库是完全相同的，`而导致两者数据库出现不一致的正是最新被执行的写命令`，
* 因此从服务器只要`接收并执行`主服务器`发来的写命令`，就可以让自己的数据库重新与主服务器数据库保持一致。

#### 异步更新引起的数据不一致
* 因为在线更新是`异步`进行的，所以在主服务器执行完写命令之后，直到从服务器也执行完相同写命令的这段时间里，
* 主从服务器的数据库将出现`短暂的不一致`，因此`要求强一致性的程序可能需要直接读取主服务器`而不是读取从服务器。

* 此外，因为主服务器可能在执行完写命令并向`从服务器发送相同写命令的过程中因故障而下线`，
* 所以从服务器在`主服务器下线之后`可能会丢失主服务器已经执行的一部分写命令，导致从服务器的数据库与下线之前的主服务器数据库处于不一致状态。

* `因为在线更新的异步本质，Redis的复制功能是无法杜绝不一致的。`

#### 部分同步
* `当因故障下线的从服务器重新上线时`，主从服务器的数据`通常已经不再一致`，因此它们`必须重新进行同步`，让两者的数据库再次回到一致状态。

* 重同步功能（只是优化解决`从服务器`断线重新同步问题）
  ●当一个Redis服务器成为另一个服务器的主服务器时，它会把`每个被执行的写命令`都记录到一个`特定长度`的`先进先出队列`中。
* ●当`断线的从服务器`尝试重新连接主服务器的时候，
* 主服务器将检查`从服务器断线期间`，被执行的那些写命令是否仍然保存在队列里面。
* 如果是，那么主服务器就会直接把`从服务器缺失的那些写命令`发送给从服务器执行，从服务器通过执行这些写命令就可以重新与主服务器保持一致，这样就避免了重新进行完整同步的麻烦。
* ●如果从服务器缺失的那些写命令已经不存在于队列当中，那么主从服务器将进行一次完整同步。

* 因为新的重同步功能需要使用先进先出队列来记录主服务器执行过的写命令，所以这个队列的体积越大，它能够记录的写命令就越多，
* `从服务器断线之后能够快速地重新回到一致状态的机会也就越大`。Redis为这个队列设置的`默认大小为1MB`，
* 用户也可以根据自己的需要，通过配置选项repl-backlog-size来修改这个队列的大小。

#### 无须硬盘的复制
* 主服务器在进行完整同步的时候，需要`在本地创建RDB文件`，然后`通过套接字将这个RDB文件传送给从服务器`。
* 但是，如果主服务器所在宿主机器的`硬盘负载非常大或者性能不佳`，那么`创建RDB文件`引起的`大量硬盘写入`将对主服务器的性能造成影响，并`导致复制进程变慢`。

* 启用了这个特性的主服务器在接收到REPLICAOF命令时将不会再在本地创建RDB文件，`而是会派生出一个子进程`，
* 然后由`子进程通过套接字直接将RDB文件写入从服务器`。这样主服务器就可以在不创建RDB文件的情况下，完成与从服务器的数据同步。

* 要使用无须硬盘的复制特性，我们只需要将repl-diskless-sync配置选项的值设置为yes即可：
```shell
        $ redis-server --repl-diskless-sync yes
```
* 无须硬盘的复制特性只是避免了在主服务器上创建RDB文件，但`仍然需要在从服务器上创建RDB文件`。
* Redis目前还无法在完全不使用硬盘的情况下完成完整数据同步，但不排除将来会出现这样的功能

#### 降低数据不一致情况出现的概率
* 因为复制的在线更新操作以异步方式进行，所以`当主从服务器之间的连接不稳定`，
* 或者从服务器未能收到主服务器发送的更新命令时，主从服务器就会出现数据不一致的情况。

* 为了尽可能地`降低`数据不一致的出现`概率`，Redis从2.8版本开始引入了两个以min-replicas开头的配置选项：
```shell
       min-replicas-max-lag <seconds>

       min-replicas-to-write <numbers>
```
* 用户设置了这两个配置选项之后，`主服务器`只会在`从服务器的数量大于等于`min-replicas-to-write选项的值，
* 并且这些`从服务器与主服务器最后一次成功通信的间隔不超过`min-replicas-max-lag选项的值时才会`执行写命令`。

* 我们可以`让主服务器``只在主从服务器连接良好的情况下执行写命令`。
* 因为在线更新的异步性质，min-replicas-max-lag和min-replicas-to-write并没有办法完全地杜绝数据不一致的情况出现，
* 但它们可以有效地减少因为主从服务器连接不稳定而导致的数据不一致，并降低因为没有从服务器可用而导致数据丢失的可能性。

#### 可写的从服务器
* Redis的`从服务器`在`默认状态下只允许执行读命令`。如果用户尝试对一个只读从服务器执行写命令，那么从服务器将返回以下错误信息：
```shell
        127.0.0.1:12345> REPLICAOF 127.0.0.16379
        OK

       127.0.0.1:12345> SET msg "hello world"
        (error) READONLY You can't write against a read only replica.
```
* Redis之所以将从服务器默认设置为只读服务器
* ，是为了确保从服务器只能通过与主服务器进行数据同步来得到更新，从而保证主从服务器之间的数据一致性。

* 但在某些情况下，我们可能想要将一些`不太重要或者临时性的数据`存储在从服务器中，或者不得不在从服务器中执行一些带有写性质的命令
* （比如ZINTERSTORE命令，它只能将计算结果存储在数据库中，不能直接返回计算结果）。
* 这时我们可以通过将replica-read-only配置选项的值设置为no来打开从服务器的写功能：
`        $ redis-server --port 12345--replica-read-only no`

在使用可写的从服务器时，用户需要注意以下几个方面：
●在主从服务器都可写的情况下，程序必须将写命令发送到正确的服务器上，不能把需要在主服务器执行的写命令发送给从服务器执行，
也不能把需要在从服务器执行的写命令发送给主服务器执行，否则就会出现数据错误。
●从服务器执行写命令得到的数据，可能会被主服务器发送的写命令覆盖。比如，如果
从服务器在执行了客户端发送的SET msg "hello from client"命令之后，
又接收到了主服务器发送的SET msg "hello from master"命令，那么客户端写入的msg键将被主服务器写入的msg键覆盖。
基于这个原因，`客户端在从服务器上面执行写命令时，应该尽量避免与主服务器发生键冲突`，
换句话说，用户应该让客户端和主服务器分别对从服务器数据库中不同的键进行写入，而`不要让客户端和主服务器都去写相同的键`。
●当从服务器与主服务器进行完整同步时，从服务器数据库包含的所有数据都将被清空，其中包括客户端写入的数据。
●为了减少内存占用，降低键冲突发生的可能性，并确保主从服务器的数据同步操作可以顺利进行， `客户端写入从服务器的数据应该在使用完毕之后尽快删除`。
一个比较简单的方法是在`客户端向从服务器写入数据的同时`，为数据设置一个比较短的过期时间，使得这些数据可以在使用完毕之后自动被删除。

#### 使用从服务器处理复杂计算操作
Redis的数据相关命令基本上可以划分为两个种类：
●第1种是简单的读写操作，比如GET命令、SET命令、ZADD命令等，这种命令只需要对数据库进行简单的读写，`它们的执行速度一般都非常快`。
●第2种是比较复杂的计算操作，比如SUNION命令、ZINTERSTORE命令、BITOP命令等，
这种命令需要对数据库中的元素进行聚合计算，并且随着元素数量的增加，计算耗费的时间也会增加，`因此这种命令的执行速度一般都比较慢`。
* 我们可以通过复制功能创建出当前服务器的从服务器，然后让主服务器只处理第1种命令，而第2种命令则交给从服务器处理

* 为了能够在从服务器执行诸如ZINTERSTORE这样的写命令，我们需要把从服务器的可写特性打开，并且
* 在将计算结果存储到从服务器之后，为它设置一个比较短的过期时间，`使得结果可以自动过期`。
* `或者在客户端获得结果之后，由客户端将结果写入主服务器进行保存。`

#### 脚本复制
* Redis服务器拥有两种不同的脚本复制模式，第一种是从Redis 2.6版本开始支持的`脚本传播模式`（whole script replication），
* 而另一种则是从Redis 3.2版本开始支持的`命令传播模式`（script effect replication），接下来将分别介绍这两种模式。

#### 脚本传播模式
* 处于脚本传播模式的主服务器会将`被执行的脚本及其参数（也就是EVAL命令本身）复制到AOF文件以及从服务器中`。
* `因为带有副作用的函数在不同服务器上运行时可能会产生不同的结果`，从而导致主从服务器不一致，
* 所以在这一模式下执行的脚本必须是`纯函数`，换句话说，`对于相同的数据集，相同的脚本以及参数必须产生相同的效果。`

* 为了保证脚本的纯函数性质，Redis对处于脚本传播模式的Lua脚本设置了以下限制：
●脚本不能访问Lua的时间模块、内部状态或者除给定参数之外的其他外部信息。
●在Redis的命令当中，存在着一部分带有随机性质的命令，这些命令对于相同的数据集以及相同的参数可能会返回不同的结果。
* 如果脚本在执行这类带有随机性质的命令之后，尝试继续执行写命令，那么Redis将拒接执行该命令并返回一个错误。
* 带有随机性质的Redis命令分别为：SPOP、SRANDMEMBER、SCAN、SSCAN、ZSCAN、HSCAN、RANDOMKEY、LASTSAVE、PUBSUB、TIME。
●当用户在脚本中调用SINTER、SUNION、SDIFF、SMEMBERS、HKEYS、HVALS、KEYS这7个会以随机顺序返回结果元素的命令时，
* 为了消除其随机性质，Lua环境在返回这些命令的结果之前会先对结果中包含的元素进行排序，以此来确保命令返回的元素总是有序的。
●Redis会确保每个被执行的脚本都拥有相同的随机数生成器种子，这意味着如果用户不主动修改这一种子，`那么所有脚本在默认情况下产生的伪随机数列都将是相同的`。

* `脚本传播模式是Redis复制脚本时默认使用的模式`。如果用户在执行脚本之前没有修改过相关的配置选项，那么Redis将使用脚本传播模式来复制脚本。

* 作为例子，如果我们在启用了脚本传播模式的主服务器执行以下命令：
```shell
    EVAL  "redis.call('SET',  KEYS[1],  'hello  world'); redis.call('SET',  KEYS[2],
    10086); redis.call('SADD', KEYS[3], 'apple', 'banana', 'cherry')" 3 'msg' 'number' 'fruits'
```
* 那么主服务器将向从服务器发送完全相同的EVAL命令：
```shell
    EVAL  "redis.call('SET',  KEYS[1],  'hello  world'); redis.call('SET',  KEYS[2],
    10086); redis.call('SADD', KEYS[3], 'apple', 'banana', 'cherry')" 3 'msg' 'number' 'fruits'
```

#### 命令传播模式
* 处于命令传播模式的主服务器会将`执行脚本产生的所有写命令用事务包裹起来`，然后`将事务复制到AOF文件以及从服务器中`。
* 因为命令传播模式复制的是写命令而不是脚本本身，所以`即使脚本本身包含副作用`，`主服务器给所有从服务器复制的写命令仍然是相同的`，
* 因此处于命令传播模式的主服务器`能够执行带有副作用的非纯函数脚本。`

* 除了脚本可以不是纯函数之外，与脚本传播模式相比，命令传播模式对Lua环境还有以下放松：
●用户可以在执行RANDOMKEY、SRANDMEMBER等带有随机性质的命令之后继续执行写命令。
●脚本的伪随机数生成器在每次调用之前，都会随机地设置种子。换句话说，被执行的每个脚本在默认情况下产生的伪随机数列都是不一样的。

* `比如，即使在命令传播模式下，脚本还是无法访问Lua的时间模块以及内部状态。`

* 为了开启命令传播模式，用户在使用脚本执行任何写操作之前，需要先在脚本中调用以下函数：
`        redis.replicate_commands()`
* 作为例子，如果我们在主服务器执行以下命令：
```shell
        EVAL  "redis.replicate_commands(); redis.call('SET',  KEYS[1],  'hello  world'); redis.
    call('SET',  KEYS[2],  10086); redis.call('SADD',  KEYS[3],  'apple',  'banana',  'cherry')"
    3 'msg' 'number' 'fruits'
```
* 那么主服务器将向从服务器复制以下命令：
```shell
        MULTI
        SET "msg" "hello world"
        SET "number" "10086"
        SADD "fruits" "apple" "banana" "cherry"
        EXEC
```

#### 选择性命令传播
* 为了进一步提升命令传播模式的作用，`Redis允许用户在脚本中选择性地打开或者关闭命令传播功能`，这一点可以通过在脚本中调用redis.set_repl()函数并向它传入以下4个值来完成：
●redis.REPL_ALL——默认值，将写命令传播至AOF文件以及所有从服务器。
●redis.REPL_AOF——只将写命令传播至AOF文件。
●redis.REPL_SLAVE——只将写命令传播至所有从服务器。
●redis.REPL_NONE——不传播写命令。

#### 模式的选择
* 一般来说，用户可以根据以下情况来判断应该使用哪种复制模式：
●如果脚本的`体积不大`，执行的计算也不多，但却会产生大量命令调用，`那么使用脚本传播模式可以有效地节约网络资源`。
●相反，如果一个脚本的`体积非常大`，`执行的计算非常多`，`但是只会产生少量命令调用`，
* 那么使用命令传播模式可以通过重用已有的计算结果来节约计算资源以及网络资源。






