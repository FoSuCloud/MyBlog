## RDB持久化
* RDB持久化是Redis`默认使用的持久化功能`，该功能可以`创建出一个经过压缩的二进制文件`，
* 其中包含了服务器在各个数据库中存储的`键值对数据`等信息。RDB持久化产生的文件都以`．rdb后缀结尾`，其中rdb代表`Redis DataBase`（Redis数据库）。

* Redis提供了多种创建RDB文件的方法，用户既`可以使用SAVE命令或者BGSAVE命令手动创建RDB文件`，
* 也可以通过`设置save配置选项让服务器在满足指定条件时自动执行BGSAVE命令`

#### SAVE：阻塞服务器并创建RDB文件
* 用户可以通过执行SAVE命令，要求Redis服务器以`同步`方式创建出一个`记录了服务器当前所有数据库数据的RDB文件`。
* SAVE命令是一个无参数命令，它在创建RDB文件成功时将返回OK作为结果：

```redis
# redis-cli
127.0.0.1:6379> auth 123456
OK
127.0.0.1:6379> save
OK
```

* 接收到SAVE命令的Redis服务器将遍历数据库包含的所有数据库，并将各个数据库包含的键值对`全部记录到RDB文件`中。
* 在SAVE命令执行期间，R`edis服务器将阻塞，直到RDB文件创建完毕为止`。
* 如果Redis服务器在执行SAVE命令时已经拥有了相应的RDB文件，那么服务器将使用新创建的RDB文件`代替已有的RDB文件`

#### BGSAVE：以非阻塞方式创建RDB文件
* 因为`SAVE命令`在执行时会阻塞整个服务器，所以用户在使用该命令`创建RDB文件期间将无法为其他客户端提供服务`。
* 为了解决这个问题，Redis提供了SAVE命令的异步版本BGSAVE命令：这个命令与SAVE命令一样都是无参数命令，
* 它与SAVE命令的不同之处在于，`BGSAVE不会直接使用Redis服务器进程创建RDB文件，而是使用子进程创建RDB文件`。

* 当Redis服务器接收到用户发送的BGSAVE命令时，将执行以下操作：
* 1）`创建一个子进程`。
* 2）子进程执行SAVE命令，创建新的RDB文件。
* 3）RDB文件创建完毕之后，`子进程退出`并通知`Redis服务器进程（父进程）`:`新RDB文件已经完成`。
* 4）Redis服务器进程`使用新RDB文件替换已有的RDB文件`。


* 因为BGSAVE命令创建RDB文件的操作是由子进程以`异步`方式执行的，所以当用户在客户端执行这个命令时，服务器将立即向客户端返回OK，然后才会在后台开始
```redis
127.0.0.1:6379> bgsave
Background saving started
```
* 因为BGSAVE命令是以异步方式执行的，所以Redis服务器在`BGSAVE命令执行期间仍然可以继续处理其他客户端发送的命令请求`。
* 不过需要注意的是，虽然BGSAVE命令不会像SAVE命令那样一直阻塞Redis服务器，
* 但由于执行BGSAVE命令需要`创建子进程`，所以`父进程占用的内存数量越大，创建子进程这一操作耗费的时间也会越长，`
* 因此Redis服务器在执行BGSAVE命令时，仍然`可能会由于创建子进程而被短暂地阻塞`。


#### 查看rdb文件路径
* `在/data目录下保存rdb文件`
```shell
# redis-cli -a 123456 config get dir 
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
1) "dir"
2) "/data"
```



#### 通过配置选项自动创建RDB文件
* `可以通过设置save选项，让Redis服务器在满足指定条件时自动执行BGSAVE命令：`
`   config set  save <seconds> <changes>`
* `如果服务器在seconds秒之内，对其包含的各个数据库总共执行了至少changes次修改，那么服务器将自动执行一次BGSAVE命令。`


* 我们首先配置save选项为 30秒修改一次文件就自动保存rdb文件
```redis
127.0.0.1:6379> config set save "30 1"
OK
127.0.0.1:6379> set msg 1
OK
```

* `在/data目录下可以看到修改时间`
```redis
# ls -al | grep dump.rdb
-rw-r--r-- 1 redis redis      462 Jul  9 07:33 dump.rdb
```
* 第二次修改
```redis
127.0.0.1:6379> set msg 3
OK
```
* 查看时间
```redis
# ls -al | grep dump.rdb
-rw-r--r-- 1 redis redis      462 Jul  9 07:37 dump.rdb
```
* 为了`避免`由于`同时使用多个触发条件`而导致服务器过于频繁地执行BGSAVE命令，
* Redis服务器在每次成功创建RDB文件之后，负责自动触发BGSAVE命令的时间计数器以及修改次数计数器都会被`清零并重新开始计数`：
* 无论这个RDB文件是由自动触发的BGSAVE命令创建的，还是由用户执行的SAVE命令或BGSAVE命令创建的，都是如此。

#### rdb文件结构
* cat dump.rdb
```shell
# cat dump.rdb
REDIS0009       redis-ver5.0.14
redis-bits@ctime­cused-memH
aof-preamble
            mini-stream
k1k1
ministream%@@Bk1         v1 "k2v2 ! &@3 3 -4 4 0/(5 5-#6 6#<7 G8 8`]5l@Tk10v [myset
1.333.2221o!51.13msgnewmsg
                          new messagetitle7aЈm`
```
1. RDB文件标识符文件最开头的部分为RDB文件标识符
* 这个标识符的内容为"REDIS"这5个字符。Redis服务器在尝试载入RDB文件的时候，可以通过这个标识符快速地判断该文件是否为`真正的RDB文件`。
2. 版本号跟在RDB文件标识符之后的是RDB文件的版本号
* 这个版本号是一个字符串格式的数字，长度为4个字符。`目前最新的RDB文件版本为第9版`，因此RDB文件的版本号将为字符串"0009"。不同版本的RDB文件在结构上都会有一些不同，
* 总的来说，新版RDB文件都会在旧版RDB文件的基础上添加更多信息，因此RDB文件的版本越新，RDB文件的结构就越复杂。
3.  设备附加信息RDB文件的设备附加信息部分记录了生成RDB文件的Redis服务器及其所在平台的信息，
* 比如服务器的版本号、宿主机器的架构、创建RDB文件时的时间戳、服务器占用的内存数量等。
4. 数据库数据 `RDB文件的数据库数据部分`记录了`Redis服务器存储的0个或任意多个数据库的数据`，
* 当这个部分包含多数个数据库的数据时，各个数据库的数据将按照数据库号码从小到大进行排列，比如，0号数据库的数据将排在最前面，紧接着是1号数据库的数据，然后是2号数据库的数据，以此类推，图15-4展示了这一排列顺序。
5.  Lua脚本缓存如果Redis服务器启用了复制功能，那么服务器将在RDB文件的Lua脚本缓存部分保存`所有已被缓存的Lua脚本`。
* 这样一来，从服务器在载入RDB文件完成数据同步之后，就可以继续执行主服务器发来的EVALSHA命令了。
6.  EOF RDB文件的EOF部分用于标识RDB正文内容的末尾，
* 它的实际值为二进制值0xFF。当Redis服务器读取到EOF的时候，它知道RDB文件的正文部分已经全部读取完毕了。
7. CRC64校验和RDB文件的末尾是一个以无符号64位整数表示的CRC64校验和，比如5097628732947693614。
* Redis服务器在读入RDB文件时会通过这个校验和来快速地检查RDB文件是否有出错或者损坏的情况出现。

#### 载入RDB文件
* 首先，当Redis服务器启动时，它会在工作目录中查找是否有RDB文件出现，如果有就打开它，然后读取文件的内容并执行以下载入操作：
  1）检查文件开头的标识符是否为"REDIS"，如果是则继续执行后续的载入操作，不是则抛出错误并终止载入操作。
* 2）检查文件的RDB版本号，以此来判断当前Redis服务器能否读取这一版本的RDB文件。
* 3）根据文件中记录的设备附加信息，执行相应的操作和设置。
* 4）检查文件的数据库数据部分是否为空，如果不为空就执行以下子操作：
* ①根据文件记录的数据库号码，切换至正确的数据库。
* ②根据文件记录的键值对总数量以及带有过期时间的键值对数量，设置数据库底层数据结构。
* ③一个接一个地载入文件记录的所有键值对数据，并在数据库中重建这些键值对。
* 5）如果服务器启用了复制功能，那么将之前缓存的Lua脚本重新载入缓存中。
* 6）遇到EOF标识，确认RDB正文已经全部读取完毕。
* 7）载入RDB文件末尾记录的CRC64校验和，把它与载入数据期间计算出的CRC64校验和进行对比，以此来判断被载入的数据是否完好无损。
* 8）`RDB文件载入完毕，服务器开始接受客户端请求。`

#### 数据丢失
* RDB文件记录的是`服务器在开始创建文件的那一刻`，服务器中包含的所有键值对数据，
* 这种数据持久化方式通常被称为`时间点快照（point-in-time snapshot）`。
* 时间点快照持久化的一个特点是，`系统在停机时将丢失最后一次成功实施持久化之后的所有数据`。
* 对于一个只使用RDB持久化的Redis服务器来说，服务器停机时丢失的数据量将取决于`最后一次成功执行的RDB持久化操作`，以及该操作开始`执行的时间`。

* `无论用户使用的是SAVE命令还是BGSAVE命令，停机时服务器丢失的数据量将取决于创建RDB文件的时间间隔：间隔越长，停机时丢失的数据也就越多。`

* `然而矛盾之处在于，RDB持久化是一种全量持久化操作，它在创建RDB文件时需要存储整个服务器包含的所有数据，并因此消耗大量计算资源和内存资源，所以用户是不太可能通过增大RDB文件的生成频率来保证数据安全的。`

* 用户可以在每次执行写命令之后都执行一次SAVE命令，以此来保证数据处于绝对安全的状态，但这样一来Redis服务器的性能将下降至无法正常使用的水平。相反，用户如果想要保证服务器的性能处于合理水平，就不能过于频繁地创建RDB文件，这样一来，也就不可避免地会出现因为停机而丢失大量数据的情况。

* `RDB持久化的特征来看，它更像是一种数据备份手段而非一种普通的数据持久化手段。为了解决RDB持久化在停机时可能会丢失大量数据这一问题，并提供一种真正符合用户预期的持久化功能`



