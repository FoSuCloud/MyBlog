## 自动过期
* 在构建应用时，我们常常会碰到一些在特定时间之后就不再有用的数据
* 在遇到上述情况时，我们虽然可以自行编写程序来处理这些不再有用的数据，但如果数据库本身能够提供自动移除无用数据的功能，就会给我们带来很多便利。
* 为了解决这个问题，Redis提供了自动的键过期功能（key expiring）。
* 通过这个功能，用户可以让特定的键在指定的时间之后自动被移除，从而避免了需要在指定时间内手动执行删除操作的麻烦。

#### EXPIRE、PEXPIRE：设置生存时间
* 用户可以通过执行EXPIRE命令或者PEXPIRE命令为键设置一个生存时间（Time To Live, TTL）：
* 键的生存时间在设置之后就会随着时间的流逝而不断地减少，`当一个键的生存时间被消耗殆尽时，Redis就会移除这个键。`

* `Redis提供了EXPIRE命令用于设置秒级精度的生存时间，它可以让键在指定的秒数之后自动被移除：`
`        EXPIRE key seconds`

* `而PEXPIRE命令则用于设置毫秒级精度的生存时间，它可以让键在指定的毫秒数之后自动被移除：`
`        PEXPIRE key milliseconds`

* `EXPIRE命令和PEXPIRE命令在生存时间设置成功时返回1；如果用户给定的键并不存在，那么命令返回0表示设置失败。`

* 可以看到3秒后，number就被销毁了
```redis
127.0.0.1:6379> expire number 3
(integer) 1
127.0.0.1:6379> get number
"5"
127.0.0.1:6379> get number
"5"
127.0.0.1:6379> get number
"5"
127.0.0.1:6379> get number
(nil)
```

* pexpire的例子
```redis
127.0.0.1:6379> pexpire not 3000
(integer) 1
127.0.0.1:6379> get not
"test"
127.0.0.1:6379> get not
"test"
127.0.0.1:6379> get not
(nil)
127.0.0.1:6379> get not
(nil)
```

#### 更新键的生存时间
* `当用户对一个已经带有生存时间的键执行EXPIRE命令或PEXPIRE命令时，键原有的生存时间将会被移除，并设置新的生存时间。`

* 例如，一个键一开始的生存时间是3s
```redis
127.0.0.1:6379> expire book 3
(integer) 1
```
* 后面设置为10s,那么就会在10s后被销毁
```redis
127.0.0.1:6379> expire book 10
(integer) 1
127.0.0.1:6379> get book
"test3"
127.0.0.1:6379> get book
"test3"
127.0.0.1:6379> get book
"test3"
127.0.0.1:6379> get book
"test3"
127.0.0.1:6379> get book
"test3"
127.0.0.1:6379> get book
"test3"
127.0.0.1:6379> get book
"test3"
127.0.0.1:6379> get book
"test3"
127.0.0.1:6379> get book
(nil)
```

#### SET命令的EX选项和PX选项
* Redis从2.6.12版本开始为SET命令提供EX选项和PX选项，
* 用户可以通过使用这两个选项的其中一个来达到同时执行SET命令和EXPIRE/PEXPIRE命令的效果：
* `ex表示expire，对应的是秒`
```redis
127.0.0.1:6379> set r1 v1 ex 3
OK
127.0.0.1:6379> get r1
"v1"
127.0.0.1:6379> get r1
"v1"
127.0.0.1:6379> get r1
(nil)
```

```redis
127.0.0.1:6379> set r1 v2 px 3000
OK
127.0.0.1:6379> get r1
"v2"
127.0.0.1:6379> get r1
"v2"
127.0.0.1:6379> get r1
(nil)
```

#### EXPIREAT、PEXPIREAT：设置过期时间
* 通过设置过期时间（expire time），让Redis在`指定UNIX时间来临之后自动移除给定的键`。

* 在对应系统时间到达之后，num被移除了
```redis
127.0.0.1:6379> expireat num 1688346911
(integer) 1
127.0.0.1:6379> get num
"2"
127.0.0.1:6379> get num
(nil)
```
    
```redis
127.0.0.1:6379> pexpireat floatNum 1688346911000
(integer) 1
127.0.0.1:6379> get floatNum
"22"
127.0.0.1:6379> get floatNum
(nil)
```

* 用户只能对整个集合或者整个散列设置生存时间/过期时间，但是却`无法为集合中的某个元素或者散列中的某个字段单独设置生存时间/过期时间`，这也是目前Redis的自动过期功能的一个缺陷。

#### TTL、PTTL：获取键的剩余生存时间
* `在为键设置了生存时间或者过期时间之后，用户可以使用TTL命令或者PTTL命令查看键的剩余生存时间，即键还有多久才会因为过期而被移除。`
```redis
127.0.0.1:6379> pexpire msg 30000
(integer) 1
127.0.0.1:6379> ttl msg
(integer) 26
```
* 返回负数表示已经失效
* 如果给定的键存在，但是并没有设置生存时间或者过期时间，那么TTL命令和PTTL命令将返回-1：
* 如果给定的键并不存在，那么TTL命令和PTTL命令将返回-2：
```redis
127.0.0.1:6379> pttl msg
(integer) -2

[//]: # 失效了，重新设置()
127.0.0.1:6379> set msg 123
OK
127.0.0.1:6379> expire msg 10
(integer) 1
127.0.0.1:6379> pttl msg
(integer) 5913
```

* `ttl的精度问题`
* 在使用TTL命令时，有时候会遇到命令返回0的情况：
* 出现这种情况的原因在于`TTL命令只能返回秒级精度的生存时间，所以当给定键的剩余生存时间不足1s时，TTL命令只能返回0作为结果`。
* 这时，如果`使用精度更高的PTTL命令去检查这些键，就会看到它们实际的剩余生存时间`，表12-6非常详细地描述了这一情景。



