## redis数据库
* 一个Redis服务器可以包含多个数据库。`在默认情况下，Redis服务器在启动时将会创建16个数据库`：
* 这些数据库都使用号码进行标识，其中第一个数据库为0号数据库，第二个数据库为1号数据库，
* 而第三个数据库则为2号数据库，以此类推。

* Redis虽然不允许在同一个数据库中使用两个同名的键，但是由于不同数据库拥有不同的命名空间，
* `因此在不同数据库中使用同名的键是完全没有问题的`，而用户也可以通过使用不同数据库来存储不同的数据，以此来达到重用键名并且减少键冲突的目的。

* 当用户使用客户端与Redis服务器进行连接时，`客户端一般默认都会使用0号数据库`，
* `但是通过使用SELECT命令，用户可以从当前正在使用的数据库切换到自己想要使用的数据库`：
```redis
select db
```

* `redis使用默认的0号数据库不会打印出数据库号码`
```angular2html
127.0.0.1:6379[3]> keys *
(empty list or set)
127.0.0.1:6379[3]>
```

#### keys 
* `KEYS命令接受一个全局匹配符作为参数，然后返回数据库中所有与这个匹配符相匹配的键作为结果：`
`        KEYS pattern`

* `如果我们想要获取数据库包含的所有键,keys *`

* `如果我们想要获取所有以user:为前缀的键`
*
```redis
127.0.0.1:6379> set user:1:profile 1
OK
127.0.0.1:6379> set user:2:profile 123
OK
127.0.0.1:6379> keys user:*
1) "user:2:profile"
2) "user:1:profile"
```

* 全局匹配符： `*匹配零个或者任意多个字符`
* `?匹配单个字符`
* `[abc]匹配方括号中的任意一个字符`
* `[x-y]匹配给定范围内的单个字符`

#### scan
* 以渐进方式迭代数据库中的键，因为keys命令需要检查数据库包含的所有键，并一次性将符合条件的所有键返回给客户端
* 所以当数据库包含的键数量比较大的时候，使用keys命令可能会导致服务器被阻塞

* `SCAN命令，该命令是一个迭代器，它每次被调用的时候都会从数据库中获取一部分键，用户可以通过重复调用SCAN命令来迭代数据库包含的所有键`
`        SCAN cursor`

* SCAN命令的cursor参数用于指定迭代时使用的游标，游标记录了迭代的轨迹和进度。`在开始一次新的迭代时，用户需要将游标设置为0`：
`scan 0`

* SCAN命令的执行结果由两个元素组成：
●第一个元素是进行下一次迭代所需的游标，`如果这个游标为0，那么说明客户端已经对数据库完成了一次完整的迭代`。
●第二个元素是一个列表，这个列表包含了`本次迭代取得的数据库键`；
* 如果SCAN命令在某次迭代中没有获取到任何键，那么这个元素将是一个空列表。

关于SCAN命令返回的键列表，有两点需要注意：
●`SCAN命令可能会返回重复的键`，用户如果不想在结果中包含重复的键，那么就需要自己在客户端中进行检测和过滤。
●`SCAN命令返回的键数量是不确定的，有时甚至会不返回任何键，但只要命令返回的游标不为0，迭代就没有结束`。

```redis
127.0.0.1:6379> scan 0
1) "3"
2)  1) "user:2:profile"
    2) "user:1:profile"
    3) "ministream"
    4) "s1"
    5) "floatNum"
    6) "number"
    7) "article:10086"
    8) "abc"
    9) "book"
   10) "num"
   11) "not"

[//]: # 告诉我们下次迭代的键为3！(   )
127.0.0.1:6379> scan 3
1) "0"
2) 1) "message"
   2) "mini-stream"
   
[//]: # 键为0表示迭代结束(   )
```

#### scan命令的迭代保证
* 针对数据库的一次完整迭代（full iteration）以用户给定游标0调用SCAN命令开始，
* 直到SCAN命令返回游标0结束。SCAN命令为完整迭代提供以下保证：
  ●`从迭代开始到迭代结束的整个过程中，一直存在于数据库中的键总会被返回。`
* ●`如果一个键在迭代的过程中被添加到数据库中，那么这个键是否会被返回是不确定的。`
* ●如果一个键在迭代的过程中被移除了，那么SCAN命令在它被移除之后将不再返回这个键，
* `但是这个键在被移除之前仍然有可能被SCAN命令返回。`
* ●`无论数据库如何变化，迭代总是有始有终的，不会出现循环迭代或者其他无法终止迭代的情况。`

#### 游标的使用
* 在很多数据库中，使用游标都要显式地申请，并在迭代完成之后释放游标，否则就会造成内存泄漏。
* 与此相反，`SCAN命令的游标不需要申请，也不需要释放，它们不占用任何资源，`
* `每个客户端都可以使用自己的游标独立地对数据库进行迭代。`
* 此外，用户可以随时在迭代的过程中停止迭代，或者随时开始一次新的迭代，这不会浪费任何资源，也不会引发任何问题。

#### 迭代与给定匹配符相匹配的键
* 在`默认情况下，SCAN命令会向客户端返回数据库包含的所有键`，它就像KEYS＊命令调用的一个迭代版本。
* 但是通过使用可选的MATCH选项，我们同样可以让SCAN命令只返回与给定全局匹配符相匹配的键：
`        SCAN cursor [MATCH pattern]`

* `此外，即使没有匹配的键了，也可能scan返回的不是0`
```redis
127.0.0.1:6379> scan 0 match user:*
1) "3"
2) 1) "user:2:profile"
   2) "user:1:profile"
127.0.0.1:6379> scan 3 match user:*
1) "0"
2) (empty list or set)
```

#### 指定返回键的期望数量
●COUNT选项只是提供了一个期望值，告诉SCAN命令我们希望返回多少个键，`但每次迭代返回的键数量仍然是不确定的`。
●不过`在通常情况下，设置一个较大的COUNT值将有助于获得更多键，这一点是可以肯定的`。

```redis
127.0.0.1:6379> scan 0 count 10
1) "3"
2)  1) "user:2:profile"
    2) "user:1:profile"
    3) "ministream"
    4) "s1"
    5) "floatNum"
    6) "number"
    7) "article:10086"
    8) "abc"
    9) "book"
   10) "num"
   11) "not"
```
* 在用户没有显式地使用COUNT选项的情况下，SCAN命令将使用10作为COUNT选项的默认值，换句话说，以下两条命令的作用是相同的：
```redis
SCAN cursor

SCAN cursor COUNT 10
```

#### 数据结构迭代命令
* 与获取数据库键的KEYS命令一样，Redis的各个数据结构也存在一些可能导致服务器阻塞的命令：
* ●散列的HKEYS命令、HVALS命令和HGETALL命令在处理包含键值对较多的散列时，可能会导致服务器阻塞。
* ●集合的SMEMBERS命令在处理包含元素较多的集合时，可能会导致服务器阻塞。
* ●有序集合的一些范围型获取命令，比如ZRANGE，也有阻塞服务器的可能。
* 比如，为了获取有序集合包含的所有元素，用户可能会执行命令调用ZRANGE key 0-1，
* 这时如果有序集合包含的成员数量较多，那么这个ZRANGE命令就可能会导致服务器阻塞。

#### randomkey命令
* `RANDOMKEY命令可以从数据库中随机地返回一个键`
* `RANDOMKEY命令不会移除被返回的键，它们会继续留在数据库中。`
```redis
127.0.0.1:6379> randomkey
"s1"
127.0.0.1:6379> randomkey
"s1"
127.0.0.1:6379> randomkey
"message"
127.0.0.1:6379> randomkey
"message"
127.0.0.1:6379> randomkey
"message"
127.0.0.1:6379> randomkey
"mini-stream"
```

#### exists
* 用户可以通过使用EXISTS命令，检查给定的一个或多个键是否存在于当前正在使用的数据库中：
* `如果我们只想确认某个键是否存在，那么只需要将那个键传递给EXISTS命令即可：命令返回0表示该键不存在，返回1则表示该键存在。`
```redis
127.0.0.1:6379> exists fruitsset
(integer) 1
```

* `通过执行以下命令，我们可以知道fruitsset ministream kkkk(不存在)这3个给定键当中，只有2个键是存在的：`
```angular2html
127.0.0.1:6379> exists fruitsset ministream kkkk
(integer) 2
```

#### DBSIZE：获取数据库包含的键值对数量
```redis
127.0.0.1:6379> dbsize
(integer) 15
```

#### type：获取键的数据结构类型
* TYPE命令允许我们查看给定键的类型：
```redis
127.0.0.1:6379> type fruitsset
set
```
* TYPE命令对于字符串键、散列键、列表键、集合键和流键的返回结果都非常直观，
* 不过它对于之后几种类型的键的返回结果则需要做进一步解释：
* ●因为所有有序集合命令，比如ZADD、ZREM、ZSCORE等，都是以z为前缀命名的，所以`有序集合也被称为zset`。
* 因此TYPE命令在接收到有序集合键作为输入时，将返回zset作为结果。
* ●因为HyperLogLog和位图这两种键在底层都是通过字符串键来实现的，所以TYPE命令对于这两种键将返回string作为结果。
* ●与HyperLogLog和位图的情况类似，因为地理位置键使用了有序集合键作为底层实现，
* 所以TYPE命令对于地理位置键将返回zset作为结果。




