## 修改

####  RENAME、RENAMENX：修改键名
* Redis提供了RENAME命令，用户可以使用这个命令修改键的名称：
```redis
127.0.0.1:6379> rename fruitsset fruits
OK
127.0.0.1:6379> keys fruit*
1) "fruits"
```

#### 覆盖已存在的键
* `如果用户指定的新键名已经被占用，那么RENAME命令会先移除占用了新键名的那个键，然后再执行改名操作。`

```redis
127.0.0.1:6379> set k1 v1
OK
127.0.0.1:6379> set k2 v2
OK
127.0.0.1:6379> rename k1 k2
OK
127.0.0.1:6379>  get k1
(nil)
127.0.0.1:6379> get k2
"v1"
```

#### 只在新键名尚未被占用的情况下进行改名
* RENAMENX命令和RENAME命令一样，都可以对键进行改名，
* `但RENAMENX命令只会在新键名尚未被占用的情况下进行改名`，如果用户指定的新键名已经被占用，那么RENAMENX将放弃执行改名操作：

```redis
127.0.0.1:6379> get k2
"v1"
127.0.0.1:6379> set k3 v3
OK
127.0.0.1:6379> renamenx k2 k3
(integer) 0
127.0.0.1:6379> get k3
"v3"
127.0.0.1:6379> get k2
"v1"
```

#### move
* 将给定的键移动到另一个数据库
* `用户可以使用MOVE命令，将一个键从当前数据库移动至目标数据库：`
* 当MOVE命令成功将给定键从当前数据库移动至目标数据库时，命令返回1；如果给定键并不存在于当前数据库，或者目标数据库中存在与给定键同名的键，那么MOVE命令将不做动作，只返回0表示移动失败。
```redis
127.0.0.1:6379> move k2 3
(integer) 1
127.0.0.1:6379> get k2
(nil)
127.0.0.1:6379> select 3
OK
127.0.0.1:6379[3]> get k2
"v1"
```

* `不覆盖同名键:当目标数据库存在与给定键同名的键时，MOVE命令将放弃执行移动操作。`
```redis
127.0.0.1:6379[3]> select 0
OK
127.0.0.1:6379> set k2 v2
OK
127.0.0.1:6379> select 3
OK
127.0.0.1:6379[3]> move k2 0
(integer) 0
127.0.0.1:6379[3]> get k2
"v1"
```
* 响应0表示移动失败了

#### del
* `DEL命令允许用户从当前正在使用的数据库中移除指定的一个或多个键，以及与这些键相关联的值：`
```redis
127.0.0.1:6379[3]> del k2
(integer) 1

127.0.0.1:6379> del message user:2:profile user:1:profile abc
(integer) 4
```

#### UNLINK：以异步方式移除指定的键
* 因为DEL命令会以同步方式执行移除操作，所以如果待移除的键非常庞大或者数量众多，`那么服务器在执行移除操作的过程中就有可能被阻塞`。
* 比如，移除一个包含上百万个元素的集合，移除一个包含数十万个键值对的散列，或者一次移除成千上万个键，都有可能引起服务器阻塞。

* UNLINK命令与DEL命令一样，都可以用于移除指定的键，但它与DEL命令的区别在于，当用户调用UNLINK命令去移除一个数据库键时，
* `UNLINK只会在数据库中移除对该键的引用（reference）`，而`对键的实际移除操作则会交给后台线程执行`，
* `因此UNLINK命令将不会造成服务器阻塞。`

```redis
127.0.0.1:6379> unlink k3 s1 k2
(integer) 3
127.0.0.1:6379> mget k3 s1 k2
1) (nil)
2) (nil)
3) (nil)
```

#### flushdb
* 清空当前数据库, `FLUSHDB命令会遍历用户正在使用的数据库，移除其中包含的所有键值对，然后返回OK表示数据库已被清空。`
```redis
127.0.0.1:6379> select 3
OK
127.0.0.1:6379[3]> flushdb
OK
127.0.0.1:6379[3]> keys *
(empty list or set)
```
* `与DEL命令一样，FLUSHDB命令也是一个同步移除命令，并且因为FLUSHDB移除的是整个数据库而不是单个键，所以它常常会引发比DEL命令更为严重的服务器阻塞现象。`

* `如果用户在调用FLUSHDB命令时使用了async选项，那么实际的数据库清空操作将放在后台线程中以异步方式进行，这样FLUSHDB命令就不会再阻塞服务器了。`

```redis
127.0.0.1:6379[3]> set k1 v1
OK
127.0.0.1:6379[3]> set k2 v2
OK
127.0.0.1:6379[3]> keys *
1) "k2"
2) "k1"
127.0.0.1:6379[3]> flushdb async
OK
127.0.0.1:6379[3]> keys *
(empty list or set)
```

#### FLUSHALL：清空所有数据库
* `与FLUSHDB命令一样，以同步方式执行的FLUSHALL命令也可能会导致服务器阻塞，因此Redis 4.0也给FLUSHALL命令添加了同样的async选项：`

#### swapdb
* `SWAPDB命令接受两个数据库号码作为输入，然后对指定的两个数据库进行互换，最后返回OK作为结果：`
* `swap x y`
* `在SWAPDB命令执行完毕之后，原本存储在数据库x中的键值对将出现在数据库y中，而原本存储在数据库y中的键值对将出现在数据库x中。`

* `SWAPDB命令可以以非阻塞方式互换给定的两个数据库。因为这个命令的执行速度是如此之快，并且完全不会阻塞服务器，`
* `所以用户实际上可以使用这个命令来实行在线的数据库替换操作。`


