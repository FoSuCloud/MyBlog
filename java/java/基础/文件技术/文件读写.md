#### flush
* `flush()方法是将输出流的缓冲区内容立即刷新（写入）到目的地，而不是等待缓冲区满或调用 close() 方法时自动刷新。`
* 这个方法通常用于在输出流尚未关闭的情况下确保将数据写入目标位置。


* 对于 OutputStream 类中的 flush() 方法来说，它将缓冲区中的数据立即刷新到底层流中，以确保数据已经被写入到输出设备或文件中，从而保证数据的完整性。
* `在进行文件操作或网络通信时，如果不调用 flush() 方法，可能会导致数据丢失或者不完整。`

* `我们首先创建了一个输出流和一个输出流写入器(OutputStreamWriter)。然后，我们使用 write() 方法将数据写入缓冲区中。`
```java
import java.io.*;

public class FlushExample {
    public static void main(String[] args) {
        try {
            FileOutputStream outputStream = new FileOutputStream("example.txt");
            OutputStreamWriter writer = new OutputStreamWriter(outputStream);

            writer.write("Hello, World!");

            // 刷新缓冲区内容到文件
            writer.flush();

            writer.close();
            outputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### 内存映射文件
* 内存映射文件不是Java引入的概念，而是操作系统提供的一种功能，大部分操作系统都支持。

* 所谓内存映射文件，就是将`文件映射到内存，文件对应于内存中的一个字节数组`，
* 对文件的操作变为对这个字节数组的操作，而`字节数组的操作直接映射到文件上`。
* 这种映射可以是映射文件全部区域，也可以是只映射一部分区域。

* 这种映射是操作系统提供的一种假象，文件一般不会马上加载到内存，操作系统只是记录下了这回事
* ，`当实际发生读写时，才会按需加载`。
* `操作系统一般是按页加载的`，页可以理解为就是一块，页的大小与操作系统和硬件相关，典型的配置可能是4K、8K等，
* `当操作系统发现读写区域不在内存时，就会加载该区域对应的一个页到内存`。

* 这种按需加载的方式，使得内存映射文件可以方便高效地处理非常大的文件，内存放不下整个文件也不要紧，
* 操作系统会自动进行处理，将需要的内容读到内存，将修改的内容保存到硬盘，将不再使用的内存释放。
* `所以即使文件很大，也可以很快加载，因为是按需加载的`

* 在一般的文件读写中，会有两次数据复制，`一次是从硬盘复制到操作系统内核，另一次是从操作系统内核复制到用户态的应用程序`。
* 而在内存映射文件中，一般情况下，只有一次复制，`且内存分配在操作系统内核`，应用程序访问的就是`操作系统的内核内存空间`，
* 这显然要比普通的读写效率更高。

* 内存映射文件的另一个重要特点是：`它可以被多个不同的应用程序共享，多个程序可以映射同一个文件`，
* 映射到同一块内存区域，一个程序对内存的修改，可以让其他程序也看到，这使得它特别适合用于不同应用程序之间的通信。

* 操作系统自身在加载可执行文件的时候，一般都利用了内存映射文件，比如：
  ❑ 按需加载代码，`只有当前运行的代码在内存，其他暂时用不到的代码还在硬盘`。
  ❑ 同时`启动多次同一个可执行文件，文件代码在内存也只有一份`。
  ❑ 不同应用程序`共享的动态链接库代码在内存也只有一份`。

* 内存映射文件也有局限性。比如，`它不太适合处理小文件，它是按页分配内存的，对于小文件，会浪费空间；`
* 另外，`映射文件要消耗一定的操作系统资源，初始化比较慢。`

* 简单总结下，对于一般的文件读写不需要使用内存映射文件，但如果处理的是大文件，要求极高的读写效率，
* 比如数据库系统，或者需要在不同程序间进行共享和通信，那就可以考虑内存映射文件。
* 理解了内存映射文件的基本概念，接下来，我们看怎么在Java中使用它。

#### 字符流和内存映射文件区别
* `字符流读取和内存映射文件都涉及到将文件内容存储在内存中`
* `但是当使用字符流进行读取时，读取的字符通常会在（应用程序的内存空间）中（作为变量）暂存。`
* 关键区别：
数据加载方式：字符流是逐个字符或一组字符地从磁盘读取，并在内存中存储为字符变量。而内存映射文件是通过将整个文件或部分文件映射到内存中的缓冲区（MappedByteBuffer），实现文件内容的直接访问。
内存占用：字符流是按需读取和处理文件内容，一次只处理一部分数据，所以内存占用相对较小。而内存映射文件会将文件的一部分或整个文件加载到内存中，因此会占用与文件大小相对应的内存空间。
访问方式：字符流以顺序方式逐个字符读取文件内容，通常用于文本处理和解析。而内存映射文件允许直接在内存中访问文件内容，可以通过内存地址进行随机访问，适用于更灵活的数据操作。
性能方面：内存映射文件可以提供更高的读取性能，因为文件内容直接映射到内存中，无需通过字符转换和多次IO操作。字符流的性能受到磁盘IO和字符编码转换等因素的影响。
总的来说，内存映射文件适用于需要快速访问大型文件内容或需要随机访问的场景。字符流适用于按顺序逐个字符读取和处理文件内容的场景。

#### FileInputStream/FileOutputStream或RandomAccessFile
* 内存映射文件需要通过FileInputStream/FileOutputStream或RandomAccessFile，它们都有一个方法：
`        public FileChannel getChannel()`
* FileChannel有如下方法：
```java
        public MappedByteBuffer map(MapMode mode, long position,
long size) throws IOException
```
map方法将当前文件映射到内存，映射的结果就是一个MappedByteBuffer对象，它代表内存中的字节数组，待会我们再来详细看它。
map有三个参数，mode表示映射模式， positon表示映射的起始位置，size表示长度。mode有三个取值：
❑ MapMode.READ_ONLY：只读。
❑ MapMode.READ_WRITE：既读也写。
❑ MapMode.PRIVATE：私有模式，更改不反映到文件，也不被其他程序看到。
```java
    RandomAccessFile file = new RandomAccessFile("abc.dat", "rw");
    try {
        MappedByteBuffer buf = file.getChannel()
        .map(MapMode.READ_WRITE, 0, file.length());
    /   /使用buf...
    } catch (IOException e) {
        e.printStackTrace();
    }finally{
        file.close();
    }
```

#### 设计一个消息队列BasicQueue
* 参考 https://github.com/swiftma/program-logic，位于包shuo.laoma.file.c61下

* 功能：
* BasicQueue是一个`先进先出的循环队列，长度固定，接口主要是出队和入队`，与之前介绍的容器类的区别是：

* 1）`消息持久化保存在文件中，重启程序消息不会丢失`。
* 2）可以供不同的程序进行协作。典型场景是，有两个不同的程序，一个是生产者，另一个是消费者，
* `生成者只将消息放入队列，而消费者只从队列中取消息，两个程序通过队列进行协作`。
* 这种协作方式更灵活，相互依赖性小，是一种常见的协作方式。

* `        public BasicQueue(String path, String queueName) throws IOException`
* `BasicQueue会使用以queueName开头的两个文件来保存队列信息，`
* `一个扩展名是．data，保存实际的消息，另一个扩展名是．meta，保存元数据信息，`
* `如果这两个文件存在，则会使用已有的队列，否则会建立新队列。`


#### rabbitmq的消息队列和使用文件做消息队列有什么区别
* RabbitMQ 是一个功能强大的消息队列系统，而`使用文件作为消息队列是一种简单的消息传递方式`。
* 以下是 RabbitMQ 和使用文件作为消息队列之间的一些区别：
1. 功能和特性：RabbitMQ 提供了丰富的功能和特性，如消息持久化、消息确认机制、消息路由和订阅模型、消息优先级、消息延迟等。
* 它支持多种消息协议，如 AMQP、MQTT 等，以及提供了灵活的消息交换机和队列的配置选项。
* `使用文件作为消息队列通常没有这些高级特性，功能相对简单。`

2. 性能和可扩展性：RabbitMQ 是一个专门为高性能、高可靠性的消息传递设计的系统。
* 它使用基于内存的消息存储和消息路由机制，可以处理大量的并发消息，并支持分布式部署和水平扩展。
* 相比之下，使用文件作为消息队列通常没有这样的高性能和可扩展性，
* `因为文件IO操作相对较慢，并且在高并发情况下可能存在性能瓶颈`。

3. 消息持久化：RabbitMQ 支持消息的持久化，即`将消息存储在磁盘上以防止消息丢失`。 它使用文件系统或数据库来持久化消息。
而使用文件作为消息队列时，你`需要自行处理消息的持久化和恢复`，可能需要编写额外的代码来实现这些功能。

4. 可靠性和可用性：RabbitMQ 提供了可靠的消息传递机制，包括`消息确认和重试机制，以确保消息的可靠传递`。
它还支持集群部署和镜像队列，以提供高可用性和容错能力。
`使用文件作为消息队列通常没有这种内置的可靠性和可用性保障，需要自行实现这些机制`。

5. 生态系统和社区支持：RabbitMQ 拥有广泛的生态系统和活跃的开发社区，提供了丰富的客户端库和工具，使得使用和集成 RabbitMQ 变得更加方便。
相比之下，使用文件作为消息队列的生态系统和社区支持相对较少。















