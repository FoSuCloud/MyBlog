#### 阅读代码的时候，建议按照以下顺序去看
1. 先从外部入口开始，也就是controller文件夹，看业务流程的实现方式，以及与外部系统的接口调用方式。
2. 接下来看entity文件夹，看数据结构的定义和实体类的属性。
3. 再看feign文件夹，看系统之间的调用方式和参数定义。
4. 最后看mq和external文件夹，这些文件夹一般是一些辅助性质的文件夹，用于处理一些异步任务或者调用外部系统的工具类等。

#### 编写一个模块的时候，建议按照以下顺序去编写
1. 先编写entity文件夹中的实体类，定义数据结构和实体类的属性。
2. 接下来编写feign文件夹中的接口定义，定义系统之间的调用方式和参数。
3. 再编写controller文件夹中的接口实现，实现业务流程的处理和与外部系统的接口调用。
4. 最后编写mq和external文件夹中的代码，用于处理异步任务或者调用外部系统的工具类等。

#### 文件夹命名
1. VO（View Object）：表示视图层（用户界面）展示数据的对象，通常与前端UI元素一一对应。
* VO的属性一般与UI上展示的数据相对应，`主要用于展示和传递数据，不包含任何业务逻辑`，通常是只读的。
2. DTO（Data Transfer Object）：表示数据传输对象，`通常用于各层之间的数据传输`，
* 如在Controller层接收请求参数并封装成DTO对象，然后传递给Service层进行业务处理。
* DTO通常只包含数据属性，不包含业务逻辑。
3. BO（Business Object）：表示业务对象，通常用于封装业务逻辑，它包含了业务处理所需的数据和方法。
* BO的属性一般与数据库表相对应，但不一定与数据库表的字段一一对应。
* `BO包含了业务逻辑，可进行数据校验、业务计算等操作。`
4. Condition：表示查询条件对象，通常用于封装各种查询条件，
* `它包含了查询所需的数据和方法，可以进行条件组合和逻辑运算。`
* Condition通常与DAO层一起使用，将查询条件传递给DAO层进行数据查询。
5. Entity：表示实体对象，通常与数据库表一一对应，它包含了数据库表的所有字段以及相关的属性和方法。
* Entity可以直接映射到数据库表，并且具有持久化能力，它与数据库交互，`完成数据的增删改查等操作。`

#### web项目层
1. pojo(plain ordinaty java object): `数据对象原型`
* POJO是一个普通的Java对象，它不依赖于任何框架或类库，`只是一个简单的JavaBean，用于封装数据`。
* 在数据访问层和业务逻辑层中经常使用POJO来表示实体对象，以便于在不同层之间进行数据传输和转换。

2. dao/mapper数据访问层:对数据库进行数据持久化, 也是个接口，只有方法名字，`具体实现在mapper.xml文件里`
* DAO/Mapper是数据访问层的实现，`用于访问数据源（如数据库、缓存等）获取数据，并提供CRUD操作。`
* 在DAO/Mapper中通常定义了一些接口或抽象类，用于定义数据访问的方法，具体的实现可以由不同的框架或类库来完成。

3. controller控制层: 接受前端请求，进行业务操作
* 用于接受和处理用户请求，并调用业务逻辑层完成具体的业务处理。
* 在Controller中通常定义了一些请求处理方法，用于处理不同的请求，`并根据需要调用Service来完成具体的业务处理`
* ，最后返回视图或数据。在Web开发中，Controller通常会`返回JSON数据或HTML页面，用于展示数据和交互界面。`

4. service业务逻辑层: 为了`处理包含多个POJO对象（即对多个表的数据操作）时，进行事务管理（声明式事务管理）`，
* Service层（其接口的实现类）被注入多个DAO对象，以完成其数据操作。
* `Service存放业务逻辑处理，也是一些关于数据库处理的操作，但不是直接和数据库打交道`

#### of与from
* `of用于创建某个对象实例`
* `from用于把一个对象转换为期望的对象实例`
```text
LocalDate date = LocalDate.of(2023, 3, 21);
```
* `例如from把LocalDateTime转换为LocalDate`
```text
LocalDateTime dateTime = LocalDateTime.of(2023, 3, 21, 12, 30);
LocalDate date = LocalDate.from(dateTime);
```

#### 硬编码
* 在Java代码中使用硬编码指的是直接将某些参数或常量值直接写在代码中，而不是使用变量或常量来引用这些值。
* 虽然这种方式很方便，但也有以下几个坏处：
1. 可维护性差：当某些参数或常量值需要修改时，需要在代码中找到并修改对应的值，这样的修改很容易出错，且会耗费大量的时间和精力。
2. 可读性差：代码中的硬编码不仅会增加代码的长度，而且也难以理解。当代码中存在大量的硬编码时，很难快速了解代码的含义，更难调试和维护代码。
3. 可移植性差：硬编码的值通常是针对特定的环境或场景进行设定的，因此在不同的环境或场景下可能无法正常工作。
4. 可测试性差：硬编码的值通常无法轻易地进行修改或替换，这也会影响测试的可靠性和有效性。





