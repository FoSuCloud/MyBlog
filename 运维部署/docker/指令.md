## FROM指令
* 指定base镜像
---
* 多层镜像需要指定from=builder。单层镜像不需要。
* 因为多层镜像的话需要指定生成镜像是哪一层. `指明当前的镜像基于哪个镜像构建`
---
```dockerfile
FROM docker/vwf-base/nginx-nodejs:v1.21.1 as builder
RUN mv vue.config.js.bak vue.config.js \
    && npm install \
    && npm run build 

FROM docker/vwf-base/nginx:v1.21.1
COPY dockerbuild/nginx.conf /etc/nginx/nginx.conf
# 在docker里面的目录需要使用 RUN cp 用于指定目录 替换
COPY --from=builder /root/dist /var/lib/manager
```
* `我们首先FROM一个nodejs基础镜像，并且as builder`
* `基于这个基础镜像进行安装构建`
* `然后基于第二个基础镜像nginx运行，因为第一个基础镜像中没有nginx!`
* `但是我们现在已经在第二个基础镜像上了，所以在nodejs镜像构建好的dist文件夹就没有了`
* `但是我们需要这个静态资源，我们的网关nginx是指向这个文件夹的。`
* `所以我们COPY --from=builder /root/dist /var/lib/manager`
* `从第一层镜像构建好的dist目录下把构建好的资源复制到nginx网关这个镜像上的/var/lib/manager下`
---
* #FROM scratch 表示使用空白镜像作为基础镜像

## MAINTAINER
* 镜像作者，任意字符串

## COPY
* 将文件从build context(`也就是执行dockerfile文件的目录，执行docker build -f xxx命令的path`)复制到镜像
* `COPY src dest 。 把当前目录下的src复制到镜像的dest目录(没有则创建)`

## ADD
* `ADD和COPY类似，都是复制文件/目录到镜像。但是ADD指定的src如果是tar,zip,tgz,xz等归档文件，那么文件会自动解压到dest!`

## ENV
* `设置环境变量，可以被后面的指令使用`
* 例子：
```dockerfile
    ENV MY_VERSION 1.3 
    RUN apt-get install -y mypackage=$MY_VERSION
```

## EXPOSE
* 指定容器中的进程会监听某个端口，docker可以将该端口暴露出来

## VOLUME
* 将文件或目录声明为volumn(存储卷)

## WORKDIR
* `为后面的RUN CMD ENTRYPOINT ADD COPY指令设置镜像中的工作目录(类似于终端初始化的路径pwd)`

## RUN
* `在容器中运行指定的命令`
* 例如touch,npm install,npm run build等自定义或dockerbuild不支持的命令都可以使用RUN来执行

## CMD
* `在容器启动后！！！ 默认执行的命令`
* `由于CMD是在容器启动后默认执行的命令，所以即使dockerfile有多个CMD命令，也只有最后一个生效`
* `并且CMD可以被docker run之后的参数替代！`

## ENTRYPOINT
* `设置容器启动时！！！运行的命令`
* `由于ENTRYPOINT是在容器启动时指定的命令，所以即使dockerfile有多个ENTRYPOINT命令，也只有最后一个生效`
* 和CMD不同的是，docker run 之后的参数会被当作参数传递给ENTRYPOINT


