## arr.splice(1,1,1)===[x]
1. 数组使用splice方法返回的是删除的部分数组,splice三个参数分别表示索引(必须),删除个数(必须),添加的元素
2. splice方法用法:
```
			var arr=[1,2,3];
			console.log(arr.splice(1,1,1));//[2]
			console.log(arr);//[1,1,3]
			console.log(arr.splice(1,0,2));//第二个参数为0表示不删除元素
			console.log(arr);//[1,2,1,3],2直接插入到下标为1的元素处
			console.log(arr.splice(1,0,2,3,4));
			console.log(arr);//[1,2,3,4,2,1,3]第三个参数可以是多个参数,都插入到1的位置
```
3. 例子:`[1,1,3].splice(1,1,2)===[2]`
4. `对数组进行删除后，的确返回[2]这个数组，但是数组属于引用数据类型，对===除了值相等，还需要内存地址相等！`

## arr空数组直接赋值
1. 对于空数组来说，它的长度根据被赋值的最大数组下标元素决定，如果被赋值的最大下标元素是arr[5],那么数组长度就是6
2. 如果存在某些数组下标元素没有被赋值，那么那些元素就是`empty,也就是undefined`
```
			var arr=[];
			arr[0]=0;
			arr[3]=3;
			arr[5]=5;
			console.log(arr);
			console.log(arr.length);//6
			for(var i=0;i<arr.length;i++){
				console.log(arr[i]);//存在undefined
			}
```

## 微任务宏任务执行顺序
```
		console.log('1');
			// new Promise是异步微任务,在一个执行循环结束后执行
			new Promise(function(resolve,reject){
				console.log('2');
				setTimeout(function(){
					console.log('5');
					// resolve('success');//此时先打印5再去打印4
				},0);
				resolve('success');//此时先执行then,console.log('4')再去执行5
			}).then(()=>{
				console.log('4')
			})
			console.log('3');
			// setTimeout属于异步宏任务,在一次事件循环之后,如果有微任务先执行微任务,然后再来执行异步宏任务
			setTimeout(function(){
				console.log('6')
			},0)
```

## 数组sort方法有参数！
```
			var arr=[3,5,1,7,4];
			console.log(arr.sort());//默认升序排序[1,3,4,5,7]
			console.log(arr);//sort排序方法能够改变原数组
			//需要注意的是,sort方法其实是可以有一个参数的,该参数必须是函数
			//如果给sort方法指定函数,那么根据函数对数组里面的值进行两两比较,如果大于0,那么就颠倒顺序
			function del(a,b){
				return b-a;//自定义一个降序排序的函数
			}
			console.log(arr.sort(del));//[7,5,3,1]
```

## 获取字符串长度
```
如果第二个参数 bUnicode255For1 === true，则所有字符长度为 1
否则如果字符 Unicode 编码 > 255 则长度为 2

			function strLength(s, bUnicode255For1) {
				var num=0;
				for(var i=0;i<s.length;i++){
					if(s.charCodeAt(i)>255&&!bUnicode255For1){
						num+=2;
					}else{
						num+=1;
					}
				}
				return num;
			}
			console.log(strLength('hello world, 牛客', true))
```

## 统计字符串频率
```
统计字符串中每个字符的出现频率，返回一个 Object，key 为统计字符，value 为出现频率
1. 不限制 key 的顺序
2. 输入的字符串参数不会为空
3. 忽略空白字符

function count(str) {
    var obj={};
    var arr=str.split("");

    arr.forEach((item)=>{
        if(obj[item]==undefined&&item!=' '){
            obj[item]=1;
        }
        else if(obj[item]>0){
            obj[item]+=1;
        }
    })
    return obj;
}
```

## 在不直接修改数组的前提下，给数组头部添加一个元素
1. slice(0)表示从0也就是第一个元素开始选取，第二个参数不设置就是选取所有元素，然后返回选取的子数组(与原来数组不一样)
```
var new_arr=arr.slice(0);//值相等的子数组
new_arr.unshift(item);
```
2. 使用[]与concat生成新数组
```
[item].concat(arr);
```

## 删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组
1. `return arr.slice(1);`
2. 使用filter过滤器
```
return arr.filter((item,index)=>{
        if(index!=0) return true;
    })
	把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。
```

## 合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组
1. `return arr1.slice(0).concat(arr2)`
2. `return arr1.concat().concat(arr2); arr1.concat()返回的是一个新的数组，不是浅拷贝之后的数组`

## 在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组
1. 使用concat/slice 和splice(index,0,item)
```
    var new_arr=arr.concat();
    new_arr.splice(index,0,item);
    return new_arr;
```
2. 通过index来巧妙的设置slice,concat
```
return arr.slice(0,index).concat([item]).concat(arr.slice(index))
```

## 统计数组 arr 中值等于 item 的元素出现的次数
1. 通过map来统计符合条件的元素
```
    var num=0;
    arr.map((it)=>{
        if(item==it){
            num++;
        }
    })
    return num;
```
2. 通过filter来获取符合条件的数组
```
    var new_arr=arr.filter((it)=>{
        if(it==item) return true;
    });//filter不会改变原数组
    return new_arr.length;
```

## 找出数组 arr 中重复出现过的元素
1. 通过indexOf(item,index+1)与新数组中是否有该元素
```
			    var new_arr=[];
			    arr.filter((item,index)=>{
			        if(arr.indexOf(item,index+1)!=-1&&new_arr.indexOf(item)==-1){
			            new_arr.push(item)
			            return true;
			        }
			    })
			    return new_arr;
```
2. 通过filter,新数组,lastIndexOf,indexOf来判断
```
			    var new_arr=[]
				arr.filter((item)=>{
			        if(arr.indexOf(item)!=arr.lastIndexOf(item)&&new_arr.indexOf(item)==-1){
			            new_arr.push(item)
						return false;
			        }else{
						return true;
					}
			    })
			    return new_arr;
```
3. 先排序，sort会直接改变原数组，然后再判断下一个元素是否等于本元素，注意数组越界
```
				arr.sort();
				var new_arr=[];
				arr.filter((item,index)=>{
					if(index<arr.length&&item==arr[index+1]&&new_arr.indexOf(item)==-1){
						new_arr.push(item)
						return true;
					}
				})
				return new_arr;
```

## 为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组
1. 使用map
```
			    return arr.map((item)=>{
			        return Math.pow(item,2)
			    })
```
2. 使用forEach
```
				arr.forEach((item,index)=>{
					arr[index]=Math.pow(item,2)
				})
				return arr
```
3. 使用filter
```
				arr.filter((item,index)=>{
					arr[index]=Math.pow(item,2);
					return true;
				})
				return arr
```

## 获取本周的月日
```
			  function getWeek(){
				// 一周
				var arr = [];  // 周一开始
				var newdate = new Date('2019-11-14')
				var now_day=newdate.getDate();
				var now = newdate.getTime();
				var month=newdate.getMonth()+1;
				var day = newdate.getDay();    // 星期
				var oneDayTime = 60 * 60 * 24 * 1000;
				for (var i = 1; i < 8; i++) {
				  if (day >= i) {
					var dd = new Date(now - (day - i) * oneDayTime).getDate();
					if(now_day<dd){
						arr.push((month-1)+'-'+(dd < 10 ? '0' + dd : dd + ''));
					}else{
						arr.push(month+'-'+(dd < 10 ? '0' + dd : dd + ''));
					}
				  } else {
					var aa = new Date(now + (i - day) * oneDayTime).getDate();
					if(now_day>aa){
						arr.push((month)+'-'+(aa < 10 ? '0' + aa : aa + ''));
					}else{
						arr.push(month+'-'+(aa < 10 ? '0' + aa : aa + ''));
					}
				  }
				}
				return arr;
			  };
```

## 判断当前日期为当年第几周
```
			  function getYearWeek(a, b, c) {
			      //date1是当前日期 (需要注意的是month的索引从开始，所以需要减一)
			      //date2是当年第一天
			      //d是当前日期是今年第多少天
			      //用d + 当前年的第一天的周差距的和在除以7就是本年第几周
				  // 此处的valueOf其实相等于getTime获取时间戳
			      var date1 = new Date(a, parseInt(b) - 1, c), date2 = new Date(a, 0, 1),
			          d = Math.round((date1.valueOf() - date2.valueOf()) / 86400000);
			      return Math.ceil((d + date2.getDay()+1) / 7);
				  //(d + date2.getDay()+1)的存在是因为该年的第一天可能不是周一，而且要修改为周日为每周起始，所以+1，所以要获取该年第一天是周几，对应增加
			  };
			  console.log(getYearWeek(2019,1,6));//此时就是第二周了！
```

## 在数组 arr 中，查找值与 item 相等的元素出现的所有位置
```
			function findAllOccurrences(arr, target) {
			    var new_arr=[];
			    while(arr.indexOf(target)!=-1){
			        var index=arr.indexOf(target);
			        new_arr.push(index);
			        arr.splice(index,1,null);
					console.log(arr)
			    }
			    return new_arr;
			}
```
* `arr.splice(index,1,null);表示从索引为index的位置开始删除一个元素，然后在该位置添加一个元素为null`

## 全局变量
* `在Javascript语言中，声明变量使用的都是关键字var，如果不使用var而直接声明变量，则该变量为全局变量。`
```
function globals() {
    var myObject = {
      name : 'Jory'
    };
	//如果不使用var,那么myObject就是全局变量
    return myObject;
}
```

## 修改 js 代码中 parseInt 的调用方式，使之通过全部测试用例
```
function parse2Int(num) {
    var reg=new RegExp(/\D/ig);
    var reg_num=num.search(reg);
    return reg_num==-1?parseInt(num):parseInt(num.slice(0,reg_num));
}
```
* 看到大佬的解法是`parseInt(num,10)`
```
看到还有一种解法，很巧妙，因为parseInt(string/Number,axis)方法是有两个参数的，（虽然我们一般只用一个参数），第一个参数是字符串，parseInt方法解析第一个参数是从第一个字符开始直到第一个不是数字的字符，如果第一个字符就不是数字，那么就返回NaN。
第二个参数是使用的进制，但是如果第一个参数不是字符串而是直接使用数字Number，例如parseInt(0x12,10),那么这时候就是16+2=18，而不是0了，因为第一个参数优先级高于第二个参数，此时第二个参数即使设置了进制也不生效.
看到大佬的解法就是使用parseInt(str,10)，因为该题目第一个参数肯定是字符串，所以最后都是把第一个参数的第一个数字部分截取出来再去转为10进制
```

## 计时器
1. 题目
```
实现一个打点计时器，要求
1、从 start 到 end（包含 start 和 end），每隔 100 毫秒 console.log 一个数字，每次数字增幅为 1
2、返回的对象中需要包含一个 cancel 方法，用于停止定时操作
3、第一个数需要立即输出
```
2. `该题目有点毛病？虽然实现了，但是我觉得很鸡肋，即使函数多了个cancel方法，但是一执行该方法，之前设置的数字哟有什么意义？因为一执行该方法，计时器就会停止`
```
			function count(start, end) {
			    console.log(start);
			    var time=setInterval(()=>{
			        if(start<end){
						start+=1;
						console.log(start);
					}
			    },100)
				return {cancel:function(){
					clearInterval(time)
				}};
			}
			count(1,3).cancel()
```
