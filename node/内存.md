## v8的垃圾回收机制
* `https://zhuanlan.zhihu.com/p/520393745`
* 在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在 Node 中通过JavaScript 使用内存时就会发现只能使用部分内存`（64 位系统写约 1.4GB，32 位系统下约为 0.7GB）`。
* 在这样的限制下，将会导致 Node 无法直接操作大内存对象，比如`无法将一个 2GB 的文件读入内存中进行字符串分析处理`，即使物理内存有 32GB，
* 这样在单个 Node 进程的情况下，计算机的内存资源无法得到充分的使用。

* 造成这个问题的主要原因就在于 Node 基于 V8 构建，所以`在 Node 中使用的JavaScript 对象基本上都是通过 V8 自己的方式来进行分配和管理的`。
* V8 的这套内存管理机制在浏览器的应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求，
* 但在 Node 中，这却限制了开发者随心所欲使用大内存的想法。

#### V8 的对象分配
* `在 V8 中，所有的 JavaScript 对象都是通过堆来进行分配的`
* 当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已经申请的堆空闲内存不够分配新的对象，将继续申请堆内存，`直到堆的大小超过 V8 的限制为止。`

* `1.对于网页来说，V8 的限制值已经绰绰有余`。`2.深层原因是 V8 的垃圾回收机制的限制`。按
* 官方的说法，以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要 50 毫秒以上，做一次非增量式的垃圾回收甚至要 1 秒以上。
* `这是垃圾回收中引起 JavaScript 线程暂停执行的时间`，
* 在这样的时间花销上，应用的性能和响应能力都会直线下降。这样的情况不仅仅后端服务无法接受，前端浏览器也无法接受，因此，在当时的考虑下直接限制堆内存是一个好的选择。


## 内存管理
* `--max-old-space-size 是 Node.js 的一个命令行参数，它用于设置 Node.js 进程的最大内存限制。具体来说，它指定了 V8 引擎中老生代对象占用的最大内存空间，以字节为单位。`
* 除了 --max-old-space-size 参数外，Node.js 还有其他一些参数可以用于控制内存和 GC，比如 --max-new-space-size 和 --gc-interval。这些参数可以根据具体情况进行调整，以优化程序的性能和稳定性。

* `--max-new-space-size 命令行参数用于设置新生代内存空间的最大值。`
* 比较遗憾的是，`这两个最大值需要在启动时就指定`，这意味着， `V8使用的内存没有办法根据使用情况自动扩充`，当内存分配过程中超过极限值时，就会引起进程出错。

* `按照https://stackoverflow.com/questions/48387040/how-do-i-determine-the-correct-max-old-space-size-for-node-js`
* 按照建议，在内存为2gb的机器上，推荐使用老生代空间内存为1.5gb

#### 解决内存不足的问题
* 在前端项目中，通常需要使用 --max-old-space-size 参数来解决内存不足的问题。例如，`在处理大型图片、执行复杂计算或者使用大量内存的第三方库时，可能会导致 Node.js 进程内存占用过大，从而导致程序崩溃或者运行缓慢。使用 --max-old-space-size 参数可以限制 Node.js 进程的内存占用，避免这种问题的发生。`
* `而且有时候在构建的时候，如果项目依赖的三方库太多，代码量多，也可能会出现内存不足的情况`
* 设置 --max-old-space-size 参数不会直接提高内存，而是控制内存的使用。`如果你将参数设置为一个较大的值，可以让 Node.js 进程能够使用更多的内存`，从而提高程序的性能。但是，这也可能会导致内存泄漏和 GC（垃圾回收）问题，因此你需要根据具体情况进行调整。

#### 设置 --max-old-space-size为什么会导致内存泄漏和 GC（垃圾回收）问题？
* 具体来说，如果你将 `--max-old-space-size 参数设置得过大，可能会导致 Node.js 进程占用的内存过多，从而增加 GC 的负担`。
* `如果同时存在内存泄漏的情况，这些未释放的对象会占用大量的内存空间，导致 GC 的效率变低，甚至可能无法回收这些对象。`
* `这样一来，内存占用会不断增加，最终导致 Node.js 进程崩溃或者运行缓慢。`
---
* `因此，为了避免内存泄漏和 GC 问题，你需要合理设置 --max-old-space-size 参数，并且尽可能减少不必要的对象创建和引用。`

#### 新生代对象和老生代对象
* V8 引擎中将对象分为新生代对象和老生代对象两种类型，这两种类型的对象在 GC（垃圾回收）过程中会有不同的处理方式。
1. `新生代对象是指存活时间较短的对象，通常是在堆上分配的小对象。`
* 在 V8 引擎中，新生代对象被分配在一块称为“新生代空间”的内存区域中。新生代空间被分为两个区域，分别为 From 空间和 To 空间。
* `当一个新生代对象被分配时，它会被复制放入 From 空间中。`. `当 From 空间被填满时，V8 引擎会执行一次 Scavenge GC，将仍然存活的对象复制到 To 空间中，同时清空 From 空间。`
* `如果一个新生代对象经过多次 Scavenge GC 仍然存活，它会被认为是老生代对象，然后被移动到老生代空间中。所以老生代对象就是从新生代对象转换为来的`

* `完成复制后，From 空间和 To 空间的角色发生对换`，简而言之，在垃圾回收的过程中，就是通过将存活对象在两个 semispace 空间之间进行复制。

2. `老生代对象是指存活时间较长的对象，通常是较大的对象。在 V8 引擎中，老生代对象被分配在一块称为“老生代空间”的内存区域中。`
* 老生代空间通常比新生代空间更大，也更容易发生内存碎片。为了处理老生代空间中的内存碎片，V8 引擎会定期执行一次 Mark-Sweep GC 或者 Mark-Compact GC。
* `Mark-Sweep GC 会标记所有存活的对象，并清除未标记的对象，这样会留下一些不连续的内存碎片。`
* `Mark-Compact GC 会将所有存活的对象移动到内存区域的一端，然后清除不再使用的内存区域，从而避免了内存碎片的问题。`
---
* 因此，V8 引擎中老生代对象和新生代对象的 GC 过程是不同的。新生代对象主要通过 Scavenge GC 进行垃圾回收，而老生代对象则需要执行 Mark-Sweep GC 或者 Mark-Compact GC 来回收垃圾。
* `由于新生代对象存活时间较短，因此它们的 GC 过程相对简单，同时新生代空间的大小也较小。老生代对象存活时间较长，因此它们的 GC 过程相对复杂，同时老生代空间的大小也较大。`
---
* `所以我们的node程序内存不足，一般通过调整老生代对象的最大值，就好了，因为新生代对象本来占用的空间就不大，如果存活的gc次数多了，很快就会转换为老生代对象的！`

### 当 V8 的新生代对象需要转移到老生代对象时，会执行以下步骤
* 首先，新生代对象会被复制到老生代对象区域。这个过程被称为晋升（promotion）。晋升通常发生在新生代对象已经经历了一定数量的垃圾回收循环后，仍然存活下来。
* 在晋升的过程中，V8 将新生代对象从新生代对象区域复制到老生代对象区域。这个过程被称为膨胀（tenuring）。V8 使用了一个称为“Survival Counters”的机制来跟踪对象的生命周期。如果一个对象经历了一定数量的垃圾回收循环后仍然存活下来，那么它的生存计数器就会被增加。当生存计数器达到一定的阈值时，对象就会被晋升到老生代对象区域。
* 在晋升的过程中，V8 还会对对象进行优化。例如，它会将对象的属性存储在固定的位置，以提高访问速度。
* 最后，新生代对象区域会被清空。这个过程被称为垃圾回收（garbage collection）。在垃圾回收的过程中，V8 会扫描新生代对象区域，找到不再使用的对象，并将它们释放掉。

* 需要注意的是，`晋升是一个相对较为昂贵的操作`，因为它涉及到对象的复制和优化。因此，V8 将尽可能地延迟晋升的时间，以减少晋升的频率和开销。此外，如果晋升的对象比较大，V8 也会尝试使用增量标记（incremental marking）等技术来减少晋升的影响。

1. 在默认情况下，V8 的对象分配主要集中在 From 空间中。对象从 From 空间中复制到 To 空间时，会检查它的内存地址来判断这个对象是否已经经历过一次 Scavenge 回收。如果已经经历过了，会将该对象从 From 空间复制到老生代空间中，如果没有，则复制到 To 空间中。
2. 另一个判断条件是 To 空间的内存占用比。当要从 From 空间复制一个对象到 To 空间时，如果 To 空间已经使用了超过 25%，则这个对象直接晋升到老生代空间中


