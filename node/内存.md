## v8的垃圾回收机制
* https://zhuanlan.zhihu.com/p/520393745

## 内存管理
* `--max-old-space-size 是 Node.js 的一个命令行参数，它用于设置 Node.js 进程的最大内存限制。具体来说，它指定了 V8 引擎中老生代对象占用的最大内存空间，以字节为单位。`
* 除了 --max-old-space-size 参数外，Node.js 还有其他一些参数可以用于控制内存和 GC，比如 --max-new-space-size 和 --gc-interval。这些参数可以根据具体情况进行调整，以优化程序的性能和稳定性。

#### 解决内存不足的问题
* 在前端项目中，通常需要使用 --max-old-space-size 参数来解决内存不足的问题。例如，`在处理大型图片、执行复杂计算或者使用大量内存的第三方库时，可能会导致 Node.js 进程内存占用过大，从而导致程序崩溃或者运行缓慢。使用 --max-old-space-size 参数可以限制 Node.js 进程的内存占用，避免这种问题的发生。`
* `而且有时候在构建的时候，如果项目依赖的三方库太多，代码量多，也可能会出现内存不足的情况`
* 设置 --max-old-space-size 参数不会直接提高内存，而是控制内存的使用。`如果你将参数设置为一个较大的值，可以让 Node.js 进程能够使用更多的内存`，从而提高程序的性能。但是，这也可能会导致内存泄漏和 GC（垃圾回收）问题，因此你需要根据具体情况进行调整。

#### 设置 --max-old-space-size为什么会导致内存泄漏和 GC（垃圾回收）问题？
* 具体来说，如果你将 `--max-old-space-size 参数设置得过大，可能会导致 Node.js 进程占用的内存过多，从而增加 GC 的负担`。
* `如果同时存在内存泄漏的情况，这些未释放的对象会占用大量的内存空间，导致 GC 的效率变低，甚至可能无法回收这些对象。`
* `这样一来，内存占用会不断增加，最终导致 Node.js 进程崩溃或者运行缓慢。`
---
* `因此，为了避免内存泄漏和 GC 问题，你需要合理设置 --max-old-space-size 参数，并且尽可能减少不必要的对象创建和引用。`

#### 新生代对象和老生代对象
* V8 引擎中将对象分为新生代对象和老生代对象两种类型，这两种类型的对象在 GC（垃圾回收）过程中会有不同的处理方式。
1. `新生代对象是指存活时间较短的对象，通常是在堆上分配的小对象。`
* 在 V8 引擎中，新生代对象被分配在一块称为“新生代空间”的内存区域中。新生代空间被分为两个区域，分别为 From 空间和 To 空间。
* `当一个新生代对象被分配时，它会被放入 From 空间中。`. `当 From 空间被填满时，V8 引擎会执行一次 Scavenge GC，将仍然存活的对象复制到 To 空间中，同时清空 From 空间。`
* `如果一个新生代对象经过多次 Scavenge GC 仍然存活，它会被认为是老生代对象，然后被移动到老生代空间中。所以老生代对象就是从新生代对象转换为来的`
2. `老生代对象是指存活时间较长的对象，通常是较大的对象。在 V8 引擎中，老生代对象被分配在一块称为“老生代空间”的内存区域中。`
* 老生代空间通常比新生代空间更大，也更容易发生内存碎片。为了处理老生代空间中的内存碎片，V8 引擎会定期执行一次 Mark-Sweep GC 或者 Mark-Compact GC。
* `Mark-Sweep GC 会标记所有存活的对象，并清除未标记的对象，这样会留下一些不连续的内存碎片。`
* `Mark-Compact GC 会将所有存活的对象移动到内存区域的一端，然后清除不再使用的内存区域，从而避免了内存碎片的问题。`
---
* 因此，V8 引擎中老生代对象和新生代对象的 GC 过程是不同的。新生代对象主要通过 Scavenge GC 进行垃圾回收，而老生代对象则需要执行 Mark-Sweep GC 或者 Mark-Compact GC 来回收垃圾。
* `由于新生代对象存活时间较短，因此它们的 GC 过程相对简单，同时新生代空间的大小也较小。老生代对象存活时间较长，因此它们的 GC 过程相对复杂，同时老生代空间的大小也较大。`
---
* `所以我们的node程序内存不足，一般通过调整老生代对象的最大值，就好了，因为新生代对象本来占用的空间就不大，如果存活的gc次数多了，很快就会转换为老生代对象的！`

### 当 V8 的新生代对象需要转移到老生代对象时，会执行以下步骤
* 首先，新生代对象会被复制到老生代对象区域。这个过程被称为晋升（promotion）。晋升通常发生在新生代对象已经经历了一定数量的垃圾回收循环后，仍然存活下来。
* 在晋升的过程中，V8 将新生代对象从新生代对象区域复制到老生代对象区域。这个过程被称为膨胀（tenuring）。V8 使用了一个称为“Survival Counters”的机制来跟踪对象的生命周期。如果一个对象经历了一定数量的垃圾回收循环后仍然存活下来，那么它的生存计数器就会被增加。当生存计数器达到一定的阈值时，对象就会被晋升到老生代对象区域。
* 在晋升的过程中，V8 还会对对象进行优化。例如，它会将对象的属性存储在固定的位置，以提高访问速度。
* 最后，新生代对象区域会被清空。这个过程被称为垃圾回收（garbage collection）。在垃圾回收的过程中，V8 会扫描新生代对象区域，找到不再使用的对象，并将它们释放掉。

* 需要注意的是，晋升是一个相对较为昂贵的操作，因为它涉及到对象的复制和优化。因此，V8 将尽可能地延迟晋升的时间，以减少晋升的频率和开销。此外，如果晋升的对象比较大，V8 也会尝试使用增量标记（incremental marking）等技术来减少晋升的影响。
