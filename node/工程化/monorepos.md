## Monorepo 演进
1. 阶段一：单仓库巨石应用， 一个 Git 仓库维护着项目代码.随着迭代业务复杂度的提升，项目代码会变得越来越多，越来越复杂，大量代码构建效率也会降低，最终导致了单体巨石应用
2. 阶段二：`多仓库多模块`应用，于是将项目拆解成多个业务模块，并在多个 Git 仓库管理，模块解耦，降低了巨石应用的复杂度.
* 每个模块都可以独立编码、测试、发版，代码管理变得简化，构建效率也得以提升，这种代码管理方式称之为 MultiRepo。
3. 阶段三：`单仓库多模块`应用，随着业务复杂度的提升，模块仓库越来越多，MultiRepo这种方式虽然从业务上解耦了，
* 但增加了项目工程管理的难度，随着模块仓库达到一定数量级.
* 会有几个问题：跨仓库代码难共享；分散在单仓库的模块依赖管理复杂
* （底层模块升级后，其他上层依赖需要及时更新，否则有问题）； 增加了构建耗时。
* 于是将`多个项目集成到一个仓库下`，`共享工程配置`，同时又快捷地共享模块代码，成为趋势，
* 这种代码管理方式称之为 `MonoRepo`。

### MultiRepo
1. 代码可见性：
   ✅ `代码隔离`，研发者只需关注自己负责的仓库
   ❌ 包管理按照各自owner划分，当出现问题时，需要到依赖包中进行判断并解决。
2. 依赖管理
   ❌ 多个仓库都有自己的 node_modules，存在依赖重复安装情况，占用磁盘内存大。
3. 代码权限
   ✅ 各项目单独仓库，不会出现代码被误改的情况，单个项目出现问题不会影响其他项目。
4. 开发迭代
   ✅ 仓库体积小，模块划分清晰，可维护性强。
   ❌ 多仓库来回切换（编辑器及命令行），项目多的话效率很低。多仓库之间存在依赖时，需要手动 npm link，操作繁琐。
   ❌ 依赖管理不便，多个依赖可能在多个仓库中存在不同版本，重复安装，npm link 时不同项目的依赖会存在冲突。
5. 工程配置
   ❌ 各项目构建、打包、代码校验都各自维护，不一致时会导致代码差异或构建差异。
6. 构建部署
   ❌ 多个项目间存在依赖，部署时需要手动到不同的仓库根据先后顺序去修改版本及进行部署，操作繁琐效率低。

#### MonoRepo场景
综合如上 Monorepo VS MultiRepo，`中大型项目，多模块项目`，更适合用 MonoRepo 方式管理代码，
在开发、协作效率、代码一致性方面都能受益。


#### lerna
* Lerna 是一个快速、现代的构建系统，
* 用于`管理和发布`来自`同一存储库的``多个 JavaScript/TypeScript 包`

#### nx
* https://github.com/nrwl/nx
* Nx 是一个具有内置工具和高级 CI 功能的构建系统。它可以帮助您在本地和 CI 上维护和扩展 monorepos。

* `npx nx@latest init 在项目中集成nx`

* 然后我们可以创建文件夹packages
* `package.json添加 "workspaces": ["packages/*"] 设置工作目录,我们可以在本地链接他们`
* 在文件夹packages下面添加多个子项目


