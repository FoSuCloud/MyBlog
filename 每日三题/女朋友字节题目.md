## node
1. 核心API(不需要require就可以使用)，内置api需要使用require才能引进来,第三方api需要先npm i下载再通过require引入
2. 文件同步读取和异步读取
```js
const fs= require('fs')
// 异步
fs.readFile('text.js',(err,data)=>{
    console.log(data.toString())
})

// 同步
const res = fs.readFileSync('text.js')
console.log(res.toString())

```
3. promisify把readFile转换为promise风格的写法
```js
(async ()=>{
    const fs= require('fs')
    const {promisify} = require('util')
    const readFile = promisify(fs.readFile)
    const data = await readFile('./text.js')
    console.log(data.toString())
})()
```
4. buffer处理二进制
```js
// Buffer.alloc:分配 size 个字节的创建一个新的 Buffer
const buf1= Buffer.alloc(10)
console.log(buf1)
//<Buffer 00 00 00 00 00 00 00 00 00 00>
// Buffer.from: 将传入的 buffer 数据复制到新的 Buffer 实例上。
const buf2=Buffer.from('a')
console.log('buf2',buf2) //  <Buffer 61>
const buf3=Buffer.from('中')
console.log('buf3',buf3) // <Buffer e4 b8 ad>
// Buffer.concat把buffer数组组合在一起
const buf4=Buffer.concat([buf2,buf3])
console.log('buf4',buf4) //  <Buffer 61 e4 b8 ad>
```
5. 创建一个http服务器
```js
const http=require('http')
http.createServer((req,res)=>{
    res.end('hello')
}).listen('3000',()=>{
    console.log('start listen')
})

// 使用end不好是因为啥？语义化?不是，
```

6. 原型链
```js
function getProtoChain(obj){
    let result=[]
    let tmp = obj;
    while(tmp = Object.getPrototypeOf(tmp)){
        result.push(tmp)
    }
    return result
}
const a= new Array(111)

console.log(getProtoChain(a))
```

7. 创建服务器
```js

const http=require('http')
const fs = require('fs')
http.createServer((req,res)=>{
    let {url,method} = req
    if(url==='/' && method==='GET'){
        fs.readFile('index.html',(err,data)=>{
            if(err){
                res.writeHead(500,{
                    'Content-Type':'text/plain;charset=utf8'
                })
                res.end('500 错误')
                return;
            }
            res.statusCode = 200;
            res.setHeader('Content-Type','text/html;charset=utf8')
            res.end(data)
        })
    }else{
        res.statusCode = 404;
        res.setHeader('Content-Type','text/plain;charset=utf8')
    }
}).listen('3000',()=>{
    console.log('start listen')
})
```

8. accept字段不可以作为判断
```js
 // headers.accept.indexOf('image/*')!==-1
// 可以伪造请求头
// 最重要的是需要先读取，然后再发出去(缓冲区)，内存占用太大！

// 使用readFile读取，会占用内存，如果是同步更是会导致阻塞
// 最好就是使用stream流去读取文件
```
