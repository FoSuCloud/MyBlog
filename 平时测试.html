<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8" />
</head>
<script>
  class ProxySandbox {
    active() {
      // 沙箱开启
      this.sandboxRunning = true;
    }
    inactive() {
      this.sandboxRunning = false;
    }
    constructor() {
      const rawWindow = window;
      const fakeWindow = {};
      // 代理 fakeWindow
      const proxy = new Proxy(fakeWindow, {
        set: (target, prop, value) => {
          // 只有沙箱开启的时候才操作 fakeWindow
          if (this.sandboxRunning) {
            // 对 window 的赋值，操作与 fakeWindow
            target[prop] = value;
            return true;
          }
        },
        get: (target, prop) => {
          // 先查找 fakeWindow，找不到再寻找 rawWindow
          console.log('target:',target); // 打印这里
          let value = prop in target ? target[prop] : rawWindow[prop];
          return value;
        },
      });
      this.proxy = proxy;
    }
  }
  const windowProxy = new ProxySandbox()
  windowProxy.active();
  with(windowProxy.proxy) {
    debugger;
    console.log(windowProxy);
    const undefined = windowProxy.proxy.undefined;
    const Array = windowProxy.proxy.Array; // 该语句内的Array指向windowProxy.proxy
    // 应用代码，通过 with 确保所有的全局变量的操作实际都是在操作 qiankun 提供的代理对象
    console.log(Array.isArray([1]))
  }
</script>
<body>
</body>
</html>
