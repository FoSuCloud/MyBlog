## CIA三元组
1. 机密性`Confidentiality`
2. 完整性`Integrity`
3. 可用性`Availability`

## xss
* XSS(Cross-site Scripting，跨站脚本攻击)，就是黑客在浏览器中插入一段恶意的js脚本，窃取信息，冒充身份进行操作
* 因为浏览器是没办法区别脚本是恶意注入的还是开发者写入的，所以都会执行。并且html很灵活，可以在任何时候对他进行修改

## xss的类型
1. 反射型(非持久型)
2. 基于DOM的XSS
3. 存储型XSS(持久型XSS)

## 实现原理
1. 反射型XSS：就是恶意的脚本是用户发送给网站请求中的一部分，然后网站把这部分返回给用户
* 恶意的脚本在页面中被执行。`一般发生在前后端不分离的项目中，不分离，所以服务器端的逻辑会改变最终的网页代码`
2. 基于DOM的XSS:`由于现在很流行前后端分离的项目，所以反射性XSS用的比较少了`
* `而基于DOM型的XSS是在浏览器端进行恶意脚本的取出和执行的，不需要经过服务器`
3. 存储型XSS：`存储型XSS是黑客把恶意的脚本长期保存在服务器数据库中，用户一旦访问该页面的数据，脚本就会执行`
* `一般出现在微博，贴吧中`
* 区别:
* `1. 反射型的xss恶意脚本是存在于请求的url中，而存储型的xss恶意脚本存在数据库中`
* `2. 基于dom的xss是属于前端的安全漏洞，而反射型和存储型的攻击方式属于服务器端的安全漏洞`
* `3. 反射型和基于dom型的xss都是黑客诱导用户去点击url,然后才给黑客可乘之机；而存储型是黑客主动向服务器提交恶意脚本`

## xss攻击可以做什么
1. 盗取用户cookie
2. 未授权操作
3. 修改dom
4. 刷弹窗广告
5. 发动蠕虫攻击
6. 劫持用户行为，进一步渗透内网

## 前端如何防备xss攻击
1. 输入防范:`在提交表单时，前端要把文本内容转换为实体编码，也就是过滤掉script,a这些标签，然后再提交`
2. 输出防范:`在显示文本内容时，最好也要做一次html实体编码转换后再显示，防止script恶意脚本执行`
* [参考](https://www.jianshu.com/p/e554b5a5c304)
3. `设置cookie:httpOnly,只能通过http请求发送cookie,不能通过js脚本代码获取cookie`
4. `在cookie的secure字段设置true，表示只能通过https请求来发送该cookie`

## 防备xss攻击(网页安全策略:白名单)
* `浏览器默认会执行所有脚本，但是安全性堪忧，很容易被xss攻击，所以从根本上解决问题:告诉浏览器哪里的脚本才可以执行！`
* CSP(content-security-policy)的实质就是白名单制度，开发者明确告诉浏览器哪些资源可以加载与执行
* CSP大大增强了网页的安全性，即使攻击者发现了漏洞也无法注入脚本，除非控制了白名单中的主机！
* 启用白名单CSP的方式有两种:
1. `通过http请求头中的Content-Security-Policy得字段来设置`
2. `通过网页的meta标签来设置，首先设置http-equiv为Content-Security-Policy,然后在content属性设置具体内容`
---
* `script-src用于设置受信任的脚本，'self'表示本地域名，'unsafe-eval'表示将字符串当做代码执行，如eval,setTimeout,setInterval;'unsafe-inline'表示可以执行页面内嵌的script标签和函数`
* `object-src表示不信任任何url,也就是不加载任何资源`
* `style-src表示信任的样式表`
* `child-src表示信任的框架frame，如果是https则表示必须使用https协议加载`
---
* `一个白名单必须有script-src和object-src，除非设置了default-src,default-src表示默认的设置`
* `此外，script-src一般需要设置unsafe-eval和unsafe-inline,因为开发者肯定也使用了内嵌的script和某些字符串函数`
*     <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' 'unsafe-eval'; object-src 'none'">

## CSRF攻击
* CSRF(Cross-site request forgery`跨站请求伪造`)
* CSRF攻击就是黑客引诱用户`打开黑客的网站`，利用用户的`登录状态`发起跨站请求
* `相对来说，CSRF跨站请求伪造就是降维打击，黑客利用用户这个受害者，用户进入黑客的网站后`
* `黑客利用用户这个受害者在想要攻击的网站中的登陆状态，轻松冒充用户绕过网站的用户校验，达成冒充用户的目的`
---
* `cookie的same-site字段规定cookie不能被跨域请求发送`

## CSRF请求实现
1. 想要实现该请求很简单，就是诱导或者说欺骗用户
2. `引诱用户点击a标签，通过href属性发起CSRF`
3. `引诱用户点击某个地方，然后这个地点其实是隐藏的表单提交按钮`
4. `最容易的就是利用img的src属性来进行自动请求`

## CSRF和XSS的区别
1. `CSRF不需要将恶意代码注入用户页面，仅仅是利用用户的登陆状态来攻击，而XSS需要在用户的页面注入恶意代码`
2. `CSRF的攻击成本比XSS还要低，因为用户每天都要访问大量的网页，没法确定网页合法性`

## DNS劫持与DNS污染
1. DNS劫持:DNS劫持就是通过劫持了DNS服务器，通过某些手段获取域名的`解析记录控制权！`
* `因为有解析记录控制权，所以就可以修改域名的解析结果，导致域名原来指向a ip，现在指向b ip;`
* `DNS劫持就是通过篡改DNS服务器上的数据返回一个错误的查询结果来实现的`
2. DNS污染:`一般都是翻墙才会出现的，就是用户访问一个网址时，国内的服务器监控到用户访问的已经被标识的地址时，`
3. `服务器伪装成DNS服务器返回一个错误的查询结果给用户，例如youtube,facebook`

## SQL注入攻击
* SQL注入攻击有两个关键条件:1. 用户能够控制输入 2. 原本程序要执行的代码，拼接了用户的输入的数据
* 防御手段
1.1 使用预编译语句，这是防止SQL注入最有效的方法，可以完全避免程序代码拼接带来的风险(这也是我们不使用eval()的原因)
1.2 关闭web服务器的错误回显功能，避免`便利了黑客改正错误的方便性`

## SSH,SSL
1. 都是属于应用层协议
2. 都是用了非对称加密
---
1. `SSH不需要证书，SSL需要证书`
