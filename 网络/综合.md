## 跨域
* 要理解跨域，先要了解一下“同源策略”。所谓同源是指，`域名，协议，端口`相同
* `在同源策略下，在某个服务器下的页面是无法获取到该服务器以外的数据的`。例如我们在自己的网站通过ajax去获取豆瓣上的接口数据，但是会报错，因为域名不一致
* `但<img>的src（获取图片），<link>的href（获取css），<script>的src（获取javascript）这三个都不符合同源策略，但它们可以跨域获取数据,不受同源策略的约束,所以我们平时才不会察觉到同源策略的约束`
* 但是我们在实际开发中，有时候需要直接通过get,post请求来获取服务器接口数据，那就不可避免会碰到跨域问题了，
* 例如我们需要在js中使用this.$axios.get('http://www.baidu.com').then()获取接口数据，
* 然后再绑定到元素中，这时候使用jsonp这种避开跨域的方式就不管用了，我用过的解决方法是在自己的服务器端设置允许跨域访问的HTTP头部，也就是使用CORS解决跨域方案

## javascript中实现跨域的方式总结
1. 第一种方式：jsonp请求；jsonp的原理是利用`<script>`标签的跨域特性，可以不受限制地从其他域中加载资源，类似的标签还有`<img>`
2. 第二种方式：`document.domain`这种方式用在`主域名相同子域名不同`的跨域访问中
* 主域名:`有两个或以上的字母组成，中间有点号隔开，但是只有一个1点号，如 badu,net`;子域名:`主域名之下的子域名，会有多个点号 blog.badu.net`
3. 第三种方式：window.name(通过这个传递数据)；window的name属性有个特征：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。
4. 第四种方式：window.postMessage；window.postMessages是html5中实现跨域访问的一种新方式，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。
5. 第五种方式：CORS(cross origin resource sharing)跨域资源共享；CORS背后的基本思想，就是使用`自定义的HTTP头部`让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。
* [CORS](http://www.ruanyifeng.com/blog/2016/04/cors.html)
6. 第六种方式：Web Sockets`就是让服务器主动推送给客户端的技术`；web sockets原理：在JS创建了`web socket`之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为`web sockt协议`。websoket是基于tcp协议的

## CORS实现跨域只需要服务器进行设置，与前端无关
* 目前几乎所有浏览器都支持CORS,除了ie10以下，所以只要服务器设置了，前端就不需要做其他改动
* CORS分为简单请求和预检请求两种:
```
以下条件都要满足才是简单请求:
1. 请求方法为get/post/head
2. content-type为text/plain,application/x-www-form-urlencoded,mutipart/form-data
```
* `对于简单请求，浏览器会自动加上origin字段，然后发送到服务器，如果服务器设置的Access-Control-Allow-Origin包含这个域名，那就会成功返回`
---
* 预检请求也可以说是不简单请求
```
满足以下条件任意一个就可以了
1. 请求方法是 put/delete/connet/options/trance/patch
2. content-type不属于这些；text/plain,multipart/form-data,application/x-www-form-urlencoded
```
* 当发生非简单请求时，浏览器会先发送一个options请求，如果该服务器支持该请求就会将真正的请求发送给后端，否则会抛出错误
* `服务是否支持该请求根据以下字段判断`
* Access-Control-Allow-Methods:支持的请求方法
* Access-Control-Allow-Headers:支持的请求头信息
* Access-Control-Max-Age:本次预检请求的有效期

* 例如我们在网站a调用 fetch('https://baidu.com')
* 会报错：`Access to fetch at 'https://baidu.com/' from origin 'https://fed.chanceyu.com' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.`
* 但是 fetch('https://mcs.volceapplog.com/list')
* 没有报错，大概就是因为这个网站服务端做了CORS

## document.domain只能用于在主域名相同，子域名不同的情况下
1. 以`id.qq.com,qq.com为例，在qq.com中1设置document.domian会报错，提示id.qq.com不是qq.com的后缀suffix`
2. `在1id.qq.com页面中打开开发者模式，输入`
```
1. 输入var w=window.open('qq.com');
2. 虽然肯定会打开页面，但是再输入 w,会发现报错，提示跨域了
---
3. 解决方法就是设置document.domain
4. 首先输入document.domain,看到目前的1document.domain是id.qq.com
5. 再输入 document.domain='qq.com'
6. 此时的document.domian就是qq.com了，然后再次w=window.open('qq.com');
7. 最后输入w.document,就可以看到取得了qq.com页面的代码了！
```
* [参考](https://blog.csdn.net/nlznlz/article/details/79506655)

## window.name的跨域比较麻烦，需要前后端协作[参考](https://www.jianshu.com/p/835bc9534281)

## websocket
* `websocket是一种通信协议，和http协议不一样`
* `http协议只能实现客户端向服务器发起请求，服务器响应。虽然http2.0支持服务器主动推送数据给客户端了`
* `而websocket通信协议是全双工通信，浏览器和服务器只需要一次握手就能建立持久的连接，进行双向的数据传输，服务器也可以主动推送数据给客户端`
* 其余特点:
```
1. 握手阶段采用http协议
2. 没有同源限制！！！
3. 更好的二进制支持，可以发送文本和二进制数据
```
* `使用websokect需要在请求中加入字段Upgraded:websokect,Upgraded字段表示要求服务器升级协议到websokect`

## 为什么很多站点第二次打开速度很快?
* `因为DNS缓存和页面资源缓存`
* 页面资源缓存:在服务器返回HTTP响应头给浏览器的时候，浏览器是通过响应头中的`Cache-Control字段来设置是否缓存该资源的`,通常来说，我们会为这个资源设置一个缓存时长，而这个时长是通过`Cache-Control中的Max-age参数来设置的`
* 例如:`Cache-Control:Max-age=2000`；而`Cache-Control:Max-age=0`则是每次都强制刷新，不要校验是否有缓存
* 这就意味着，在该缓存资源还未过期的情况下，如果再次请求该资源，会直接返回缓存中的资源给浏览器；如果缓存过期了，浏览器会继续发起网络请求，并且在HTTP请求头上带上`If-None-Match字段`
* 在服务器收到请求头之后，会根据`If-None-Match`来判断请求的资源是否有更新
* 如果没有更新，那么会返回`304状态码，告诉客户端，这个缓存可以继续使用，因为没有更新，所以这次就不发送数据给你了`
* 如果有更新，那么就会发送新的数据给客户端

## 用户登录状态是怎么保持的?
1. 用户打开登录页面，在登录框里填入用户名和密码，然后点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用post方法提交用户登录信息给服务器
2. 服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话会生成一段表示用户身份的字符串，并把字符串写到响应头的set-cookie字段里
* 如下所示，然后把响应头发送到浏览器
* `Set-Cookie:UID=3431uad`
3. 浏览器在接收到服务器的响应头之后，开始解析响应头，如果遇到响应头中有`Set-Cookie`字段，那么浏览器会把这个字段保存到本地，例如`UID=3241uad`保存到本地
4. 当用户再次访问该站点的页面，浏览器会发起http请求，但是在发起http请求之前，浏览器会读取之前保存的cookie数据，并把数据写进请求头里的cookie字段里，然后浏览器再把请求头发给服务器
* `Cookie:UID=3424uad`
5. 服务器在收到HTTP请求头数据之后，会查找请求头里的Cookie字段信息，当查找到UID=314uad的信息时，服务器查询后台，并判断用户是否是已登录状态，然后生成包含该用户信息的页面数据，把数据发送给浏览器
6. 浏览器在接收到含有该用户信息的数据之后，就可以显示该用户登录时的页面了

## 强缓存和协商缓存
1. 强缓存就是强制缓存，当浏览器去请求文件的时候，服务器会在响应头上进行缓存配置，缓存的事件和类型都由服务器控制
* `表现为cache-control,一般设置为max-age,public,no-cache,private,no-store`
* `max-age设置的值是秒数，public表示可以被浏览器和代理服务器缓存`
* `如果设置了max-age不为0，那么正常的页面请求时都会判断时候超过max-age时间，不超过就不需要去请求了`
* `但是如果按下f5或者左上角的刷新，那么就要进行重新请求了！`
* `no-cache表示不设置强缓存`
* `no-store表示客户端和服务器端都不缓存，也就是强缓存和协商缓存都失效！`
2. 协商缓存就是需要客户端和服务器端进行交互的！
* 设置协商缓存就是在响应头字段中设置`etag,last-modified`
* `etag:每个文件都有一个标识，也就是文件的哈希值`
* `last-modifed:表示文件的最后一次修改时间`
* 在接收到响应头该字段后，就会存起来，下次继续请求该页面就会带上这两个字段在`请求头`！
* `最后对该页面在进行请求的时候，发送请求头，服务器比较这两个字段，判断该文件时候有修改`

## 输入URL后发生了什么？
1. 首先去查找DNS缓存，如果存在就直接用缓存中的ip地址，如果不存在就执行DNS域名解析
2. 获取到ip地址后，就可以尝试进行TCP连接了，但是如果同一个域名下有多个TCP连接正在进行，那么需要排队
例如谷歌就是6个，排队结束了，TCP连接就可以通过端口号和序列号进行三握手了
3. TCP连接进行三握手
三握手就是:首先客户端发送一次报文，服务器接收到表示服务器能够接受数据；
第二次握手:服务器接受到了之后，再发送一次给客户端，客户端接受到了表示客户端能够接收数据并且发送数据；
第三次握手:服务器接收到之后，服务器就知道自己也可以发送数据成功
4. 三握手之后就可以通过TCP/IP协议进行连接了
5. 如果是get请求，那么就直接发送请求数据；如果是post请求，那么就先发送请求头，如果服务器返回100状态码再继续发送请求体
6. 服务器接收到请求数据，返回相应的文件
7. 客户端接收到200状态码或304状态码就表示接收成功了，然后就进行四挥手断开连接，因为http请求是无连接的，获取到相应数据就会断开连接
8. 首先会构建DOM树，同时构建css规则树；等DOM树和CSS规则树都好了就可以构建渲染树了
9. 构建完渲染树就可以通过渲染树来渲染页面，构建页面，最终呈现在眼前


## http是应用层协议，udp是传输层协议，ip是网络层的协议，都是无连接协议

## OSI网络协议体系
1. 七层`应用层 表示层 会话层 传输层 网络层 数据链路层 物理层`
1. 七层`应用层(HTTP) 表示层 会话层 传输层(TCP,UDP) 网络层(IP协议 路由器) 数据链路层(网卡 MAC地址 ARP解析协议) 物理层`

## 各个层的协议
1. 数据链路层：`处理与电缆或者其它传输媒介的 物理 接口`
* `MAC协议，ARP地址解析协议，RARP逆地址解析协议`
2. 网络层:`处理分组在网络中的活动，如网络选组`
* `IP协议，ICMP协议，IGMP协议`
3. 传输层:`为两台主机上的应用程序提供端到端通信`
* `UDP协议，TCP协议`
4. 应用层:`http协议，FTP文件传输协议，SMTP简单邮件传送协议，SNMP简单网络管理协议，Telnet远程登录协议`

## 各个层的物理设备
1. 物理层:`中继器，集线器，调试器`
2. 数据链路层:`二层交换机，网桥，网卡`
3. 网络层:`路由器`

## 打电话是电路交换，上网是分组交换
## ISP(Internet Service Provider因特网服务提供商)

## 动态主机设置协议DHCP(Dynamic Host Configuration Protocol)
* 这是一个局域网的网络协议，使用UDP协议工作
* 作用：`1. 用于内部网络或者网络服务供应商自动分配ip地址`
* `2. 给用户用于内部网管理员作为一个对计算机管理的手段`
* `3.默认网关`
* `4. 存放DNS服务器的IP地址，可以为客户机分配Ip地址`

## 虚拟网络
1. 虚拟局域网建立在局域网交换技术基础上
2. 虚拟局域网可以将局域网上的节点划分为若干个“逻辑工作组，一个逻辑工作组就是一个虚拟网络
3. `逻辑工作组的节点组成不受物理位置的限制`

## 决定局域网特性的技术要素:传输介质，网络拓扑结构，介质访问控制方法(最重要)
## 以太网卡工作模式:混杂模式，直接模式，多播模式，广播模式
## 按照网络范围划分:局域网<城域网<广域网(万维网是最大的广域网)

## 传输速率/带宽/吞吐量
1. 传输速率:`表示两个设备之间数据流动的物理速度`，单位是bps
2. 带宽:`也就是单位时间内，从某处传输到另一处的最大数据量！相当于最大速率`，单位也是bps
3. 吞吐量:`吞吐量属于主机之间实际的传输速率，也就是单位时间内某个信道或者端口实际的数据量！`
4. 举个例子:在日常生活中，一般都号称100M带宽，但是实际下载速度却绝对没有那么多
5. 这是因为运营商ISP提供的衡量单位是bit,`1Mb/s=1000Kb/s=1000/8KB/s=125KB/s`
6. 此外，也会因为网络延迟，信号灯问题导致网络实际传输速率很低
