## 跨域
* 要理解跨域，先要了解一下“同源策略”。所谓同源是指，`域名，协议，端口`相同
* `在同源策略下，在某个服务器下的页面是无法获取到该服务器以外的数据的`。例如我们在自己的网站通过ajax去获取豆瓣上的接口数据，但是会报错，因为域名不一致
* `但<img>的src（获取图片），<link>的href（获取css），<script>的src（获取javascript）这三个都不符合同源策略，但它们可以跨域获取数据,不受同源策略的约束,所以我们平时才不会察觉到同源策略的约束`
* 但是我们在实际开发中，有时候需要直接通过get,post请求来获取服务器接口数据，那就不可避免会碰到跨域问题了，例如我们需要在js中使用this.$axios.get('http://www.baidu.com').then()获取接口数据，然后再绑定到元素中，这时候使用jsonp这种避开跨域的方式就不管用了，我用过的解决方法是在自己的服务器端设置允许跨域访问的HTTP头部，也就是使用CORS解决跨域方案

## javascript中实现跨域的方式总结
1. 第一种方式：jsonp请求；jsonp的原理是利用`<script>`标签的跨域特性，可以不受限制地从其他域中加载资源，类似的标签还有`<img>`
2. 第二种方式：`document.domain`这种方式用在`主域名相同子域名不同`的跨域访问中
* 主域名:`有两个或以上的字母组成，中间有点号隔开，但是只有一个1点号，如 badu,net`;子域名:`主域名之下的子域名，会有多个点号 blog.badu.net`
3. 第三种方式：window.name；window的name属性有个特征：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。
4. 第四种方式：window.postMessage；window.postMessages是html5中实现跨域访问的一种新方式，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。
5. 第五种方式：CORS(cross origin resource sharing)跨域资源共享；CORS背后的基本思想，就是使用`自定义的HTTP头部`让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。
* [CORS](http://www.ruanyifeng.com/blog/2016/04/cors.html)
6. 第六种方式：Web Sockets；web sockets原理：在JS创建了`web socket`之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为`web sockt协议`。websoket是基于tcp协议的

## 为什么很多站点第二次打开速度很快?
* `因为DNS缓存和页面资源缓存`
* 页面资源缓存:在服务器返回HTTP响应头给浏览器的时候，浏览器是通过响应头中的`Cache-Control字段来设置是否缓存该资源的`,通常来说，我们会为这个资源设置一个缓存时长，而这个时长是通过`Cache-Control中的Max-age参数来设置的`
* 例如:`Cache-Control:Max-age=2000`；而`Cache-Control:Max-age=0`则是每次都强制刷新，不要校验是否有缓存
* 这就意味着，在该缓存资源还未过期的情况下，如果再次请求该资源，会直接返回缓存中的资源给浏览器；如果缓存过期了，浏览器会继续发起网络请求，并且在HTTP请求头上带上`If-None-Match字段`
* 在服务器收到请求头之后，会根据`If-None-Match`来判断请求的资源是否有更新
* 如果没有更新，那么会返回`304状态码，告诉客户端，这个缓存可以继续使用，因为没有更新，所以这次就不发送数据给你了`
* 如果有更新，那么就会发送新的数据给客户端

## 用户登录状态是怎么保持的?
1. 用户打开登录页面，在登录框里填入用户名和密码，然后点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用post方法提交用户登录信息给服务器
2. 服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话会生成一段表示用户身份的字符串，并把字符串写到响应头的set-cookie字段里
* 如下所示，然后把响应头发送到浏览器
* `Set-Cookie:UID=3431uad`
3. 浏览器在接收到服务器的响应头之后，开始解析响应头，如果遇到响应头中有`Set-Cookie`字段，那么浏览器会把这个字段保存到本地，例如`UID=3241uad`保存到本地
4. 当用户再次访问该站点的页面，浏览器会发起http请求，但是在发起http请求之前，浏览器会读取之前保存的cookie数据，并把数据写进请求头里的cookie字段里，然后浏览器再把请求头发给服务器
* `Cookie:UID=3424uad`
5. 服务器在收到HTTP请求头数据之后，会查找请求头里的Cookie字段信息，当查找到UID=314uad的信息时，服务器查询后台，并判断用户是否是已登录状态，然后生成包含该用户信息的页面数据，把数据发送给浏览器
6. 浏览器在接收到含有该用户信息的数据之后，就可以显示该用户登录时的页面了

## 输入URL后发生了什么？
1. 首先去查找DNS缓存，如果存在就直接用缓存中的ip地址，如果不存在就执行DNS域名解析
2. 获取到ip地址后，就可以尝试进行TCP连接了，但是如果同一个域名下有多个TCP连接正在进行，那么需要排队
例如谷歌就是6个，排队结束了，TCP连接就可以通过端口号和序列号进行三握手了
3. TCP连接进行三握手
三握手就是:首先客户端发送一次报文，服务器接收到表示服务器能够接受数据；
第二次握手:服务器接受到了之后，再发送一次给客户端，客户端接受到了表示客户端能够接收数据并且发送数据；
第三次握手:服务器接收到之后，服务器就知道自己也可以发送数据成功
4. 三握手之后就可以通过TCP/IP协议进行连接了
5. 如果是get请求，那么就直接发送请求数据；如果是post请求，那么就先发送请求头，如果服务器返回100状态码再继续发送请求体
6. 服务器接收到请求数据，返回相应的文件
7. 客户端接收到200状态码或304状态码就表示接收成功了，然后就进行四挥手断开连接，因为http请求是无连接的，获取到相应数据就会断开连接
8. 首先会构建DOM树，同时构建css规则树；等DOM树和CSS规则树都好了就可以构建渲染树了
9. 构建完渲染树就可以通过渲染树来渲染页面，构建页面，最终呈现在眼前


## http是应用层协议，udp是传输层协议，ip是网络层的协议，都是无连接协议

## OSI网络协议体系
1. 七层`应用层 表示层 会话层 传输层 网络层 数据链路层 物理层`
1. 七层`应用层(HTTP) 表示层 会话层 传输层(TCP,UDP) 网络层(IP协议 路由器) 数据链路层(网卡 MAC地址 ARP解析协议) 物理层`
