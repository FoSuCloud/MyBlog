## sourcemap
* `在webpack.config.js 设置 devtool: 'source-map' 开启`

- [参考]("https://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html")
- `sourcemap就是一个独立的map文件，和源码在同一个目录`

### 背景

- 首先从源码转换说起：
- 现在的 js 变得越来越复杂，`项目代码都要经过转换才能投入生产环境中`
- 常见的源码转换方式有以下几种：

1. `压缩，减少体积`
2. `多文件合并，减少请求数`
3. `把其他语言编译为js`

- `不管是哪种转换，都不利于debug。`
- 通常，我们在浏览器的 source 界面可以看到是第几行代码出错了，但是都被转换为单调的 a,b,c 等单词
- 所有的变量都改了名字。`也就是看着生产环境的代码没有debug的线索，不知道是哪一行出错`
- `而sourcemap就是为了解决不知道哪里的代码出错而出现的`

### 什么是 sourcemap

- sourcemap 就是一个信息文件，里面存储着我们代码的信息。`也就是转换后的代码的每一个位置，对应着转换前的哪一个位置`
- `开启了sourcemap,我们就可以在浏览器的source界面看到原始的代码，而不只是转换后的代码`

### sourcemap 的格式

- sourcemap 文件显示是这样的，例子：
* `可以去看rollup demo 生成的map文件`

```json
{
  "version": 3,
  "file": "out.js",
  "sourceRoot": "",
  "sources": ["foo.js", "bar.js"],
  "names": ["src", "maps", "are", "fun"],
  "mappings": "AAgBC,SAAQ,CAAEA"
}
```
* 整个map文件相当于一个json对象，可以被解释器读取，然后解析为对应的文件位置
* version:sourcemap版本
* file: 转换后的文件名
* sourceRoot：转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。`也就是map文件是否和map转换之前的文件在同一个目录`
* sources: `转换前的文件数组，数组也就意味着打包之后的文件可能是来源于多个文件，文件合并产生该文件`
* names: 转换前的所有变量名和属性名
* mappings: `记录位置信息的字符串！`

### mappings属性
* mappings属性其实就是一个字符串，但是很长。
* mappings属性分为三层。
1. 第一层是`行对应，以分号;表示。`,每个分号对应转换后源码的一行。`所以第一个分号前的内容，就对应源码的第一行！`
2. 第二层是`位置对应,以逗号,表示`，每个逗号对应转换后源码的某一个位置。`所以第一个逗号前的内容就表示对应行源码的第一个位置`
3. 第三层是`位置转换，以VLQ编码表示，对应 该位置对应的转换前的源码位置`
* 例子：
`mappings:"AAAAA,BBBBB;CCCCC"`
* 表示转换后的源码分为两行，第一行有两个位置，第二行有一个位置

### 位置对应的原理
* `每个位置使用五位进行表示`
* `注意，不一定需要第五位，如果没有对应的names变量`
* `另外每一位的字符都是可以变长的，也就是可以多个字符表示一位`
1. 第一位：表示`这个位置在转换后的代码第几列`
2. 第二位：表示`这个位置属于sources属性中第几个文件`
3. 第三位：表示`这个位置属于转换前的代码第几行`
4. 第四位：表示`这个位置属于转换前的代码第几列`
5. 第五位：表示`这个位置属于names属性中的第几个变量`
* `另外所有的位置都是使用0零 作为基数的`
* `AAAAA:就表示转换后的代码第0列，对应sources属性的第0个文件，属于转换前的代码第0行，第0列，属于names属性的第0个变量`

### VLQ编码
* VLQ编码的特点就是可以非常精简的表示很大的数值
* VLQ编码是变长的，`如果数值在-15到15之间，使用一个字符表示`
* 超出这个范围，那么使用多个字符表示。`规定，每个字符使用6个二进制位表示`
* `注意，第一个二进制位表示是否连续。如果是1表示这六个数后面的六个数也是同一个数`
*  `如果是0则表示 该字符只由这六位二进制数表示`
---
* `然后6个二进制位的最后一位表示这6个位是否是某个数值的VLQ编码的第一个字符`
* `如果是，那么是0，如果不是则表示1`

## sourcemap实现
* [经典]("https://github.com/mozilla/source-map")
* 使用了wasm这个技术，之后可以看看


#### 浏览器是如何识别并加载 SourceMap 的？
如果我们让构建工具开启了 SourceMap，例如 Webpack 的 devtools，
源码经过构建过程（编译、混淆、压缩等）生成的部署代码会在`最底部增加一行注释`，如下所示：
```javascript
//# sourceMappingURL=app.b0e56bd3.js.map
```
* sourceMappingURL告诉我们，当前资源文件 app.b0e56bd3.js,
* 对应的 SourceMap 文件的路径是 app.b0e56bd3.js.map。
* 这是相对路径的写法，也就是说，在本地启用的服务中，构建后的 chunk 和对应的 SourceMap 文件的地址就是在同一个目录下

* `这样一来，浏览器就可以根据 sourceMappingURL 去自动加载 SourceMap，而不用苦哈哈的手动添加。`

#### 为什么本地可以自动加载而线上不可以？
* 一般来讲，线上产物中会把 SourceMap 去除，除了为了加速构建过程，更重要的是避免有开发经验的人直接在浏览器中「阅读源码」

* 除了直接去除，企业内也常常利用内部的存储能力，将构建好的 SourceMap 资源转存到其他地方，这样一来，
* `构建产物中的 sourceMappingURL 将无法正确指向 SourceMap 的资源地址，从而实现与直接去除接近的效果。`
* `hidden-source-map - 与 source-map 相同，但不向捆绑包添加引用注释。//# sourceMappingURL`
* `如果您只想让 SourceMaps 从错误报告中映射错误堆栈跟踪，但不想为浏览器开发工具公开 SourceMap，则非常有用。`


* 这样一来，在生产环境下 Chrome 根据 sourceMappingURL 相对路径的写法就只能寻址到不存在的 404，浏览器会加载不到需要的资源。
* `掘金的就是这样，可以看到会提示sourcemap 404`

#### 如何感知浏览器确实加载了 SourceMap？
* 打开 Charles 抓一把
* `但是直接在network中是找不到map文件的`
