在使用Monorepo/Submodule的方式时，每个仓库确实可以单独管理自己的代码和版本控制。但是，它们之间的管理方式略有不同。
#### Monorepo
* 当使用Monorepo的方式时，所有的代码都存储在同一个仓库中。每个子项目都可以被单独管理，因为它们都有自己的文件夹，并可以有自己的Git版本控制。但是，它们的提交历史记录、分支、标签等仍然是在同一个仓库中。
#### Git的Submodule
当使用Git的Submodule的方式时，每个子模块都是独立的Git仓库。主Git仓库只是包含一个指向子模块Git仓库的链接，以便将子模块作为子文件夹引用。这种方式允许每个子模块有自己的提交历史、分支、标签等，并且可以在不影响主Git仓库的情况下独立管理自己的版本控制。主Git仓库和子模块之间的关系更像是一种松散的耦合，而不是完全整合在一起的。

### Monorepo/Submodule 的方式都可以让子项目单独发包。

使用 Monorepo 方式，每个子项目都可以单独打包，发布到 npm 上。通过这种方式，可以避免将所有的代码打包在一起发布，而是只发布所需的代码。例如，可以只发布 my-react-library 子项目而不是整个 Monorepo 中的所有子项目。

使用 Git 的 Submodule 方式，每个子模块都是独立的 Git 仓库，可以单独打包并发布到 npm 上。子模块的打包和发布过程与常规的 Git 仓库没有什么区别。主 Git 仓库中只包含子模块的引用，因此不会影响子模块的打包和发布。


### lerna 安装的依赖是可以被项目的子项目共享的。
 Monorepo 中，不同的子项目之间可以共享依赖。Lerna 通过 lerna bootstrap 命令来实现这个功能。它会检查所有子项目的依赖，并且将它们安装到根目录下的 node_modules 目录中，然后在每个子项目中创建符号链接来引用这些依赖。

这样，子项目就可以共享依赖了。当一个子项目需要依赖另一个子项目时，它可以直接引用该项目的模块，而不需要额外安装依赖。同时，它也可以使用在根目录下安装的公共依赖。

需要注意的是，lerna bootstrap 会根据子项目的依赖关系来安装依赖。`如果一个子项目依赖于另一个子项目，并且需要使用该项目的某个模块，那么它必须在该项目之后被安装，以确保正确的依赖关系。`

### 使用 Git Submodule，那么父子仓库都需要独立安装依赖
* Git Submodule 是将一个 Git 仓库作为另一个 Git 仓库的子目录。当父仓库包含子仓库时，每个仓库都有自己的 .git 目录，因此它们需要独立管理自己的依赖。

* 具体来说，当父仓库中包含一个子仓库时，需要在父仓库和子仓库中分别运行 npm install（或者使用其他的包管理工具，如 Yarn）。这意味着在进行开发时，需要分别进入每个仓库来安装和管理依赖。

* 这种方式虽然可以让子项目独立管理自己的依赖，但是在管理和协调多个子项目的依赖时可能会比较复杂。而且当需要更新子仓库中的某个依赖时，需要手动进入子仓库进行更新操作。这可能会导致依赖管理变得混乱和不一致。

### 子项目目录下进行了版本回退
如果你只是在 Monorepo 的子项目目录下进行了版本回退操作，并没有修改其他子项目或者主项目的代码，那么在回退操作完成之后，可以在 Monorepo 的根目录直接进行 git push 操作。这样会将回退操作提交到代码库中，并同步到代码库的远程分支上。

需要注意的是，在进行版本回退操作时，最好先备份一下整个代码库，以防不测。此外，如果在回退之前已经将代码推送到了远程分支上，并且其他开发者也在此分支上进行了修改，那么回退操作可能会引起代码冲突，需要仔细考虑如何解决这些冲突。

### Monorepo这种项目管理方法，在设计上有什么缺陷
1.构建和部署时间变长：由于 Monorepo 中包含多个子项目，因此构建和部署时间可能会比较长。如果每个子项目都需要重新构建和部署，那么整个过程可能会比较耗时。

2.代码库变得更加复杂：在 Monorepo 中，所有的代码都存放在同一个仓库中，这可能会导致代码库变得更加复杂，因为不同的子项目可能会有不同的目录结构和构建方式。这可能会增加开发人员在代码库中进行导航和理解的难度。

3.组织和协调成本增加：在 Monorepo 中，需要对多个子项目进行组织和协调。这可能需要额外的开销来确保所有的子项目都能够协调工作，并且能够正确地共享代码和依赖。

4.依赖管理可能变得困难：由于所有的子项目都在同一个代码库中，因此依赖管理可能会变得比较困难。当一个子项目更新了某个依赖时，需要确保其他子项目也能够顺利地升级到新版本，这可能需要更多的测试和协调工作。

5.版本控制可能变得复杂：在 Monorepo 中，由于所有的代码都在同一个代码库中，因此版本控制可能会变得比较复杂。需要考虑如何管理不同子项目之间的版本，以及如何进行版本回退和分支管理等操作。

* 需要注意的是，这些缺陷并不是 Monorepo 的本质问题，而是由于 Monorepo 的特殊性质导致的。在实践中，可以采取一些策略来缓解这些缺陷，例如优化构建和部署流程、制定统一的目录结构和构建规范、采用自动化工具来协调依赖管理等等。