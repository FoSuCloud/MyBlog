## Monorepo 演进
1. 阶段一：单仓库巨石应用， 一个 Git 仓库维护着项目代码.随着迭代业务复杂度的提升，项目代码会变得越来越多，越来越复杂，大量代码构建效率也会降低，最终导致了单体巨石应用
2. 阶段二：`多仓库多模块`应用，于是将项目拆解成多个业务模块，并在多个 Git 仓库管理，模块解耦，降低了巨石应用的复杂度.
* 每个模块都可以独立编码、测试、发版，代码管理变得简化，构建效率也得以提升，这种代码管理方式称之为 MultiRepo。
3. 阶段三：`单仓库多模块`应用，随着业务复杂度的提升，模块仓库越来越多，MultiRepo这种方式虽然从业务上解耦了，
* 但增加了项目工程管理的难度，随着模块仓库达到一定数量级.
* 会有几个问题：跨仓库代码难共享；分散在单仓库的模块依赖管理复杂
* （底层模块升级后，其他上层依赖需要及时更新，否则有问题）； 增加了构建耗时。
* 于是将`多个项目集成到一个仓库下`，`共享工程配置`，同时又快捷地共享模块代码，成为趋势，
* 这种代码管理方式称之为 `MonoRepo`。

### MultiRepo
1. 代码可见性：
   ✅ `代码隔离`，研发者只需关注自己负责的仓库
   ❌ 包管理按照各自owner划分，当出现问题时，需要到依赖包中进行判断并解决。
2. 依赖管理
   ❌ 多个仓库都有自己的 node_modules，存在依赖重复安装情况，占用磁盘内存大。
3. 代码权限
   ✅ 各项目单独仓库，不会出现代码被误改的情况，单个项目出现问题不会影响其他项目。
4. 开发迭代
   ✅ 仓库体积小，模块划分清晰，可维护性强。
   ❌ 多仓库来回切换（编辑器及命令行），项目多的话效率很低。多仓库之间存在依赖时，需要手动 npm link，操作繁琐。
   ❌ 依赖管理不便，多个依赖可能在多个仓库中存在不同版本，重复安装，npm link 时不同项目的依赖会存在冲突。
5. 工程配置
   ❌ 各项目构建、打包、代码校验都各自维护，不一致时会导致代码差异或构建差异。
6. 构建部署
   ❌ 多个项目间存在依赖，部署时需要手动到不同的仓库根据先后顺序去修改版本及进行部署，操作繁琐效率低。

#### MonoRepo场景
综合如上 Monorepo VS MultiRepo，`中大型项目，多模块项目`，更适合用 MonoRepo 方式管理代码，
在开发、协作效率、代码一致性方面都能受益。

#### Monorepo 踩坑
1、`幽灵依赖`
问题：npm/yarn 安装依赖时，存在依赖提升，某个项目使用的依赖，并没有在其 package.json 中声明，也可以直接使用，这种现象称之为 “幽灵依赖”；随着项目迭代，这个依赖不再被其他项目使用，不再被安装，使用幽灵依赖的项目，会因为无法找到依赖而报错。
方案：基于 npm/yarn 的 Monorepo 方案，依然存在 “幽灵依赖” 问题，我们可以通过 pnpm 彻底解决这个问题

2、`依赖安装耗时长`
问题：`MonoRepo 中每个项目都有自己的 package.json 依赖列表`，随着 MonoRepo 中依赖总数的增长，每次 install 时，耗时会较长。
方案：相同版本依赖提升到 Monorepo 根目录下，减少冗余依赖安装；使用 pnpm 按需安装及依赖缓存。

3、构建打包耗时长
问题：多个项目构建任务存在依赖时，往往是`串行构建 或 全量构建`，导致构建时间较长
方案：`增量构建`，而非全量构建；也可以将串行构建，优化成`并行构建`。

## Monorepo 选型
### 1、构建型 Monorepo 方案
此类工具，主要解决大仓库 Monorepo 构建效率低的问题。项目代码仓库越来越庞大，工作流（int、构建、单元测试、集成测试）也会越来越慢；这类工具，是专门针对这样的场景进行极致的性能优化。适用于包非常多、代码体积非常大的 Monorepo 项目。

#### Turborepo
#### Rush
#### Nx

### 2、轻量化 Monorepo 方案
#### Lerna
* 全部工作都交给lerna

#### npm/yarn + workspace

#### Lerna + npm/yarn + workspace
1、 `依赖管理交给 yarn workspace`
操作步骤：
1. 配置 Lerna 使用 `Yarn 管理依赖`：learn.json 中配置 `"npmClient": "yarn"`
2. 配置 Lerna 启用 `Yarn Workspaces`：
   配置 lerna.json/useWorkspaces = true
   配置根目录 package.json/workspaces = ["pacages/*"] , 此时 lerna.json 中的 packages 配置项将不再使用
   配置根目录 package.json/private = true

* `yarn` 1.x 及以上版本，新增 workspace 能力，不借助 Lerna，也可以`提供原生的 Monorepo 支持`，
* 需要在根目录下 package.json 中，声明 workspaces
```json
{
  "private": true, // 必须是私有项目
  "workspaces": ["project1", "project2/*"]
}
```
* `并且yarn把依赖提升到根目录的 node_modules 下，安装更快，体积更小`

2、Lerna 更突出工作流方面
* 使用 Lerna 命令来优化多个包的管理，如：`发包`、`版本管理`，`批量执行脚本`


#### Lerna + pnpm + workspace


